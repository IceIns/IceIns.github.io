<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搜索</title>
    <url>/2024/01/17/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>搜索</p>
<span id="more"></span>

<p>也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。</p>
<h2 id="搜索的基本概念："><a href="#搜索的基本概念：" class="headerlink" title="搜索的基本概念："></a>搜索的基本概念：</h2><p>状态：定量的描述一个唯一确定的情况。</p>
<p>状态转移：从一个状态转移到另一个状态的过程，涉及状态上信息的修改。</p>
<p>搜索树：跳过相同状态后，每一个状态视作一个结点，一个状态转移到另一个状态之间视作一条边。</p>
<h2 id="搜索的基本形式："><a href="#搜索的基本形式：" class="headerlink" title="搜索的基本形式："></a>搜索的基本形式：</h2><p>（本文讨论的 DFS 和 BFS 更多地考虑实际问题的搜索，而非图论上的 DFS 和 BFS。对于图论上的 DFS 和 BFS 具有更多更有趣的性质，将在后续中讨论）</p>
<img src="/2024/01/17/%E6%90%9C%E7%B4%A2/1.png" class="" title="咕咕咕">

<h3 id="DFS（深度优先搜索）："><a href="#DFS（深度优先搜索）：" class="headerlink" title="DFS（深度优先搜索）："></a>DFS（深度优先搜索）：</h3><p>在搜索中，DFS 表现为使用递归函数枚举所有解空间。以函数参数作为状态。递归至找到解后返回。体现在搜索树上便是深度优先。</p>
<p>例1：</p>
<p>给定 $10$ 个数，选出 $3$ 个十进制位各不相同的数且和最大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(b[<span class="number">1</span>],b[<span class="number">2</span>],b[<span class="number">3</span>]))</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">For</span>(i,<span class="number">1</span>,<span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                b[++cnt]=a[i];</span><br><span class="line">                vis[i]=<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(x+<span class="number">1</span>,sum+a[i]);</span><br><span class="line">                vis[i]=<span class="number">0</span>;</span><br><span class="line">                cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BFS（宽度优先搜索）："><a href="#BFS（宽度优先搜索）：" class="headerlink" title="BFS（宽度优先搜索）："></a>BFS（宽度优先搜索）：</h3><p>在搜索中，BFS 表现为使用队列枚举所有解空间。以队列元素作为状态。不断入队出队至找到解后终止。体现在搜索树上便是宽度优先。</p>
<p>同样解决例 1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,sum;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>],b[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">if</span>(now.x==<span class="number">3</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,now.sum);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,<span class="number">10</span>)&#123;</span><br><span class="line">    	<span class="built_in">For</span>(j,<span class="number">1</span>,now.x) <span class="keyword">if</span>(now.a[j]!=i&amp;&amp;<span class="built_in">check</span>(a[i],now.b[j]))&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur=now;</span><br><span class="line">            cur.x++;</span><br><span class="line">            cur.a[cur.x]=i;</span><br><span class="line">            cur.b[cur.x]=a[i];</span><br><span class="line">            cur.sum+=a[i];</span><br><span class="line">            q.<span class="built_in">push</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!now.x)&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur=now;</span><br><span class="line">            cur.x++;</span><br><span class="line">            cur.a[cur.x]=i;</span><br><span class="line">            cur.b[cur.x]=a[i];</span><br><span class="line">            q.<span class="built_in">push</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种搜索方式在遍历解空间角度，仅仅是实现方式不同，一个使用栈（递归栈）一个使用队列，实现功能完全相同。</p>
<h2 id="DFS-和-BFS-的比较："><a href="#DFS-和-BFS-的比较：" class="headerlink" title="DFS 和 BFS 的比较："></a>DFS 和 BFS 的比较：</h2><p>在普遍的教学中，一般以迷宫问题作为 DFS 和 BFS 的引入问题。</p>
<p>那么就来看看迷宫问题：</p>
<p>例 2：</p>
<p>给定一个 $n\times m$ 的迷宫，$0$ 表示通路，$1$ 表示障碍求从 $(1,1)$ 到 $(n,m)$ 的最短路径。</p>
<p>DFS 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n&amp;&amp;y==m)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,z);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">For</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="type">int</span> X=dx[i]+x,Y=dy[i]+y;</span><br><span class="line">        <span class="keyword">if</span>(!vis[X][Y]&amp;&amp;maze[x][y]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            vis[X][Y]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(X,Y,z+<span class="number">1</span>);</span><br><span class="line">            vis[X][Y]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(now.x==n&amp;&amp;now.y==m)&#123;</span><br><span class="line">            ans=now.z;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">For</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="type">int</span> X=now.x+dx[i],Y=now.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(maze[X][Y]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;X,Y,now.z+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察两者，比较两者的不同。</p>
<ul>
<li>DFS 需要添加 vis，要求递归过程中不能走回头路（走过的路），因为 DFS 代表一条路走到黑是典型的“不撞南墙不回头”。若允许走回头路，最直接的问题就是在两个状态之间来回横跳，陷入死循环。</li>
<li>BFS 不严格需要添加 vis，且 BFS 过程中终点第一次出队即为最短路径。因为 BFS 过程是将新状态加入队尾，在迷宫问题中满足每次路径只会增加不会减少或不变，且增量相等（都为 $1$）。而初始状态只有一个 $0$，所以 BFS 过程中的任意时候，队列的路径长度中只会有 $2$ 种值且小的在前，大的在后。也就说，出队的路径长度为单调不减且在有限个状态后一定会增。那么就一定会达到最短路径。所以不严格需要添加标记数组，只是会让无用的状态数大量增加。</li>
</ul>
<p>根据以上结论，其实可以发现，BFS 在状态转移增量恒为 1 的问题中，第一次找到的解即为最优解。</p>
<p>对于标记数组，因为迷宫问题中，状态转移增量恒为 $1$，所以走过再走一遍的路只会让答案增大。</p>
<p>同时：</p>
<ul>
<li>DFS 的标记数组需要回溯，为单独一条路径服务。</li>
<li>BFS 的标记数组不需要回溯，为全体路径共用。（注意：此条关于 BFS 标记数组的性质是因为状态转移增量为 $1$（状态转移增量相同也可视为 $1$）。而不是因为转移增量为正。若仅满足转移增量为正，不足以支撑所有点共用一个标记数组）</li>
</ul>
<p>DFS 就像一个人独自找答案，不能同时尝试多种方法；BFS 就像一群人分别找答案，在同时尝试不同方法。</p>
<p>综上，可以发现：BFS 在状态转移增量恒为 $1$ 的问题中，第一次找到的解即为最优解且时间复杂度和空间复杂度均为 $O(nm)$ 因为每个点只会被入队一次。而 DFS 在最坏情况下仍会遍历全体解空间导致时间复杂度呈指数级。</p>
<p>而增量不恒为 $1$ 的情况下，BFS 就不能体现以上性质，因为队列中的解不呈单调不减的情况了。也就不能体现和 DFS 相比的优越性了。</p>
<p>DFS 和 BFS 均为搜索算法，仅仅是搜索角度不同。但一般提到搜索，均指 DFS。而 BFS 往往只作为在转移增量恒为 $1$ 的问题中求最小解。</p>
<p>这就是 BFS 在一般问题中标记数组不能共用导致的，在 BFS 的队列中存着若干状态，而每个状态均需要一个标记数组，那么空间复杂度便达到了状态数的平方，这是许多问题不能接受的。</p>
<p>而 DFS 不同，在 DFS 递归到某一层考虑当前函数内层，只存在一个状态，vis 仅为当前状态服务，也就只需要一个标记数组，那么空间复杂度便仅仅是状态数。</p>
<h4 id="存储路径信息："><a href="#存储路径信息：" class="headerlink" title="存储路径信息："></a>存储路径信息：</h4><p>由于 DFS 采用栈存储既往状态，所以如果要求具体解的方案，只要把栈中状态依次取出即可。</p>
<p>而 BFS 不存储深度信息，只存储同一宽度的状态，自然就是不能得到到初始状态的方案，若是要求方案，就需要额外储存了。</p>
<p>这本身就是由深度和宽度而决定的，其实算不上什么优点或缺点，只是恰好实际中往往更需要求方案（即深度信息），而不是宽度信息，如果说现在有一题要求输出比最优解小 1 的状态，那么，DFS 就比不上 BFS 了。</p>
<h3 id="DFS："><a href="#DFS：" class="headerlink" title="DFS："></a>DFS：</h3><p>按深度递归，某一时刻状态数：$O(depth)$。</p>
<h3 id="BFS："><a href="#BFS：" class="headerlink" title="BFS："></a>BFS：</h3><p>按宽度递归，某一时刻状态数：$O(weight)$。</p>
<h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><h3 id="剪枝："><a href="#剪枝：" class="headerlink" title="剪枝："></a>剪枝：</h3><h4 id="可行性剪枝："><a href="#可行性剪枝：" class="headerlink" title="可行性剪枝："></a>可行性剪枝：</h4><p>若当前情况已经不符合题意则可以直接返回，而不需要走到头。</p>
<p>如例 $1$ 中，若搜索的第二个数已经不满足和第一个数匹配，那就没有必要继续搜索第三个数了。</p>
<h4 id="最优性剪枝："><a href="#最优性剪枝：" class="headerlink" title="最优性剪枝："></a>最优性剪枝：</h4><p>若当前情况已经劣于已经找到的最优解时，直接返回。</p>
<p>如例 $2$ 中，若当前搜到的路径已经比 $ans$ 大了，就不用继续搜了。</p>
<h4 id="搜索顺序剪枝："><a href="#搜索顺序剪枝：" class="headerlink" title="搜索顺序剪枝："></a>搜索顺序剪枝：</h4><p>虽然从某种意义上说，这仅仅是“骗过了数据”。</p>
<p>但是不可否认的是大多情况下，改变搜索顺序可以优化搜索效率。</p>
<p>如例 $1$ 中，若从最大的数开始向小的数搜索，那么效率显然更优。</p>
<h4 id="Alpha-Beta："><a href="#Alpha-Beta：" class="headerlink" title="Alpha-Beta："></a>Alpha-Beta：</h4><h4 id="人类智慧："><a href="#人类智慧：" class="headerlink" title="人类智慧："></a>人类智慧：</h4><p>以上剪枝策略只是形式化的剪枝策略。还可以利用人类智慧来进行剪枝：</p>
<ul>
<li>极端法：考虑极端情况，如果最极端的情况都不满足，那一定不满足。</li>
<li>调整法：通过对子树的对比剪掉重复子树和明显不是最优的子树。</li>
<li>数学方法：比如在图论中借助连通分量，数论中借助模方程的分析，借助不等式的放缩来估计下界等等。</li>
</ul>
<h3 id="记忆化搜索："><a href="#记忆化搜索：" class="headerlink" title="记忆化搜索："></a>记忆化搜索：</h3><h3 id="双向搜索："><a href="#双向搜索：" class="headerlink" title="双向搜索："></a>双向搜索：</h3><h4 id="同时双向搜索："><a href="#同时双向搜索：" class="headerlink" title="同时双向搜索："></a>同时双向搜索：</h4><h4 id="meet-in-middle："><a href="#meet-in-middle：" class="headerlink" title="meet in middle："></a>meet in middle：</h4><h3 id="A-："><a href="#A-：" class="headerlink" title="A*："></a>A*：</h3><h3 id="迭代加深搜索："><a href="#迭代加深搜索：" class="headerlink" title="迭代加深搜索："></a>迭代加深搜索：</h3><h3 id="IDA-："><a href="#IDA-：" class="headerlink" title="IDA*："></a>IDA*：</h3><h3 id="Dancing-Links："><a href="#Dancing-Links：" class="headerlink" title="Dancing Links："></a>Dancing Links：</h3><h3 id="启发式搜索："><a href="#启发式搜索：" class="headerlink" title="启发式搜索："></a>启发式搜索：</h3>]]></content>
      <categories>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构（四）</title>
    <url>/2024/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>莫队</p>
<span id="more"></span>

<p>普通莫队是一个基于分块的离线解决静态区间询问问题的算法。</p>
<p>但莫队算法扩展性极强，具有许多扩展莫队算法，</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>设询问区间为 $[l_i,r_i]$。对原序列索引分块。将询问区间离线后以 $l_i$ 所在块的编号为第一关键字，$r_i$ 为第二关键字升序。</p>
<p>对于每个询问 $[l_i,r_i]$ 的答案，由 $[l_1,r_1]$ 扩展而来，每次用 while 暴力移动 $l,r$ 指针。</p>
<p>此时，升序后的 $[l_i,r_i]$ 呈现，同一块内的 $l_i$ 对应的询问 $[l_i,r_i]$ 视作一个整体，共有 $\frac nt$ 个块。在一个块内的 $r$ 最多移动 $n$ 次（因为同一块内的 $r$ 升序，最多从 $1$ 移动到 $n$。在同一个块内 $l$ 每次扩展最多移动 $t$ 次。同时，从一个块的右端点询问的 $l$ 向下一个块的左端点的 $l$ 扩展时，$l$ 最多移动 $2t$，$r$ 最多移动 $n$。</p>
<p>综上：处理完 $m$ 个询问，$l,r$ 指针的总移动次数为：$O(\frac{n^2}{t}+mt)$。</p>
<p>当 $t&#x3D;\frac{n}{\sqrt m}$ 时，时间复杂度最优为：$O(n\sqrt m)$。</p>
<p>一般认为 $n,m$ 同阶，所以直接取 $\sqrt n$。</p>
<p>上述只是考虑了指针移动次数。每次指针移动都要一次更新操作的时间复杂度。根据更新的复杂度不同，莫队的时间复杂度不同。</p>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="关于四个循环位置的讨论："><a href="#关于四个循环位置的讨论：" class="headerlink" title="关于四个循环位置的讨论："></a>关于四个循环位置的讨论：</h3><p>莫队区间的移动过程，就相当于加入了 $[1,r]$ 的元素，并删除了 $[1,l-1]$ 的元素，因此：</p>
<ul>
<li>对于 $l\leq r$ 的情况，$[1,l-1]$ 的元素相当于被加入了一次又被删除了一次，$[l,r]$ 的元素被加入一次，$[r+1,+∞)$ 的元素没有被加入。这个区间是合法区间。</li>
<li>对于 $l&#x3D;r+1$ 的情况，$[1,r]$ 的元素相当于被加入了一次又被删除了一次，$[r+1,+∞)$ 的元素没有被加入。这时这个区间表示空区间。</li>
<li>对于 $l&gt;r+1$ 的情况，那么 $[r+1,l-1]$（这个区间非空）的元素被删除了一次但没有被加入，因此这个元素被加入的次数是负数。</li>
</ul>
<p>代码中四个 while 循环一共有 $4!&#x3D;24$ 种排列顺序，不妨设第一个为移动 $l$，那么只考虑 $12$ 种，剩下 $12$ 种对称。 </p>
<img src="/2024/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/1.png" class="" title="咕咕咕">

<h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><p>奇偶化排序：对奇数块内的询问的 $r$ 进行升序，对偶数块内的询问的 $r$ 进行降序。</p>
<p>这是很自然的，因为按原本的排序方式，每次进入一个新块时，r 都会从最大值降到最小值，再又升到最大值。这当然是不优的。</p>
<p>当然，这并不能改变复杂度，只是一个常用的有效的常数优化。</p>
<h2 id="扩展：-1"><a href="#扩展：-1" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="带修莫队："><a href="#带修莫队：" class="headerlink" title="带修莫队："></a>带修莫队：</h3><h3 id="回滚莫队："><a href="#回滚莫队：" class="headerlink" title="回滚莫队："></a>回滚莫队：</h3><h3 id="树上莫队："><a href="#树上莫队：" class="headerlink" title="树上莫队："></a>树上莫队：</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构（三）</title>
    <url>/2024/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>分块</p>
<span id="more"></span>

<p>分块是优美的暴力，但却并不是暴力。</p>
<p>常见分块为根号分块，一种基于根号均衡的根号算法。</p>
<p>在数据结构问题中，一般使用的为序列分块。</p>
<h2 id="根号均衡："><a href="#根号均衡：" class="headerlink" title="根号均衡："></a>根号均衡：</h2><p>$a\times b&#x3D;n$，$\min\lbrace a,b\rbrace\leq \sqrt n$.</p>
<p>$a+\frac na\geq 2\sqrt n$</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>序列分块。</p>
<p>将原序列按 $t$ 为块长，划分成 $\frac nt$ 块。</p>
<img src="/2024/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/1.png" class="" title="咕咕咕">

<h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>对于一个区间 $[l,r]$，一定可以拆分成：</p>
<ul>
<li>块的三部分：$l$ 到 $l$ 所在块的右端点；$l$ 所在块的下一块到 $r$ 所在块的上一块；$r$ 所在块的左端点到 $r$。</li>
<li>特殊情况：$l,r$ 在同一块内。</li>
</ul>
<p>对于块的三部分，一个块为一个整体，共有 $O(\frac nt)$ 个块，$l$ 和 $r$ 的块内元素共有 $O(t)$ 个。同样的，$l,r$ 在同一块内，元素个数为 $O(t)$ 个。$r$ 的块内元素共有 $O(t)$ 个。同样的，$l,r$ 在同一块内，元素个数为 $O(t)$ 个。</p>
<h2 id="分（建）块："><a href="#分（建）块：" class="headerlink" title="分（建）块："></a>分（建）块：</h2><p>枚举块的编号，遍历块的范围内元素以维护整块信息即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bh</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)/t+<span class="number">1</span>;&#125;<span class="comment">//计算 x 所在的块的编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)*t+<span class="number">1</span>;&#125;<span class="comment">//计算第 x 个块的左端点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">min</span>(n,x*t);&#125;<span class="comment">//计算 x 个块的右端点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,<span class="built_in">bh</span>(n))</span><br><span class="line">    <span class="built_in">For</span>(j,<span class="built_in">left</span>(i),<span class="built_in">right</span>(i))</span><br><span class="line">    	block[i].sum+=a[j];</span><br></pre></td></tr></table></figure>

<p>注意一点：$n$ 是序列的右端点，但不一定是整块的右端点，要小心处理。体现在代码中，计算块的右端点时，和 $n$ 取 $\min$。</p>
<h2 id="询问："><a href="#询问：" class="headerlink" title="询问："></a>询问：</h2><p>以区间求和为例分析，若维护整块的和，散块暴力累计。则单次询问时间为 $O(t+\frac nt)$。当 $t&#x3D;\sqrt n$ 时，$O(t+\frac nt)$ 取得最小值，为 $O(2\sqrt n)$。所以一般块长设为 $\sqrt n$。</p>
<p>但是具体题目具体分析。由于不同题目限制不同，所得时间复杂度也不尽相同，所以块长也会做相应调整。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="built_in">bh</span>(l)+<span class="number">1</span>,<span class="built_in">bh</span>(r)<span class="number">-1</span>) res+=block[i].sum;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bh</span>(l)==<span class="built_in">bh</span>(r))&#123;</span><br><span class="line">        <span class="built_in">For</span>(i,l,r) res+=a[i]+block[<span class="built_in">bh</span>(i)].tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">For</span>(i,l,<span class="built_in">right</span>(<span class="built_in">bh</span>(l))) res+=a[i]+block[<span class="built_in">bh</span>(i)].tag;</span><br><span class="line">        <span class="built_in">For</span>(i,<span class="built_in">left</span>(<span class="built_in">bh</span>(r)),r) res+=a[i]+block[<span class="built_in">bh</span>(i)].tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h2><p>与询问一致，同样是散块暴力，整块整体维护。</p>
<p>但是此时存在一个问题：修改时维护了整块的整体的答案，但是整块内的信息并未得到维护，而在之后的询问中，询问到散块信息时，是需要整块内的信息的，所以这里需要借助和线段树一样的懒标记。</p>
<p>进行区间修改时，维护懒标记的信息。需要用到散块信息时，则将懒标记下传，维护散块信息。后重新维护整块信息。</p>
<p>笔者将下传标记维护散块信息写作 <code>down</code>，重新维护整块信息写作 <code>up</code>，两个过程一同视作块的重构过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="built_in">left</span>(<span class="built_in">bh</span>(l)),<span class="built_in">right</span>(<span class="built_in">bh</span>(r))) a[i]+=block[<span class="built_in">bh</span>(l)].tag;</span><br><span class="line">    block[<span class="built_in">bh</span>(l)].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,l,r) a[i]+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    block[x].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="built_in">left</span>(x),<span class="built_in">right</span>(x)) block[x].sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="built_in">bh</span>(l)+<span class="number">1</span>,<span class="built_in">bh</span>(r)<span class="number">-1</span>)</span><br><span class="line">        block[i].tag+=v,block[i].sum+=v*t;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bh</span>(l)==<span class="built_in">bh</span>(r))&#123;</span><br><span class="line">        <span class="built_in">down</span>(l,r,v);</span><br><span class="line">        <span class="built_in">up</span>(<span class="built_in">bh</span>(l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">down</span>(l,<span class="built_in">right</span>(<span class="built_in">bh</span>(l)),v);</span><br><span class="line">        <span class="built_in">up</span>(<span class="built_in">bh</span>(l));</span><br><span class="line">        <span class="built_in">down</span>(<span class="built_in">left</span>(<span class="built_in">bh</span>(r)),r,v);</span><br><span class="line">        <span class="built_in">up</span>(<span class="built_in">bh</span>(r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，对于维护可标记永久化的信息，使用标记永久化也可（就比如上文中的区间求和）。</p>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="例题讲解："><a href="#例题讲解：" class="headerlink" title="例题讲解："></a>例题讲解：</h3><p><a href="https://www.luogu.com.cn/blog/yrj20201208/fen-kuai-ru-men">分块入门-咕咕咕-LibreOJ数列分块入门</a></p>
<h3 id="值域分块："><a href="#值域分块：" class="headerlink" title="值域分块："></a>值域分块：</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces-Round-920-Div3</title>
    <url>/2024/01/16/Codeforces-Round-920-Div3/</url>
    <content><![CDATA[<p>A-D，耻辱之夜。</p>
<span id="more"></span>

<h2 id="A-Square"><a href="#A-Square" class="headerlink" title="A.Square"></a>A.Square</h2><p>题意：以任意顺序给出正方形的四个顶点坐标，求面积。</p>
<p>解：</p>
<p>$(\max\lbrace x\rbrace-\min\lbrace x\rbrace)^2$ 即可。</p>
<h2 id="B-Arranging-Cats"><a href="#B-Arranging-Cats" class="headerlink" title="B.Arranging Cats"></a>B.Arranging Cats</h2><p>题意：可以取出，交换，放入 $1$，求将 $a$ 变成 $b$ 的最小操作数。</p>
<p>解：</p>
<p>首先，对于 $a_i&#x3D;b_i$ 的位置，不用考虑，</p>
<p>其次，那就只有 $a_i&#x3D;1,b_i&#x3D;0$ 或 $a_i&#x3D;0,b_i&#x3D;1$ 的情况了。贪心地想，先移动 $1$ 去匹配 $1<br>$，然后把多的 $1$ 取出即可。 </p>
<p>答案就是 $\max\lbrace[a_i&#x3D;1],[b_i&#x3D;1]\rbrace$。</p>
<h2 id="C-Sending-Messages"><a href="#C-Sending-Messages" class="headerlink" title="C.Sending Messages"></a>C.Sending Messages</h2><p>题意：在 $t_i$ 时刻，手机必须是开机状态。开机状态下，每持续 $1s$，消耗 $a$ 能量；关机不消耗能量，但是开机消耗 $b$ 的能量，初始第 $0s$ 有 $c$ 的能量且出于开机状态。判断是否可以在能量耗尽前满足 $n$ 个时刻都是开机状态。</p>
<p>解：</p>
<p>$t_i$ 必是开机状态，那么 $t_i$ 时刻之后便与 $t_i$ 之前无关，即：贪心地让 $t_i$ 时刻的能量尽可能大即可。在 $t_{i-1}$ 到 $t_i$ 之间，只能是开机一次，或者全程开机。那么比较一下这两者的大小即可。</p>
<h2 id="D-Very-Different-Array"><a href="#D-Very-Different-Array" class="headerlink" title="D.Very Different Array"></a>D.Very Different Array</h2><p>题意：给定两个序列 $a_n$ 和 $b_m$，要求在 $b_m$ 中选出 $n$ 个数使得 $\sum\limits_{i&#x3D;1}^n|a_i-c_i|$ 最大。求最大值。</p>
<p>解；</p>
<p>贪心地想，将 $b_m$ 中大的和 $a_n$ 中小的进行匹配，$b_m$ 中小的和 $a_n$ 中大的进行匹配。</p>
<p>答案与序列的顺序无关，那么可以先将 $a_n,b_m$ 升序，然后用 $b_m$ 的后缀和 $a_n$ 的前缀匹配，$b_m$ 的前缀和 $a_n$ 的后缀匹配即可。枚举这个分界点，一定可以找到最大值。</p>
<p>证明：</p>
<p>引理：</p>
<p>最后的答案形式一定是：</p>
<ul>
<li>在分界点前（含分界点），$a_i&lt;b_i$。</li>
<li>在分界点后：$a_i&gt;b_i$</li>
</ul>
<p>因为如果在分界点后，存在一个位置 $a_i&lt;b_i$，那么 $b_i$ 完全可以移到 $a_i$ 的前面，因为 $a_j&lt;a_i(j&lt;i)$，在前面同样满足 $a_j&lt;b_i$ 且此时答案会变大。</p>
<p>此时，若 分界点前的，不是 $b_m$ 的后缀，那么在 $b_m$ 中一定存在一个比分界点前的 $b_i$ 大的元素去替换它了。</p>
<h2 id="E-Eat-the-Chip"><a href="#E-Eat-the-Chip" class="headerlink" title="E.Eat the Chip"></a>E.Eat the Chip</h2><p>题意：Alice 每次可以向 $(x+1,y-1),(x+1,y),(x+1,y+1)$ 移动，Bob 每次可以向 $(x-1,y-1),(x-1,y),(x-1,y+1)$ 移动。一方将棋子移动到另一方上则该方获胜，反之则是平局，求胜者。</p>
<p>解：</p>
<p>引理：</p>
<p>若 $y_0&#x3D;y_1$，即 Alice 和 Bob 在同一列：</p>
<ul>
<li>$|x_0-x_1|$ 为奇数时，Alice 必胜。</li>
<li>$|x_0-x_1|$ 为偶数时，Bob 必胜。</li>
</ul>
<p>假设 $|x_0-x_1|$ 为偶数时，后手必胜。</p>
<p>那么，$|x_0-x_1|$ 为奇数时，先手往下走，使 $|x_0-x_1|$ 为偶数，且仍满足 $y_0&#x3D;y_1$，那么此时的后手必胜即为初始时的先手必胜。</p>
<p>核心变成 $|x_0-x_1|$ 为偶数时，后手必胜：</p>
<p>策略：无论先手怎么走，后手都选择走到和对方同一列。</p>
<p>那么每次 $|x_0-x_1|$ 变小 $1$，因为 $|x_0-x_1|$ 为偶数，那么最后就是后手必胜。</p>
<p>对于 $y_0\neq y_1$ 的情况：</p>
<ul>
<li>若 $|x_0-x_1|$ 为奇数，那么 Bob 不能获胜，容易发现 $|x_0-x_1|$ 为奇数时最后一步（使得 $x_0&#x3D;x_1$ 的那步）一定是 Alice 走出来的。</li>
<li>若 $|x_0-x_1|$ 为偶数，那么 Alice 不能获胜。同上。</li>
</ul>
<p>所以：</p>
<ul>
<li>$|x_0-x_1|$ 为奇数时，Alice 要在 y 轴追上 Bob，而 Bob 要尽可能地远离 Alice。因为一旦移动的过程中，出现了 $y_0&#x3D;y_1$，那就是 Alice 获胜。所以 Alice 要朝 Bob 的方向移动，Bob 要朝面向 Alice 的另一个方向移动。</li>
<li>$|x_0-x_1|$ 为偶数时，同上。</li>
</ul>
<p>因为 $h\leq 10^6$，所以最多走 $10^6$ 步，所以模拟这个过程即可。</p>
<p>同时，因为奇偶交替的强性质，直接用式子 $O(1)$ 判断也可以。</p>
<h2 id="F-Sum-of-Progression"><a href="#F-Sum-of-Progression" class="headerlink" title="F.Sum of Progression"></a>F.Sum of Progression</h2><p>题意：$q$ 次询问 $s,d,k$ 求 $a_s+a_{s+d}\times2+…+a_{s+(k-1)d}\times k$。</p>
<p>解：</p>
<p>对索引等差求和是根号分治的一种经典思路。</p>
<p>先考虑这样一个问题：</p>
<p>求 $\sum\limits_{i&#x3D;l}^r(i-l+1)\times a_i$。</p>
<p>先把式子拆成：$\sum\limits_{i&#x3D;l}^ri\times a_i-(l-1)\sum\limits_{i&#x3D;l}^ra_i$。</p>
<p>然后对前后两部分分别做前缀和差分即可。</p>
<p>那么此题也是一样。</p>
<p>设阈值为 $t$：</p>
<ul>
<li>若 $d&gt;t$，$k\leq\lfloor\frac{n}{d}\rfloor&lt;\lfloor\frac{n}{t}\rfloor$。暴力求和即可。</li>
<li>若 $d\leq t$，用上述套路解决。$sum[i][j][0&#x2F;1]$ 表示公差为 $j$ 的前 $i$ 个数的两种前缀和。</li>
</ul>
<p>时间复杂度：$O(q\lfloor\frac{n}{t}\rfloor)$。</p>
<p>空间复杂度：$O(nt)$。</p>
<p>直接将 $t$ 设为 $\sqrt n$ 即可。</p>
<p>时间复杂度；$O(n\sqrt n)$。</p>
<p>空间复杂度：$O(n\sqrt n)$。</p>
<h3 id="addition："><a href="#addition：" class="headerlink" title="addition："></a>addition：</h3><p>看到一种不显式设阈值分析的根号算法。</p>
<p>将询问离线。对于每个 $s\bmod d$，求从 $s\bmod d$ 开始的公差为 $d$ 的一个序列。同样使用前文中的两种前缀和维护。每次询问时，直接 $O(1)$ 差分询问即可。这样的询问时间复杂度就是 $O(q)$ 的了。</p>
<p>考虑从 $s\bmod d$ 开始的公差为 $d$ 的序列的维护。对于一组 $s\bmod d$，直接暴力加公差的时间复杂度为 $O(\frac{n}{d})$。但是对于同一组 $(s\bmod d,d)$（即：起点和公差相同的情况）可以略去。</p>
<p>因为 $s\bmod d$ 的值只有 $[0,d)$，所以一<strong>种</strong> $d$ 的值会产生 $d\times \frac{n}{d}&#x3D;n$ 的时间消耗。那么总共只有 $n$ 个 $d$，所以最多只会有 $\sqrt n\times n$ 的时间消耗。</p>
<p>因为 $1+2+…+d&#x3D;\frac{d\times(d+1)}{2}$，$d\leq \sqrt n$。所以最多也就只有 $\sqrt n$ 种 $d$，所以暴力预处理的时间复杂度也只有 $O(n\sqrt n)$。</p>
<p>空间复杂度同样为 $O(n\sqrt n)$。</p>
<p>但是是暴力。而且不用设阈值。</p>
<h2 id="G-Mischievous-Shooter"><a href="#G-Mischievous-Shooter" class="headerlink" title="G.Mischievous Shooter"></a>G.Mischievous Shooter</h2><p>待补。</p>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构（二）</title>
    <url>/2024/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>线段树</p>
<span id="more"></span>

<p>千呼万唤始出来。</p>
<p>线段树是算法竞赛中最常用的、应用最广的用来维护 <strong>区间信息</strong> 的数据结构。</p>
<p>线段树可以在 $O(\log n)$ 的时间复杂度内实现单点修改、区间修改、区间查询等操作。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>线段树将每个长度不为 $1$ 的区间划分成左右两个区间递归求解，把整个线段划分成一个树形结构。</p>
<p>设 $x$ 的管辖区间为 $[l,r]$，则 $x$ 的左儿子的管辖区间为 $[l,mid]$，$x$ 的右儿子的管辖区间为 $[mid+1,r]$。</p>
<img src="/2024/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/1.jpg" class="" title="咕咕咕">

<p>在实际应用中，采用二进制编码的方式表示树上的结点：</p>
<p>设当前结点为 $x$，则左儿子为 $x&lt;&lt;1$，右儿子为 $x&lt;&lt;1|1$。</p>
<p>（用一个结构体维护结点蕴含所有信息，把左右儿子的序号直接存进结构体也是一种常见写法，但是笔者看来更适合之后的动态开点线段树）</p>
<p>因为这样的堆式存储使得部分结点就算在线段树没有实际左右儿子，但是同样会占用数组内存，所以线段树总结点个数为 $2^{\lceil{\log n}\rceil+1}-1$。当 $n&#x3D;2^x+1$ 时，结点树数取得最大值：$4n-5$。所以一般线段树开 $4n$ 的空间。</p>
<h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>对于一个 $[x,y]$ 一定能被拆分成 $O(\log n)$ 个线段树上结点所表示的区间并。</p>
<p>这是支持线段树完成 $O(\log n)$ 实现区间操作的基本原理。</p>
<p>证明：</p>
<p>在线段树上递归时，考虑第一个中点位于 $[x,y]$ 之间的区间 $[l,r]$。此时，$[x,y]$ 便可以依 $mid$ 划分为两部分：$[x,mid]$ 和 $[mid+1,y]$。$mid$ 是 $[l,mid]$ 的右端点，$mid+1$ 是 $[mid+1,r]$ 的左端点。</p>
<p>先考虑 $[mid+1,r]$ 中划分 $[mid+1,y]$ 的情况。</p>
<p>容易发现，$[mid+1,r]$ 中划分 $[mid+1,y]$ 的第一个区间长度是 $\leq y-mid$ 的最大 $2$ 的整数幂。之后的递归也是同理，所以 $[mid+1,y]$ 就被划分成了若干个严格递减的 $2$ 的整数幂长度的区间，容易发现，这个至多是 $O(\log n)$ 级别的。$[l,mid]$ 划分 $[x,mid]$ 同理。</p>
<p>综上：一个 $[x,y]$ 一定能被拆分成 $\log n$ 个线段树上结点所表示的区间并。</p>
<p>（本文以线段树维护区间和，区间加示例）</p>
<h2 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h2><p>按定义所规定的管辖区间递归建树即可。用子结点信息更新父节点信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[t].sum=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(t&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">push_up</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间询问："><a href="#区间询问：" class="headerlink" title="区间询问："></a>区间询问：</h2><p>在具体的线段树代码实现中，不唯一，不局限。只要本质相同即可。</p>
<p>下面以笔者代码分析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> tr[t].sum;<span class="comment">//返回信息</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(t&lt;&lt;<span class="number">1</span>,l,mid,x,y);<span class="comment">//返回左儿子的信息</span></span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);<span class="comment">//返回右儿子的信息</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当递归到的结点所在区间完全包含于询问区间，则直接返回结点信息。</p>
<p>询问区间在递归时，可以改成前文中的 $[x,mid]$ 和 $[mid+1,y]$，不影响结果。因为之后递归的结点区间若完全包含于 $[x,mid]$ 或 $[mid+1,y]$ 则一定也完全包含于 $[x,y]$。</p>
<h2 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h2><p>线段树的单点修改较区间修改更复杂，下面先考虑单点修改。</p>
<p>（单点修改是区间修改的子集，若线段树一定能支持某类操作的区间修改，则一定能支持单点修改，反之不然）</p>
<p>从线段树的根节点开始，递归到 $[x,x]$ 所在结点。后回溯更新祖先结点信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;<span class="comment">//l=r一定满足l=x=r</span></span><br><span class="line">        tr[t],sum+=v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>,l,mid,x,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,v);</span><br><span class="line">    <span class="built_in">push_up</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子结点信息更新父节点信息："><a href="#子结点信息更新父节点信息：" class="headerlink" title="子结点信息更新父节点信息："></a>子结点信息更新父节点信息：</h2><p>一般将此操作写作 <code>push_up</code> 作为一个单独的函数出现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void push_up(int t)&#123;</span><br><span class="line">    tr[t].sum=tr[t&lt;&lt;1].sum+tr[t&lt;&lt;1|1].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间修改："><a href="#区间修改：" class="headerlink" title="区间修改："></a>区间修改：</h2><p>类比区间询问，将修改区间 $[x,y]$ 拆分成线段树上 $O(\log n)$ 个区间。把修改的信息标记到这个区间上。但是这时候就能发现，这样并没有维护住线段树的定义信息。标记的区间的儿子结点的信息没有更新，标记的区间的父节点的信息也没有更新。可要让所有结点的信息都完成更新，则需要修改 $O(n)$ 个结点的信息，这是不能接受的。</p>
<h3 id="标记永久化："><a href="#标记永久化：" class="headerlink" title="标记永久化："></a>标记永久化：</h3><p>修改操作和询问操作是紧密联系在一起的，如果不支持询问的操作，那么修改的支持便毫无意义。</p>
<p>以区间加，单点查询为例：</p>
<p>因为单点查询时，必然递归经过所有包含单点的区间。所以可以把修改的信息和初始信息分开考虑，将标记就固定在修改到的区间上。那么在查询时，把递归路径上经过的区间上的标记信息累计起来即可。</p>
<p>但是对于区间询问，就有所不同，因为区间询问时不会递归到拆分之后的区间的后代结点，而若修改的标记标记到了某个拆分之后的区间的后代结点上，就会对答案产生影响。所以对于区间询问，永久化的标记同样要作用于祖先结点。查询时只会查询到标记的某一个祖先结点而不会有多个，所以不影响答案。</p>
<p>同时，标记永久化具有较大的局限性，例如在信息不可直接叠加值时，便不具有可永久化的性质。比如：区间赋值；同时维护区间加和区间乘。</p>
<p>标记永久化也有它的优点，例如：不用像懒标记那样下传标记，常数较小；在可持久化线段树中，对区间修改标记永久化，空间复杂度可以少乘 $O(\log n)$ 。</p>
<h3 id="懒标记："><a href="#懒标记：" class="headerlink" title="懒标记："></a>懒标记：</h3><p>对于懒的解释：延迟下传。</p>
<p>在前文考虑维护住线段树定义时，是因为要保证其它点也满足线段树的定义。但是，</p>
<p><strong>修改操作和询问操作是紧密联系在一起的</strong>。试想，如果在后续的询问操作中，没有用到这里修改操作所涉及的点，那么是否还需要去把所有点都更新？</p>
<p>因此，秉持不用不管的原则，只有当询问操作递归经过这个区间时，才将这个区间上的标记信息下传更新子结点的信息。至于父结点信息，在修改操作递归到这个区间的过程中直接修改即可。</p>
<p>注意，懒标记的标记与标记永久化的标记不同，懒标记的标记是与线段树结点的信息结合起来的，是需要通过懒标记去修改结点上的信息的。而标记永久化的标记是与线段树结点的信息独立的。也就是标记永久化过程中的结点信息是不变的（始终为建树时的信息）而懒标记过程中的结点信息是会随着懒标记的下传而更新的（当前结点的懒标记下传后，懒标记信息清空，结点信息更新）</p>
<p>懒标记具有较强的扩展性，可以维护更多信息。但是需要维护的内容更多，代码更长。</p>
<p>懒标记中，懒标记下传函数一般写作 <code>push_down</code>，结点信息更新一般不写成函数，笔者写作 <code>eval</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(node &amp;t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    t.tag+=v;<span class="comment">//维护懒标记信息</span></span><br><span class="line">    t.sum+=v*(r-l+<span class="number">1</span>);<span class="comment">//维护结点信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">eval</span>(tr[t&lt;&lt;<span class="number">1</span>],l,mid,tr[t].tag);<span class="comment">//懒标记下传左儿子</span></span><br><span class="line">    <span class="built_in">eval</span>(tr[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],mid+<span class="number">1</span>,r,tr[t].tag);<span class="comment">//懒标记下传右儿子</span></span><br><span class="line">    tr[t].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒标记还有一个要注意的点，何时 <code>push_down</code>。</p>
<p>根据前文：“不用不管”，那么就是说只要递归到了这个区间，那就要 <code>push_down</code>。所以在递归前就 <code>push_down</code> 且任何修改和询问操作，只要递归到了这个点，就应该 <code>push_down</code>，一般应用中，<code>push_down</code> 的位置置于 <code>if</code> 后面，递归前面。</p>
<p>下面是完整的区间加、区间和的懒标记线段树代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> For(i,a,b) for(i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,a,b) for(i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> sum,tag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sege</span>&#123;</span><br><span class="line">	node tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">		tr[t].sum=tr[t&lt;&lt;<span class="number">1</span>].sum+tr[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(node &amp;t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">		t.tag+=v;</span><br><span class="line">		t.sum+=v*(r-l+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">eval</span>(tr[t&lt;&lt;<span class="number">1</span>],l,mid,tr[t].tag);</span><br><span class="line">		<span class="built_in">eval</span>(tr[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],mid+<span class="number">1</span>,r,tr[t].tag);</span><br><span class="line">		tr[t].tag=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">			tr[t].sum=a[l];</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">build</span>(t&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">		<span class="built_in">build</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="built_in">push_up</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">			<span class="built_in">eval</span>(tr[t],l,r,v);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">push_down</span>(t,l,r);</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>,l,mid,x,y,v);</span><br><span class="line">		<span class="keyword">if</span>(y&gt;mid) <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y,v);</span><br><span class="line">		<span class="built_in">push_up</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> tr[t].sum;</span><br><span class="line">		<span class="built_in">push_down</span>(t,l,r);</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(t&lt;&lt;<span class="number">1</span>,l,mid,x,y);</span><br><span class="line">		<span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m,i,l,r,v,op;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">For</span>(i,<span class="number">1</span>,n) cin&gt;&gt;a[i];</span><br><span class="line">	tree.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;</span><br><span class="line">			tree.<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			cout&lt;&lt;tree.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="动态开点线段树："><a href="#动态开点线段树：" class="headerlink" title="动态开点线段树："></a>动态开点线段树：</h3><h3 id="值域线段树："><a href="#值域线段树：" class="headerlink" title="值域线段树："></a>值域线段树：</h3><h3 id="可持久化线段树："><a href="#可持久化线段树：" class="headerlink" title="可持久化线段树："></a>可持久化线段树：</h3><h3 id="线段树合并："><a href="#线段树合并：" class="headerlink" title="线段树合并："></a>线段树合并：</h3><h3 id="线段树分裂："><a href="#线段树分裂：" class="headerlink" title="线段树分裂："></a>线段树分裂：</h3><h3 id="线段树优化建图："><a href="#线段树优化建图：" class="headerlink" title="线段树优化建图："></a>线段树优化建图：</h3><h3 id="线段树分治："><a href="#线段树分治：" class="headerlink" title="线段树分治："></a>线段树分治：</h3><h3 id="zkw-线段树："><a href="#zkw-线段树：" class="headerlink" title="zkw 线段树："></a>zkw 线段树：</h3><h3 id="势能线段树："><a href="#势能线段树：" class="headerlink" title="势能线段树："></a>势能线段树：</h3><h3 id="李超线段树："><a href="#李超线段树：" class="headerlink" title="李超线段树："></a>李超线段树：</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构（一）</title>
    <url>/2024/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>树状数组</p>
<span id="more"></span>

<p>树状数组是一种基于二进制位性质的类树形结构，可以 $O(\log n)$ 进行单点修改，$O(\log n)$ 进行前缀询问的数据结构。</p>
<h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>$lowbit(x)&#x3D;x\And-x$</p>
<p>$lowbit(x)$ 定义为非负整数 $x$ 在二进制表达下，最低位的 $1$ 及其后面的 $0$ 构成的二进制数。同时也是最大的整除 $x$ 的 $2$ 的整数幂。</p>
<p>证明：</p>
<p>在计算机中，负整数的二进制表示，为正整数的二进制取反后加 $1$ 。</p>
<p>也就是保留从后往前第一个 $1$ 后将其它位置取反。</p>
<p>所以 $x\And-x$ 即为 $x$ 在二进制表达下，最低位的 $1$ 及其后面的 $0$ 构成的二进制数。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>树状数组定义了 $tr[x]$ 表示区间 $[x-lowbit(x)+1,x]$ 的信息和。我们称这个区间为 $x$ 的管辖区间。</p>
<img src="/2024/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class="" title="咕咕咕">

<h2 id="询问："><a href="#询问：" class="headerlink" title="询问："></a>询问：</h2><p>那么对于一个前缀区间 $[1,x]$，一定能拆分成 $x$ 的二进制上 $1$ 的位数个 $tr[x]$ 的和。</p>
<p>例如 $[1,5]$ 可以划分成 $[5,5]$ 和 $[1,4]$ 两个。</p>
<p>$5:[100+1,101] 4:[000+1,100]$</p>
<p>那么将这二进制位数个 $tr[x]$ 相加就实现了 $O(\log n)$ 的前缀查询，因为二进制位数是 $O(\log n)$ 级别的，而且是不大于 $O(\log n)$ 的。</p>
<p>每一次 $-lowbit(x)$ 即可得到下一个区间。</p>
<h2 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h2><p>要修改的是 $x$ 位置的单点值，但是我们需要修改不止一个 $tr[x’]$。因为是否修改 $tr[x’]$ 是取决于 $tr[x’]$ 是否覆盖了 $x$。</p>
<h3 id="解释-1-："><a href="#解释-1-：" class="headerlink" title="解释 $1$："></a>解释 $1$：</h3><p>$tr[x’]$ 所管辖的区间为 $[x’-lowbit(x’)+1,x’]$。当 $x’-lowbit(x’)\leq x\land x\leq x’$ 时，tr[x’] 覆盖了 $x$。此时 $x’$ 满足，$x’$ 除 $lowbit(x’)$ 外的高位 为 $x$ 的前缀，且 $lowbit(x’)$ 为 $1$ 的这一位 $x$ 为 $0$。</p>
<p>这样的 $x’$ 可以通过 $x$ 开始不断 $+lowbit(x)$ 得到。</p>
<h3 id="解释-2-："><a href="#解释-2-：" class="headerlink" title="解释 $2$："></a>解释 $2$：</h3><p>根据树状数组的树形结构，$tr[x’]$ 覆盖了 $x$ 当且仅当 $x’$ 是 $x$ 的祖先结点，那么不断跳父节点就可以得到 $x’$ 了，而跳父节点的操作，在树状数组上就是 $+lowbit(x)$。</p>
<p>每一次 $+lowbit(x)$ 都会变成下一个 $1$ 更高的第一个 $0$ 的位。所以时间复杂度同样是 $O(\log n)$ 的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="type">int</span> tr[N],n;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) tr[x]+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x)) res+=tr[x];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Bit;</span><br></pre></td></tr></table></figure>

<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="前缀-min-max-："><a href="#前缀-min-max-：" class="headerlink" title="前缀 $\min&#x2F;\max$："></a>前缀 $\min&#x2F;\max$：</h3><p>若能理解树状数组的原理，便不难解决这个问题。</p>
<p>树状数组将前缀询问分成了 $O(\log n)$ 个独立的区间，那么只要是能够通过合并两个区间信息得到的大区间信息，都可以可以维护的。</p>
<p>单点修改则用修改后的信息更新 $O(\log)$ 个区间，那么是否支持修改为任意数呢？</p>
<p>答案是否定的。对于前缀 $\min$ 只能支持单点减的修改；对于前缀 $\max$ 只能支持单点加的修改。</p>
<p>因为树状数组修改是基于旧最值和新修改的值进行的更新，而最值不能依附于旧值，因为无法确定这个最值是否恰好是被修改的数。</p>
<h3 id="区间询问："><a href="#区间询问：" class="headerlink" title="区间询问："></a>区间询问：</h3><p>树状数组本身维护的为前缀区间信息。然而若维护的信息是可差分的，即 $[l,r]$ 的信息可以通过 $[1,r]-[1,l-1]$ 得到，那么就可以利用树状数组支持区间询问。</p>
<h3 id="区间修改："><a href="#区间修改：" class="headerlink" title="区间修改："></a>区间修改：</h3><p>同样的，若维护的信息是可差分的，那么将区间修改转化成单点加和单点减，即可实现区间修改。</p>
<h3 id="区间询问-区间修改："><a href="#区间询问-区间修改：" class="headerlink" title="区间询问+区间修改："></a>区间询问+区间修改：</h3><p>使用上述差分的方法，也只能仅支持区间询问或仅支持区间修改，不能同时支持区间询问和区间修改。</p>
<p>那么是否能使用树状数组同时支持区间询问和区间修改呢？</p>
<p>也是有可能可以的。</p>
<p>牢牢把握树状数组的本质：单点修改和前缀询问。树状数组本质是不能改变的，但是具体的询问和修改却可以依题目而变，所以可以尝试从修改和询问的性质入手。</p>
<p>以区间加和区间求和为例：</p>
<p>令 $b_i&#x3D;a_i-a_{i-1}，$$\sum\limits_{i&#x3D;l}^r a_i&#x3D;\sum\limits_{i&#x3D;l}^r\sum\limits_{j&#x3D;1}^i b_j$</p>
<p>考虑每个 $b_j$ 的贡献，可得：$\sum\limits_{i&#x3D;l}^r(r-i+1)\times b_i&#x3D;(r+1)\times\sum\limits_{i&#x3D;l}^rb_i-\sum\limits_{i&#x3D;l}^rib_i$。</p>
<p>所以只要维护两个树状数组，一个维护 $b_i$，一个维护 $ib_i$，即可。</p>
<p>$b_i$ 已经是差分数组了，对 $b_i$ 的修改即为单点修改。</p>
<h3 id="树状数组维护不可差分信息："><a href="#树状数组维护不可差分信息：" class="headerlink" title="树状数组维护不可差分信息："></a>树状数组维护不可差分信息：</h3><p>此部分数据结构功能对应线段树，但时间复杂度严格劣于线段树，选择性学习。</p>
<p>树状数组维护不可差分信息，依然是只能支持单点修改和区间询问，但单点修改和区间询问时间复杂度均为 $O(\log^2n)$。</p>
<h4 id="区间询问：-1"><a href="#区间询问：-1" class="headerlink" title="区间询问："></a>区间询问：</h4><p>对于区间询问 $[l,r]$ 同样是将区间拆分成若干个区间，只是现在不能拆到 $1$ 了，即拆分成的区间的范围不能小于 $l$。</p>
<p>因此：</p>
<ul>
<li>$x-lowbit(x)&lt;l$，将 $a[x]$ 合并即可，然后继续从 $tr[x-1]$ 考虑。直到 $x&#x3D;l$，$a[x]$ 即为原序列，直接在原序列上维护即可。</li>
<li>$x-lowbit(x)\geq l$，正常考虑。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,a[r]);</span><br><span class="line">        --r;</span><br><span class="line">        <span class="keyword">for</span>(;r-<span class="built_in">lowbit</span>(r)&gt;=l;r-=<span class="built_in">lowbit</span>(r)) ans=<span class="built_in">max</span>(ans,tr[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h4><p>不可差分信息单点修改同最值（最值本身即为一种不可差分信息）。不能使用旧值更新新值。</p>
<p>但是，树状数组上，$x$ 的儿子的信息是没有发生变化的（也就依然是新值），所以先用儿子更新 $tr[x]$，再用修改的新值更新 $tr[x]$ 即可。同时，由于 $x$ 的新值会破坏它的所有父节点的信息，所以 $x$ 所有的父节点也都要用儿子更新一遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    a[x]=v;</span><br><span class="line">    <span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))&#123;</span><br><span class="line">        tr[x]=a[x];</span><br><span class="line">        <span class="keyword">for</span> (v=<span class="number">1</span>;v&lt;<span class="built_in">lowbit</span>(x);v&lt;&lt;=<span class="number">1</span>) </span><br><span class="line">            tr[x]=<span class="built_in">max</span>(tr[x],tr[x-v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述做法虽然是 $O(\log^2n)$ 的，但是很显然，其常数巨小，实际表现不一定会在所有情况下劣于线段树的 $O(\log n)$，而且代码量极短。</p>
<h3 id="权值树状数组："><a href="#权值树状数组：" class="headerlink" title="权值树状数组："></a>权值树状数组：</h3><p>正常情况下，使用树状数组维护的是一个序列，而权值树状数组维护的则是问题的值域。原理与使用与普通树状数组无异，这里不再赘述。</p>
<p>这里只是引入这样将树状数组视作“计数器”维护值域的思想。</p>
<p>通常使用权值树状数组维护逆序对数量与全局第 $k$ 小。</p>
<h3 id="树状数组二分："><a href="#树状数组二分：" class="headerlink" title="树状数组二分："></a>树状数组二分：</h3><p>例如：在保证 $a_i\geq 0$ 的情况下，求最小的 $x$ 满足 $\sum\limits_{i&#x3D;1}^x a_i&gt;y$。且要求多次询问和单点加。</p>
<h4 id="树状数组-二分："><a href="#树状数组-二分：" class="headerlink" title="树状数组$+$二分："></a>树状数组$+$二分：</h4><p>更形象的叫法应该是：树状数组套二分。那么就是在外层二分模型下，查询前缀和。同时维护单点加。</p>
<p>时间复杂度：$O(\log^2n)$。</p>
<p>虽然是 $O(\log^2n)$，但是实际表现却十分优先，许多情况下，并不比线段树上二分劣。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l,r,mid;</span><br><span class="line">l=<span class="number">1</span>,r=n;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">4</span>)&#123;</span><br><span class="line">    mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Bit.<span class="built_in">query</span>(mid)&gt;v) r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(mid=l;mid&lt;=r;mid++) <span class="keyword">if</span>(Bit.<span class="built_in">query</span>(mid)&gt;v) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h4 id="树状数组上二分："><a href="#树状数组上二分：" class="headerlink" title="树状数组上二分："></a>树状数组上二分：</h4><p>更准确地这里应该是树状数组上倍增，但是一般而言倍增和二分可以互相转化，所以也无伤大雅。</p>
<p>从最高位开始，若这一位的管辖区间和加上已累加的超过了 $y$，则考虑下一位，否则就累加到答案中。最多考虑 $\log n$ 位。</p>
<p>时间复杂度：$O(\log n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> _log=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;_log)&lt;=n)  _log++;</span><br><span class="line">    _log--;</span><br><span class="line">    <span class="type">int</span> i,x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,_log,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(tr[x+(<span class="number">1</span>&lt;&lt;i)]&lt;=v)&#123;</span><br><span class="line">        v-=tr[x+(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">        x+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>泰拉瑞亚-召唤师流程</title>
    <url>/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><font face="楷体">召唤师，通过召唤武器召唤仆从，仆从跟随人物且具有无敌状态，仆从会自动攻击靠近人物的敌对生物，召唤视为增益，死亡后会消失。仆从造成召唤伤害。</font></p>
<p><font face="楷体">同时，召唤师可以使用鞭子作为人物攻击方式，攻击方式为近战，但伤害视为召唤伤害而不是近战伤害。召唤师仆从会集中攻击被鞭子攻击的敌怪</font></p>
<span id="more"></span>

<h2 id="肉前"><a href="#肉前" class="headerlink" title="肉前"></a>肉前</h2><h3 id="开荒期"><a href="#开荒期" class="headerlink" title="开荒期"></a>开荒期</h3><p><font face="楷体">召唤师前期能获得的武器较少。</font></p>
<p><font face="楷体">1.雀杖</font></p>
<p><font face="楷体">获得较为容易，但不排除脸黑到开不出来。</font></p>
<p><font face="楷体">但是其特殊的攻击方式导致其不易击中敌怪，而且不锁敌，使得其并不好用。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/1.png" class="" title="咕咕咕">

<p><font face="楷体">2.阿比盖尔之花</font></p>
<p><font face="楷体">获得较为容易，但是需要死亡后产生墓碑。</font></p>
<p><font face="楷体">输出稳定。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/2.png" class="" title="咕咕咕">

<p><font face="楷体">3.史莱姆法杖</font></p>
<p><font face="楷体">获取途径简单，但爆率极低且不可飞行。</font></p>
<p><font face="楷体">如果开局就通过击杀史莱姆获取那不失为一个好选择。但没有必要为了它而在前期刷史莱姆。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/3.png" class="" title="咕咕咕">

<p><font face="楷体">个人推荐：阿比盖尔之花 $&gt;$ 雀仗 $\geq$ 史莱姆法杖</font></p>
<p><font face="楷体">前期的第一个鞭子为动物学家 $10$ 金售卖的皮鞭。</font></p>
<p><font face="楷体">动物学家在怪物图鉴解锁 $\frac{1}{10}$ 后入住。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/4.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/5.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/18.png" class="" title="咕咕咕">

<p><font face="楷体">在前期探图的同时应尽可能多地解锁生物。</font></p>
<p><font face="楷体">先去沙漠获取仙人掌套，其套装效果可在前期和敌怪贴贴的时候避免不断的接触伤害。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/6.png" class="" title="咕咕咕">

<p><font face="楷体">解锁皮鞭后，前往地下雪原刷小雪怪皮毛，鹿角怪召唤物 $+$ 小雪怪的法杖 $+$ 小雪怪皮毛外套。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/7.png" class="" title="咕咕咕">

<p><font face="楷体">鹿角怪可掉落肉前唯一的哨兵武器-眼球激光塔（酒馆老板除外）但作用不大，自行选择。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/8.png" class="" title="咕咕咕">

<p><font face="楷体">阿比盖尔之花退役。</font></p>
<p><font face="楷体">此时可视情况选择挑战 史莱姆王-克苏鲁之眼-世界吞噬者（腐化）&#x2F;克苏鲁之脑（猩红）。</font></p>
<p><font face="楷体">史莱姆王 和 克苏鲁之眼 挑战顺序可视情况而定，无先后要求。</font></p>
<p><font face="楷体">建议在挑战 BOSS 前获得 赫尔墨斯靴（可在地下和洞穴地层中的宝箱里找到）以加强机动性，否则不好躲克苏鲁之眼的冲撞。或可用粘鞍（史莱姆王坐骑）躲避。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/9.png" class="" title="咕咕咕">

<p><font face="楷体">使用粘鞍更适合挑战世界吞噬者。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/10.png" class="" title="咕咕咕">

<p><font face="楷体">若对走位水平不自信，可以下丛林获取荆鞭。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/11.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/16.png" class="" title="咕咕咕">

<p><font face="楷体">荆鞭对敌怪有中毒减益，对人物有增加鞭速的增益。且伤害与攻击范围与皮鞭相比均有较大提升。</font></p>
<p><font face="楷体">在拥有荆鞭后，可挑战骷髅王。</font></p>
<p><font face="楷体">陨石对召唤师同样不必要，可跳过。</font></p>
<p><font face="楷体">或先获取黑曜石套，其在 世界吞噬者&#x2F;克苏鲁之脑 后即可通过熔岩熔炉合成。熔岩熔炉需要梦魇镐（腐化）&#x2F;死亡使者镐（猩红）挖掘。召唤杖亦可更新为小鬼法杖，狱石通过梦魇镐&#x2F;死亡使者镐挖掘。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/19.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/21.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/14.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/15.png" class="" title="咕咕咕">

<p><font face="楷体">使用粘鞍可较易躲避骷髅王旋转攻击。进入地牢后，通过击杀地牢内骷髅类敌怪掉落的骨头，和蛛网合成脊柱骨鞭。以及在地牢中获取可以增加一个仆从位的施法桌。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/12.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/17.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/20.png" class="" title="咕咕咕">

<p><font face="楷体">召唤师蜂王不必要，可以跳过。虽然蜂王掉落物可以合成另一套召唤师套装-蜜蜂套装，但是出了蜜蜂套装可以再额外多加 $1$ 个仆从位外，其它属性不如黑曜石套，可自行选择。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/13.png" class="" title="咕咕咕">

<p><font face="楷体">接下来便是肉前最后的 BOSS，肉山。</font></p>
]]></content>
      <tags>
        <tag>泰拉瑞亚</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客小白月赛85</title>
    <url>/2024/01/06/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B85/</url>
    <content><![CDATA[<p>概述：</p>
<ul>
<li>阅读理解，题面普遍片场（讲故事）（为什么我当初出了一道阅读理解就被dis了，这场全是。</li>
<li>A-D 都是一种：我不会 $\neq$ 我不能过。</li>
<li>开场 50 分钟才想起来还有小白月赛，D 题思路秒了（假贪心）WA 了半小时。然后去拿了个外卖，回来意识到想假了，又想了一下过了。本来不打算写了，看到榜一 10 分钟不到秒了前三题，最后 14 分钟打算挣扎一下，结果 C 上来就 WA 了两发，直接下机。</li>
<li>总结：不训练导致的（自从南京回来快两个月了）！</li>
<li>碎碎念：如果这场我把题面变一下，测试数据不变，通过率绝对高好多。</li>
</ul>
<span id="more"></span>

<h2 id="A-ACCEPT"><a href="#A-ACCEPT" class="headerlink" title="A.ACCEPT"></a>A.ACCEPT</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给一个只含 <code>A</code> <code>C</code> <code>E</code> <code>P</code> <code>T</code> 的字符串，问重新排列后最多几个 <code>ACCEPT</code>。</p>
<h3 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h3><p>经典思路，统计五种字符的数量，按比例求最小值即可（1:2:1:1:1）</p>
<h2 id="B-咕呱蛙"><a href="#B-咕呱蛙" class="headerlink" title="B.咕呱蛙"></a>B.咕呱蛙</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>第 $i$ 层有 $i$ 个青蛙，问前 $i$ 层青蛙总数为偶数的第 $x$ 个 $i$ 是几。</p>
<h3 id="解：-1"><a href="#解：-1" class="headerlink" title="解："></a>解：</h3><p>实际就是求数列 $a_i&#x3D;\dfrac{i\times (i+1)}{2}$ 的第 $x$ 个偶数。</p>
<p>打表打出来发现就是 $4i-3,4i$ 是偶数。答案就是 $\lfloor\frac{n}{2}\rfloor\times 4+[n\bmod 2]\times 3$。</p>
<p>直接研究式子，或者考虑 $1…i$ 的奇偶性也可以。</p>
<h2 id="C-得分显示"><a href="#C-得分显示" class="headerlink" title="C.得分显示"></a>C.得分显示</h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>$a_i&#x3D;\lfloor i\times x\rfloor$。求 $\max\lbrace x\rbrace$。 </p>
<h3 id="解：-2"><a href="#解：-2" class="headerlink" title="解："></a>解：</h3><p>$a_i&#x3D;\lfloor i\times x\rfloor\Rightarrow x\in [\lceil\frac{a_i}{i}\rceil,\lfloor\frac{a_i+1}{i}\rfloor)$</p>
<p>所以其实就是 $n$ 个区间求交，左端点求 $max$，右端点求 $min$ 即可，同时又因为题目保证有解且求 $max\lbrace x\rbrace$，所以答案就是 $\min\lbrace\lfloor\frac{a_i+1}{i}\rfloor\rbrace$。</p>
<p>但是这个题面就把题目变得迷惑起来（引导人考虑相邻两个数之间的增量）。</p>
<p>从另一个角度去二分也可以。</p>
<h2 id="D-阿里马马与四十大盗"><a href="#D-阿里马马与四十大盗" class="headerlink" title="D.阿里马马与四十大盗"></a>D.阿里马马与四十大盗</h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在 $a_i&#x3D;0$ 的位置可以选择回满血，并花费恢复生命值的时间，或者直接走。</p>
<p>在 $a_i&gt;0$ 的位置会损失 $a_i$ 的生命，求从 $1$ 到 $n$ 的最小时间。</p>
<p>移动一格花费 $1$ 的时间，只能往相邻的格子移动。</p>
<h3 id="解：-3"><a href="#解：-3" class="headerlink" title="解："></a>解：</h3><p>题目大量冗余信息。</p>
<p>移动的时间没用，直接在答案上 $+n-1$ 即可。因为不能往回走，$a_i$ 不会消失，时间不会变少。</p>
<p>一个错误的贪心：能不回血就不回血。想假的原因是贪心的滞后性。</p>
<p>正确的贪心：花费的时间只和起止血量和经过的 $a_i$ 之和有关。所以枚举最后一次回血的位置，算 $a_i$ 的前缀和即可。</p>
<h2 id="E-烙饼"><a href="#E-烙饼" class="headerlink" title="E.烙饼"></a>E.烙饼</h2><h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>$n$ 张饼，第 $i$ 张饼需要 $a_i$ 的制作时间，每张饼可以分为若干次安排在 $m$ 机器上制作。求做完所有饼的最短时间。要求所有机器工作总次数不超过 $2n$。</p>
<h3 id="解：-4"><a href="#解：-4" class="headerlink" title="解："></a>解：</h3><p>逃不过阅读理解去剥离题目的外衣。</p>
<p>一个容易的小结论：最短时间 $\geq$ $\max\lbrace a_i\rbrace$。</p>
<p>所以其实，就很迷惑行为了，有了这个结论，那么最后所有机器的工作总次数本身就是不会超过 $2n$ 的。即：这个工作次数没什么大的意义。</p>
<p>简单证明：</p>
<p>$x&#x3D;\max$，若当前 $now+a_i&gt;x$，那么 $a_i-(x-now)&lt;now$，所以 $a_i$ 这个饼花费的时间不会超过 $x$（在两台机器上时间不会有重合）且最多只会被划分成 $2$ 段。</p>
<p>假设答案为 $x$，那么又是一个经典的 trick：$x$ 满足单调性。直接对 $x$ 二分即可。check 的时候只需要从前往后满了就放到下一台机器就好了。</p>
<p>那么出题人给出了一个巧妙一点的偏思维的做法，我觉得供参考，学习价值不如二分。</p>
<p>首先，最短时间也是 $\geq$ $\lceil\frac{\sum a_i}{m}\rceil$ 的，因为假设“抛开事实不谈”，仅考虑总耗时，然后分配给 $m$ 台机器，那么答案就是均分的结果。</p>
<p>那么结果上文的结论，再分讨一下：</p>
<ul>
<li>如果 $\max\leq \lceil\frac{\sum a_i}{m}\rceil$，那么最终的 $x$ 就是 $\lceil\frac{\sum a_i}{m}\rceil$</li>
<li>反之就是 $\max$。</li>
</ul>
<h2 id="F-龙吸水"><a href="#F-龙吸水" class="headerlink" title="F.龙吸水"></a>F.龙吸水</h2><h3 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 $n$ 天的水位，魔法师可以在任意天降低任意数值的水位。求最多可以有多少天水位在要求区间内。</p>
<h3 id="解：-5"><a href="#解：-5" class="headerlink" title="解："></a>解：</h3><p>先阅读理解。$n$ 天的水位不关心，只关心每一天的变化量，即：$a_i-a_{i-1}$（那我觉得这里出题人不说变化量纯纯是给题目加阅读理解）。</p>
<p>同时变化后的水位相比 $a_i$ 不会增加。</p>
<p>而第 $i$ 天之后的结果只跟第 $i$ 天的水位有关，这就非常适合 dp 了。</p>
<h4 id="easy-version："><a href="#easy-version：" class="headerlink" title="easy version："></a>easy version：</h4><p>$a_i\leq 5\times 10^3$，直接设 $dp[i][j]$ 表示仅考虑前 $i$ 个且第 $i$ 天水位为 $j$ 的答案。</p>
<p>转移时，因为可以用魔法，所以</p>
<p>$dp[i][j]$</p>
<p>可以由 </p>
<p>$dp[i-1][k]+[j\geq l \land j\leq r](k\in [j-(a[i]-a[i-1]),+∞])$</p>
<p>转移而来。</p>
<p>维护一个 $dp[i]$ 的后缀 $\max$ 即可。</p>
<p>时间复杂度：$O(na)$</p>
<p>空间复杂度：$O(na)$</p>
<h4 id="hard-version"><a href="#hard-version" class="headerlink" title="hard version:"></a>hard version:</h4><p>hard version 主要是 $a_i$ 变大了，最直接的使用动态开点线段树，只需要支持：区间加（$[l,r]+1$），后缀 $\max$ 即可。</p>
<p>时间复杂度：$O(n\log a_i)$</p>
<p>空间复杂度：$O(n\log a_i\log n)$</p>
<p>但是貌似卡空间。</p>
<p>那么把要用的值离线下来后离散化再用一般线段树维护即可。</p>
<p>鉴定为锻炼考验码力。</p>
]]></content>
      <tags>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何（九）</title>
    <url>/2023/12/07/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    <content><![CDATA[<p>杂项</p>
<span id="more"></span>

<h2 id="皮克定理"><a href="#皮克定理" class="headerlink" title="皮克定理"></a><font face="楷体">皮克定理</font></h2><p><font face="楷体">顶点坐标均是整点的简单多边形，其面积 $A$ 和内部格点数目 $i$ 和边上格点数目 $b$ 的关系为 $A&#x3D;i+\frac{b}{2}-1$。</font></p>
<h2 id="平面最近点对"><a href="#平面最近点对" class="headerlink" title="平面最近点对"></a><font face="楷体">平面最近点对</font></h2><p><font face="楷体">问题描述：给出平面上 $n$ 个点，求距离最近的点对。</font></p>
<p><font face="楷体">引理：如果平面上 $n$ 个点的最近点对距离为 $d$，那么将这 $n$ 个点放进 $d\times d$ 的网格中，每个网格中的点数不超过 4。</font></p>
<h3 id="法一：经典分治算法"><a href="#法一：经典分治算法" class="headerlink" title="法一：经典分治算法"></a><font face="楷体">法一：经典分治算法</font></h3><ul>
<li><font face="楷体">分：画一条垂直的线将点集均分为左右两个子集。</font></li>
<li><font face="楷体">治：分别求出左右两个子集的最近点对。</font></li>
<li><font face="楷体">合：求出跨越分界线的最近点对，与子问题的最近点对比较取最优。</font></li>
</ul>
<p><font face="楷体">令两个子问题中的最近点对距离为 $d$。</font></p>
<p><font face="楷体">找出所有离分界线距离 $d$ 以内的所有点，并按纵坐标（y） 坐标排序。</font></p>
<p><font face="楷体">对每个范围内的点，遍历与其纵坐标（y）之差 d 以内的所有点，更新最近点对。</font></p>
<p><font face="楷体">根据引理，此范围内的点能更新的最近点对是常数级别的。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$</font></p>
<h3 id="法二：扫描线"><a href="#法二：扫描线" class="headerlink" title="法二：扫描线"></a><font face="楷体">法二：扫描线</font></h3><p><font face="楷体">对所有点按横坐标（x）排序，从左到右扫描，记录当前的最近点对距离 $d$。</font></p>
<p><font face="楷体">对于一个新的点，遍历之前的点中所有与其横坐标（x）之差小于 d 且纵坐标（y）之差小于 d 的所有点，更新最近点对。</font></p>
<p><font face="楷体">用一个 multiset 存放与新点横坐标（x）之差小于 d 的点，内部按纵坐标（y）排序。</font></p>
<p><font face="楷体">使用队列按 x 坐标顺序入队各点，当队首与新点横坐标（x）之差大于 d 时出队，并且将其从 multiset 中移除。</font></p>
<p><font face="楷体">在 multiset 中二分找到纵坐标（y）之差小于 d 的分界点。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$</font></p>
<h3 id="法三：随机化算法"><a href="#法三：随机化算法" class="headerlink" title="法三：随机化算法"></a><font face="楷体">法三：随机化算法</font></h3><p><font face="楷体">令前 $i-1$ 个点的最近点对距离为 $d$，作 $d\times d$ 的网格图，使用哈希表记录每个格子内有哪些点。</font></p>
<p><font face="楷体">对第 $i$ 个点，找到其所在的格子，并找到以此格子为中心的九宫格内的所有点，更新最近点对。</font></p>
<p><font face="楷体">如果最近点对被更新，以新的最近点对距离 $d’$ 重构网格图。</font></p>
<p><font face="楷体">若点的顺序为随机打乱的。那么期望时间复杂度为 $O(n)$。</font></p>
<h2 id="最小圆覆盖"><a href="#最小圆覆盖" class="headerlink" title="最小圆覆盖"></a><font face="楷体">最小圆覆盖</font></h2><p><font face="楷体">问题描述：给定平面上 $n$ 个点，求一个半径最小的圆，能覆盖所有的点。</font></p>
<p><font face="楷体">引理：过三个不共线的点可以唯一确定一个圆。</font></p>
<p><font face="楷体">定理：如果点 $p$ 不在点集 S 的最小圆覆盖圆内，那么它一定在 $\lbrace p\rbrace\bigcup S$ 的最小覆盖圆上，即最小覆盖圆一定经过点 $p$。</font></p>
<h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a><font face="楷体">算法：</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最小圆覆盖（点集 p，边界点集 R）</span><br><span class="line">	如果 P 为空 或 |R|==3</span><br><span class="line">		返回 R 确定的圆</span><br><span class="line">	p = P 中随机选一点</span><br><span class="line">	D = 最小圆覆盖（P-&#123;p&#125;，R）</span><br><span class="line">	如果 p 不在 D 中</span><br><span class="line">		D = 最小圆覆盖（P-&#123;p&#125;，R ∪ &#123;p&#125;）</span><br><span class="line">	返回 D</span><br></pre></td></tr></table></figure>

<p><font face="楷体">时间复杂度：$O(n)$</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（八）</title>
    <url>/2023/12/07/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<p>圆</p>
<span id="more"></span>

<h2 id="圆基础"><a href="#圆基础" class="headerlink" title="圆基础"></a><font face="楷体">圆基础</font></h2><ul>
<li><font face="楷体">圆的表示：圆心、半径</font></li>
<li><font face="楷体">圆的周长：$C&#x3D;2\pi r$</font></li>
<li><font face="楷体">圆的面积：$S&#x3D;\pi r^2$</font></li>
</ul>
<h2 id="关系问题"><a href="#关系问题" class="headerlink" title="关系问题"></a><font face="楷体">关系问题</font></h2><h3 id="点与圆的关系"><a href="#点与圆的关系" class="headerlink" title="点与圆的关系"></a><font face="楷体">点与圆的关系</font></h3><ul>
<li><font face="楷体">点在圆外</font></li>
<li><font face="楷体">点在圆上</font></li>
<li><font face="楷体">点在圆内</font></li>
</ul>
<p><font face="楷体">判定方法：点到圆心距离（平方）与圆的半径（平方）比较。</font></p>
<p><font face="楷体">无精度误差。</font></p>
<h3 id="直线与圆的关系"><a href="#直线与圆的关系" class="headerlink" title="直线与圆的关系"></a><font face="楷体">直线与圆的关系</font></h3><ul>
<li><font face="楷体">相离</font></li>
<li><font face="楷体">相切</font></li>
<li><font face="楷体">相交</font></li>
</ul>
<p><font face="楷体">判定方法：圆心到直线距离与圆的半径比较</font></p>
<p><font face="楷体">可以做到无精度误差。</font></p>
<h3 id="圆与圆的关系"><a href="#圆与圆的关系" class="headerlink" title="圆与圆的关系"></a><font face="楷体">圆与圆的关系</font></h3><p><font face="楷体">令两圆半径分别为 $r_1$ 和 $r_2$，两圆圆心的距离为 $d$。</font></p>
<ul>
<li><font face="楷体">相同：$r_1&#x3D;r_2$ 且 $d&#x3D;0$</font></li>
<li><font face="楷体">相离：$d&gt;r_1+r_2$</font></li>
<li><font face="楷体">外切：$d&#x3D;r_1+r_2$</font></li>
<li><font face="楷体">相交：$|r_1-r_2|&lt;d&lt;r_1+r_2$</font></li>
<li><font face="楷体">内切：$d&#x3D;|r_1-r_2|$</font></li>
<li><font face="楷体">内含：$d&lt;|r_1-r_2|$</font></li>
</ul>
<h2 id="交集问题"><a href="#交集问题" class="headerlink" title="交集问题"></a><font face="楷体">交集问题</font></h2><h3 id="直线与圆的交点"><a href="#直线与圆的交点" class="headerlink" title="直线与圆的交点"></a><font face="楷体">直线与圆的交点</font></h3><p><font face="楷体">前提：直线与圆不相离</font></p>
<p><font face="楷体">直线：$\lbrace P,\vec v\rbrace$</font></p>
<p><font face="楷体">圆：$\lbrace C,r\rbrace$</font></p>
<p><font face="楷体">设圆心到直线距离为 $d$，投影为 $C’$，则：</font></p>
<p><font face="楷体">交点：$\overrightarrow{OC’}±\dfrac{\sqrt{r^2-d^2}}{|\vec v|}\vec v$。</font></p>
<h3 id="圆与圆交点"><a href="#圆与圆交点" class="headerlink" title="圆与圆交点"></a><font face="楷体">圆与圆交点</font></h3><p><font face="楷体">前提：两圆不相同、不相离、不内含</font></p>
<p><font face="楷体">两圆圆心连线与一圆心到交点连线夹角 $\alpha$。</font></p>
<p><font face="楷体">根据余弦定理：$\cos\alpha&#x3D;\dfrac{r_1^2+d^2-r_2^2}{2r_1d},\sin\alpha &#x3D;\sqrt{1-\cos^2\alpha}$。</font></p>
<p><font face="楷体">将两圆心连线对应向量进行伸缩旋转。</font></p>
<h3 id="圆与圆面积交"><a href="#圆与圆面积交" class="headerlink" title="圆与圆面积交"></a><font face="楷体">圆与圆面积交</font></h3><p><font face="楷体">两个弓形（扇形减去三角形）面积和。</font></p>
<p><font face="楷体">扇形面积：$\pi r^2\times\dfrac{2\alpha}{2\pi}&#x3D;r^2\alpha$。</font></p>
<p><font face="楷体">三角形面积：$\dfrac12\times 2r\sin\alpha\times r\cos\alpha&#x3D;r^2\sin\alpha\cos\alpha$</font></p>
<p><font face="楷体">弓形面积：$r^2(\alpha-\sin\alpha\cos\alpha)$</font></p>
<h3 id="圆与多边形面积交"><a href="#圆与多边形面积交" class="headerlink" title="圆与多边形面积交"></a><font face="楷体">圆与多边形面积交</font></h3><p><font face="楷体">从圆心将多边形剖分成若干三角形，求三角形与原的面积交。</font></p>
<h3 id="多个圆的面积并"><a href="#多个圆的面积并" class="headerlink" title="多个圆的面积并"></a><font face="楷体">多个圆的面积并</font></h3><p><font face="楷体">对于极角在 $\theta_l$ 到 $\theta_r$ 之间的一段圆弧。</font></p>
<p>$2S&#x3D;x_0r(\sin\theta_r-\sin\theta_l)-y_0r(\cos\theta_r-\cos\theta_l)+r^2(\theta_r-\theta_l)$。</p>
<p><font face="楷体">时间复杂度：$O(n^2\log n)$。</font></p>
<h2 id="切线问题"><a href="#切线问题" class="headerlink" title="切线问题"></a><font face="楷体">切线问题</font></h2><h3 id="过圆外一点圆的切线"><a href="#过圆外一点圆的切线" class="headerlink" title="过圆外一点圆的切线"></a><font face="楷体">过圆外一点圆的切线</font></h3><ul>
<li>$\cos\alpha&#x3D;\dfrac{r}{d}$</li>
<li><font face="楷体">向量伸缩、旋转</font></li>
</ul>
<h3 id="两圆的公切线"><a href="#两圆的公切线" class="headerlink" title="两圆的公切线"></a><font face="楷体">两圆的公切线</font></h3><ul>
<li><font face="楷体">相离：4 条</font></li>
<li><font face="楷体">外切：3 条</font></li>
<li><font face="楷体">相交：2 条</font></li>
<li><font face="楷体">内切：1 条</font></li>
<li><font face="楷体">内含：0 条</font></li>
</ul>
<h4 id="外公切线"><a href="#外公切线" class="headerlink" title="外公切线"></a><font face="楷体">外公切线</font></h4><p>$\cos\alpha&#x3D;\dfrac{r_1-r_2}{d}$</p>
<h4 id="内公切线"><a href="#内公切线" class="headerlink" title="内公切线"></a><font face="楷体">内公切线</font></h4><p>$\cos\alpha&#x3D;\dfrac{r_1+r_2}{d}$</p>
<h2 id="圆的反演"><a href="#圆的反演" class="headerlink" title="圆的反演"></a><font face="楷体">圆的反演</font></h2><p><font face="楷体">给定反演中心点 $O$ 和反演半径 $R$。若平面上点 $P$ 和 $P’$ 满足：</font></p>
<ul>
<li><font face="楷体">点 $P’$ 在射线 $OP$ 上</font></li>
<li>$|\overrightarrow{OP}|\times|\overrightarrow{OP’}|&#x3D;R^2$</li>
</ul>
<p><font face="楷体">则称点 $P$ 和点 $P’$ 互为反演点</font></p>
<p><font face="楷体">性质：</font></p>
<ul>
<li><font face="楷体">圆外的点的反演点在圆内，反之亦然。</font></li>
<li><font face="楷体">圆上的点的反演点为其自身。</font></li>
<li><font face="楷体">不过点 $O$ 的圆，其反演图形也是不过点 $O$ 的圆。</font></li>
<li><font face="楷体">过点 $O$ 的圆，其反演图形是不过点 $O$ 的直线。</font></li>
<li><font face="楷体">两个图形相切，则它们的反演图形也相切。</font></li>
</ul>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（七）</title>
    <url>/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<p>扫描线</p>
<span id="more"></span>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a><font face="楷体">引入</font></h2><h3 id="矩形面积并"><a href="#矩形面积并" class="headerlink" title="矩形面积并"></a><font face="楷体">矩形面积并</font></h3><p><font face="楷体">给出 $n$ 个边平行于坐标轴的矩形，求它们的面积并。</font></p>
<h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a><font face="楷体">扫描线</font></h2><p><font face="楷体">将问题拆解成时间序列关键点，可以想象一条线在平面上扫过，在一些特定的位置这条线上对应的状态会发生变化。</font></p>
<p><font face="楷体">两要素：</font></p>
<ul>
<li><font face="楷体">时间序列：状态发生变化的关键点。</font></li>
<li><font face="楷体">维护当前时间状态的数据结构。</font></li>
</ul>
<h2 id="引入的解"><a href="#引入的解" class="headerlink" title="引入的解"></a><font face="楷体">引入的解</font></h2><p><font face="楷体">两要素：</font></p>
<ul>
<li><font face="楷体">时间序列：每个矩形的上下边</font></li>
<li><font face="楷体">数据结构：线段树（区间修改，查询覆盖的区间长度）</font></li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a><font face="楷体">应用</font></h2><h3 id="判断-n-条线段中是否存在有交点的线段"><a href="#判断-n-条线段中是否存在有交点的线段" class="headerlink" title="判断 $n$ 条线段中是否存在有交点的线段"></a><font face="楷体">判断 $n$ 条线段中是否存在有交点的线段</font></h3><p><font face="楷体">朴素做法：$O(n^2)$。</font></p>
<p><font face="楷体">尝试扫描线，一条垂直于 $x$ 轴的线从左向右扫。</font></p>
<p><font face="楷体">关键点：线段的端点（左端点加入，右端点删除）</font></p>
<p><font face="楷体">考虑对于每一个时间点的竖线，把所有与之相交的线段，按纵坐标（y）升序排序。那么两条有交点的线段的先后顺序会在某一时刻发生变化。</font></p>
<p><font face="楷体">具体而言，其先后顺序发生变化的情况有两种：</font></p>
<ul>
<li><font face="楷体">新加入一条线段，与这条线段相邻的两条线段先后顺序发生变化。</font></li>
<li><font face="楷体">删除一条线段，原本被这条线段隔开的两条线段先后顺序发生变化。</font></li>
</ul>
<p><font face="楷体">使用 set 维护。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$。</font></p>
<p><font face="楷体">细节：</font></p>
<ul>
<li><font face="楷体">一个关键点上有多个操作的情况（多条线段共端点）</font></li>
<li><font face="楷体">线段与扫描线平行的情况（平行 y 轴）</font></li>
</ul>
<h3 id="面积并问题"><a href="#面积并问题" class="headerlink" title="面积并问题"></a><font face="楷体">面积并问题</font></h3><p><font face="楷体">对于部分问题，扫描线并不是最优解。</font></p>
<h4 id="三角形面积并"><a href="#三角形面积并" class="headerlink" title="三角形面积并"></a><font face="楷体">三角形面积并</font></h4><h5 id="法一：扫描线"><a href="#法一：扫描线" class="headerlink" title="法一：扫描线"></a><font face="楷体">法一：扫描线</font></h5><ul>
<li><font face="楷体">关键点：三角形顶点，交点。</font></li>
<li><font face="楷体">关键点之间的面积可用梯形面积公式计算。</font></li>
</ul>
<p><font face="楷体">时间复杂度：$O(n^3)$</font></p>
<h5 id="法二：轮廓法"><a href="#法二：轮廓法" class="headerlink" title="法二：轮廓法"></a><font face="楷体">法二：轮廓法</font></h5><p><font face="楷体">三角形的并本质上是多边形，如果能找到这个多边形的轮廓，可用直接使用求多边形面积的算法求得面积并。</font></p>
<p><font face="楷体">对于每一条边，求出它与其它所有三角形的交点，找到没有包含在任何三角形内部的部分。</font></p>
<p><font face="楷体">时间复杂度：$O(n^2)$</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（六）</title>
    <url>/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<p>旋转卡壳</p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font face="楷体">概念</font></h2><p><font face="楷体">点集的直径：平面最远点对（一定是其凸包上的某两个极点）。</font></p>
<p><font face="楷体">性质</font></p>
<ul>
<li><font face="楷体">各极点到其中一点的距离并不存在单调性。</font></li>
<li><font face="楷体">但是各极点到一条极边的距离存在单峰性。</font></li>
</ul>
<h2 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a><font face="楷体">旋转卡壳</font></h2><p><font face="楷体">卡尺绕凸包旋转，其两边经过的点构成对踵点。</font></p>
<img src="/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E5%85%AD%EF%BC%89/1.gif" class="" title="咕咕咕">

<p><font face="楷体">一个点的对踵点不好直接得出，且可能不止一个。但一条边的对踵点可以利用上页提到的单峰性找出。</font></p>
<p><font face="楷体">卡尺的一条边逆时针经过各条极边时，另一条边对应的对踵点也是逆时针依次经过，因此二者可以通过双指针进行遍历。</font></p>
<p><font face="楷体">卡尺旋转过程中一定存在某时刻其两边经过直径对应的两点。</font></p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a><font face="楷体">算法流程</font></h2><ul>
<li><font face="楷体">设定初始边指针 p，并找到其对踵点 q。</font></li>
<li><font face="楷体">p 指向下一条边。</font></li>
<li><font face="楷体">如果 q 点到 p 边的距离小于等于 q 的下一个点到 p 边的距离，则 q 指向下一个点。</font></li>
<li><font face="楷体">重复 3 直到找到 p 边的对踵点，更新答案。</font></li>
<li><font face="楷体">回到 2。</font></li>
</ul>
<p><font face="楷体">此处的距离比较可转化为面积比较，从而可以使用叉积解决。</font></p>
<p><font face="楷体">时间复杂度：$O(n)$。</font></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a><font face="楷体">应用</font></h2><h3 id="凸多边形间最大-小距离"><a href="#凸多边形间最大-小距离" class="headerlink" title="凸多边形间最大&#x2F;小距离"></a><font face="楷体">凸多边形间最大&#x2F;小距离</font></h3><p><font face="楷体">重新定义“对踵点”：</font></p>
<p><font face="楷体">以凸多边形某条边作为 y 轴，x 坐标最小的点。</font></p>
<p><font face="楷体">在此定义下，该点依然是和该边组成叉积最大的点。</font></p>
<p><font face="楷体">除此之外，算法流程与求点集直径一致。</font></p>
<h3 id="凸多边形间最小面积-周长外接矩形"><a href="#凸多边形间最小面积-周长外接矩形" class="headerlink" title="凸多边形间最小面积&#x2F;周长外接矩形"></a><font face="楷体">凸多边形间最小面积&#x2F;周长外接矩形</font></h3><p><font face="楷体">不论是最小周长还是面积的外接矩形，其一定有一条边与凸包的一条极边共线。</font></p>
<p><font face="楷体">在旋转卡壳时，多维护方向上的两个极点即可。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（五）</title>
    <url>/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p><font face="楷体">半平面交</font></p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font face="楷体">概念</font></h2><p><font face="楷体">半平面：有向直线左侧的区域。</font></p>
<p><font face="楷体">半平面交：多个半平面的交集。</font></p>
<p><font face="楷体">半平面交涉及直线均使用点向式表示。</font></p>
<p><font face="楷体">性质：半平面交一定是凸集。</font></p>
<p><font face="楷体">特别地，可以加入一个相当大的边界，将交集无穷大的情况转化为有边界，这样交集可以用一个凸多边形表示。</font></p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a><font face="楷体">做法</font></h2><h3 id="法一：朴素算法"><a href="#法一：朴素算法" class="headerlink" title="法一：朴素算法"></a><font face="楷体">法一：朴素算法</font></h3><p><font face="楷体">求出各直线的交点，判断各交点是否在所有平面内。</font></p>
<p><font face="楷体">对满足条件的各点求凸包。</font></p>
<p><font face="楷体">时间复杂度：$O(n^3)$。</font></p>
<h3 id="法二：增量法；"><a href="#法二：增量法；" class="headerlink" title="法二：增量法；"></a><font face="楷体">法二：增量法；</font></h3><p><font face="楷体">每次用直线去切割当前的凸多边形。</font></p>
<p><font face="楷体">时间复杂度：$O(n^2)$。</font></p>
<h3 id="法三：排序增量法："><a href="#法三：排序增量法：" class="headerlink" title="法三：排序增量法："></a><font face="楷体">法三：排序增量法：</font></h3><p><font face="楷体">求凸包算法中，对点进行排序可以有效降低复杂度。</font></p>
<p><font face="楷体">利用凸多边形各边方向向量的有序性，同样可以对各直线进行排序后求半平面交。</font></p>
<p><font face="楷体">对于方向向量同向的直线，只需要考虑最左的一个。</font></p>
<h4 id="维护过程"><a href="#维护过程" class="headerlink" title="维护过程"></a><font face="楷体">维护过程</font></h4><p><font face="楷体">用双端队列维护当前的半平面交：</font></p>
<p><font face="楷体">当加入一个新的半平时，可能有以下几种情况。</font></p>
<ul>
<li><font face="楷体">队尾的一些半平面变成冗余的，从队尾弹出。</font></li>
<li><font face="楷体">队首的一些半平面变成冗余的，从队首弹出。</font></li>
<li><font face="楷体">半平面交变成空集。</font></li>
</ul>
<p><font face="楷体">时间复杂度：$O(n\log n)$。瓶颈在于排序。</font></p>
<h4 id="判断冗余"><a href="#判断冗余" class="headerlink" title="判断冗余"></a><font face="楷体">判断冗余</font></h4><p><font face="楷体">队尾&#x2F;首两条直线的交点在新加入的直线右侧。</font></p>
<h4 id="外边界"><a href="#外边界" class="headerlink" title="外边界"></a><font face="楷体">外边界</font></h4><p><font face="楷体">在加入外边界的前提下，半平面交中相邻各边逆时针旋转不超过 $180^\circ$。</font></p>
<p><font face="楷体">当无解的情况出现时，新加入的直线与队首差。一定大于等于 $180^\circ$，并且会把队中除队首外的直线全部弹出。</font></p>
<p><font face="楷体">因此，每加入一条新直线，弹出冗余半平面后与队尾比较，如果逆时针旋转大于等于  $180^\circ$，则交集为空。</font></p>
<p><font face="楷体">此时，外边界的加入是必要的。</font></p>
<h4 id="先处理队尾，再处理队首"><a href="#先处理队尾，再处理队首" class="headerlink" title="先处理队尾，再处理队首"></a><font face="楷体">先处理队尾，再处理队首</font></h4><p><font face="楷体">当出现一个可以把队列里的点全部弹出去的向量（即队列里的所有点都在该向量的右侧），则我们必须先处理队尾，再处理队首。</font></p>
<p><font face="楷体">原因如下：</font></p>
<img src="/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%94%EF%BC%89/1.jpg" class="" title="咕咕咕">

<p><font face="楷体">一般情况下，我们在队列里（队列顺序为 $\lbrace\vec u,\vec v\rbrace$）后面加一条边（向量 $\vec w$）,会产生一个交点 $N$，缩小 $\vec v$ 后面的范围。</font></p>
<img src="/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%94%EF%BC%89/2.jpg" class="" title="咕咕咕">

<p><font face="楷体">但是毕竟每次操作都是1一般的，因此可能会有把 $M$ 点 $\lceil$挤出去$\rfloor$  的情况。</font></p>
<img src="/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%94%EF%BC%89/3.jpg" class="" title="咕咕咕">

<p><font face="楷体">如果此时出现了 $\vec a$，使得 $M$ 在 $\vec a$ 的右侧，那么 $M$ 就要出队了。此时如果先处理队首，显然是扩大了范围。实际上 $M$ 点是由 $\vec u$ 和 $\vec v$ 共同构成的，因此需要考虑影响到现有进程的是 $\vec u$ 还是 $\vec v$。而因为我们在极角排序后，向量是逆时针顺序，所以 $\vec v$ 的影响更大一些。</font></p>
<p><font face="楷体">就如上图，如果 $M$ 确认在 $\vec a$ 的右侧，那么此时 $\vec v$ 的影响一定不会队半平面交的答案作出任何的贡献。</font></p>
<p><font face="楷体">而我们排除队首的原因是 <strong>当前直线的限制比队首大</strong>，这个条件的前提是队列里有不止两个直线，不然就会出现上面的情况。</font></p>
<p><font face="楷体">所以一定要先排除队尾在排除队首。</font></p>
<h4 id="交点在新加入直线上"><a href="#交点在新加入直线上" class="headerlink" title="交点在新加入直线上"></a><font face="楷体">交点在新加入直线上</font></h4><p><font face="楷体">队尾&#x2F;首两条直线的交点在新加入的直线上时，一般不认为这时的队尾&#x2F;首是冗余的，这样便可区分出交集面积为 0 与交集为空。</font></p>
<p><font face="楷体">特殊情况：多条直线交于一点。</font></p>
<h3 id="法四：分治法"><a href="#法四：分治法" class="headerlink" title="法四：分治法"></a><font face="楷体">法四：分治法</font></h3><p><font face="楷体">时间复杂度：$O(n\log n)$。</font></p>
<p><font face="楷体">$[l,r]$ 直线的半平面交是$[l,mid]$ 半平面交和 $[mid+1,r]$ 半平面交的交集。</font></p>
<p><font face="楷体">核心在于实现 $O(n)$ 求两个凸多边形的交。</font></p>
<h4 id="实现一："><a href="#实现一：" class="headerlink" title="实现一："></a><font face="楷体">实现一：</font></h4><p><font face="楷体">使用法三求两个凸多边形半平面交得到凸多边形的交。</font></p>
<p><font face="楷体">因为半平面交求出的交的边是有序的，所以合并 $[l,mid]$ 和 $[mid+1,r]$ 时，两个凸多边形都是有序的，那么使用法三维护的时间复杂度瓶颈即为维护双端队列的复杂度。为 $O(n)$。</font></p>
<h4 id="实现二："><a href="#实现二：" class="headerlink" title="实现二："></a><font face="楷体">实现二：</font></h4><p><font face="楷体">对两个凸多边形的顶点进行扫描线，对两相邻竖线之间的梯形求交。单次 $O(1)$。共 $O(n)$ 条竖线。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>“锐评”清华社杯</title>
    <url>/2023/12/03/%E2%80%9C%E9%94%90%E8%AF%84%E2%80%9D%E6%B8%85%E5%8D%8E%E7%A4%BE%E6%9D%AF/</url>
    <content><![CDATA[<blockquote>
<p>为了深入贯彻党的二十大提出的构建新一代信息技术、人工智能增长引擎,加快发展数字经济，促进数字经济和实体经济深度融合.打造具有国际竞争力的数字产业集群的政策方针，同时积极响应教育部、国家发展改革委、财政部三部委发文加快人工智能领域人才培养的文件精神，中国电子学会现代教育技术分会决定联合清华大学出版社等单位面向全国高等学校在读全日制研究生和大学生举办2023第二届“清华社杯”大学生算法大赛，旨在促进大学生学习计算机领域专业知识与技能的兴趣，邀发大学生在信息技术和人工智能的算法编程领域勇于发现问题、提出问题和解决问题，有效提升算法设计、逻辑推理、数学建模、编程实现和计算机系统能力，培养团队合作意识、挑战精神和创新能力。</p>
</blockquote>
<span id="more"></span>

<h2 id="体验极差"><a href="#体验极差" class="headerlink" title="体验极差"></a>体验极差</h2><p>抛开这个比赛本身不谈，我觉得这场比赛就是依托答辩。</p>
<p>明面上都第二届了，却给我一种办赛水平甚至不如蓝桥杯周赛。</p>
<h2 id="题面描述不清"><a href="#题面描述不清" class="headerlink" title="题面描述不清"></a>题面描述不清</h2><p>整套题不止一处题面描述不清。</p>
<h3 id="A-题"><a href="#A-题" class="headerlink" title="A 题"></a>A 题</h3><p>整场比赛最大的锅。</p>
<p>A 作为一个签到，却成了通过率最低的题目（题面没改前）。小于 10% 的通过率，我愿称之为算法竞赛有史以来最有“实”力的签到题。</p>
<p>显然答案会是小数，题面却不说保留几位小数。</p>
<p>样例也恰好给一个答案为整数的数据。</p>
<p>要不是我赛时想到了，不然我还真以为出题人埋了个好坑：</p>
<ul>
<li>因为题目的特殊性，所以结果的小数部分只可能是 0.5,0.25,0.75 中的一个，所以特判一下就可以了。</li>
</ul>
<p>但是我这样写没过。</p>
<p>那就是纯纯初生出题人&#x2F;主办方了。</p>
<p>这题导致我吃了 8 发罚时，并且在 2:30 才过了此题（题面 2:00 就修改了，却没有公告广播，只有一个在比赛详情页的，右边一小块地方提了一下，我直接麻了）</p>
<p>也觉得神奇，那些在题面修改前过的是什么样的人？</p>
<ul>
<li>实验了一下，知道了，printf 输出 double 类型，默认六位小数。</li>
</ul>
<center>6！</center>

<h3 id="F-题"><a href="#F-题" class="headerlink" title="F 题"></a>F 题</h3><p>题面里写的是</p>
<blockquote>
<p>前 $i$ 个元素中的最大元素，且小于等于 $X_i$。如果没有答案，请打印 -1。</p>
</blockquote>
<p>但是实际上，是小于等于 $X_i$ 的最大元素。</p>
<p>虽然这个点可以从样例里看出来，但是出题人的描述能力，可见一斑。</p>
<h3 id="E-题"><a href="#E-题" class="headerlink" title="E 题"></a>E 题</h3><p>最后说到：“每两个连续数字之间的绝对值”</p>
<p>我想但凡打过 CF 的人都不会这么描述两个相邻元素。</p>
<h3 id="I-题"><a href="#I-题" class="headerlink" title="I 题"></a>I 题</h3><blockquote>
<p>不同的子序列连续以字母 X 和 Y 结尾</p>
</blockquote>
<blockquote>
<p>对于某些索引 S1[i] 不等于 S2[i]，则 S1 和 S2 被视为不相同</p>
</blockquote>
<p>从未见过在中文题面里写“索引”的。</p>
<p>这题是导致我这场比赛炸裂的罪魁祸首。</p>
<p>我读错了整整<strong>两个多小时</strong>的题面。从 10:30 读错到 12:50。</p>
<p>我赛中以为求的是以 X 开头，Y 结尾的子序列（下标）的个数。</p>
<p>就比如说，第一个样例：<code>xhapxcicbt</code>，我以为的解是 p x c&#x2F;p c c&#x2F;p i c。</p>
<p>并且我还纠结了很久，他这个不同的子序列，到底是不是“本质不同”的个数。</p>
<p>后面我才意识到应该是求以 XY 结尾的本质不同子序列的数量。</p>
<p>最伤心的是：按我之前的题意理解做法得到的 O(nm) 做法，一直卡在 1.5 s 时间超限，导致我一直以为是卡常，卡了整整两个小时的常。从 1.6s 卡到 1.3 s 还是时间超限。</p>
<p>而且我后面揣度出正确题意后，用时 1.3s 时，有时返回时间超限，有时返回答案错误。不懂 OJ 在干什么。</p>
<p>抛开事实不谈，这个样例屁用没有。</p>
<h2 id="赛时无答疑"><a href="#赛时无答疑" class="headerlink" title="赛时无答疑"></a>赛时无答疑</h2><p>一开始我就发了 A 题的询问，到结束，没有回复。不懂他那个“私信官方”是不是就一个摆设？</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>总的来看，这比赛是不是没有验题人？</p>
<p>A 题这样的锅都能出现。已经不是能力问题了。</p>
<p>从题面上，我一个很大的感觉是，大概率是大学老师出的题，而不是 ACM 选手出题。</p>
<p>也不懂这个监控体系是在干什么。</p>
<p>中途上厕所往哪报备？</p>
<p>官网写的是“报名编号+姓名+去做什么+预计多久的形式发给组委会老师”。</p>
<p>通过什么形式发？</p>
<p>我以为它都这么说了，监控系统里应该有申请入口。结果屁都没有。</p>
<p>而且这个报备，也没什么意义吧。该“厕所战神”还是“厕所战神”。</p>
<hr>
<p><font face="楷体">但是打都打了，复盘也写一下好了。</font></p>
<p><font face="楷体">开局 A 先 WA 三发，没什么好说的。</font></p>
<p><font face="楷体">因为记得 QQ 群里组委会老师说题目分布从易到难，所以直接从 B 往后做，但是这个 B 看着不是很能做。看了半天也只看出一个二分性。以及一个枚举 min，然后 max 只能是不小于 min 的最小值，这样就是，组 1 和 组 2 共产生 2n 个二元组，组 3 和组 4 同理。</font></p>
<p><font face="楷体">看了眼榜，G 被开了，就去跟榜了，G 也是签到，没什么好说的。</font></p>
<p><font face="楷体">然后依次跟榜开了 F E，F 开始那个错误的描述，我还以为一个前缀 max 就好了，结果还是得 set。</font></p>
<p><font face="楷体">E 是一个打表猜结论的贪心，虽然这个类似的思路已经烂大街了。</font></p>
<p><font face="楷体">就是把 n&#x2F;2 放到最前面，然后一大一小就好了。</font></p>
<p><font face="楷体">此时榜上暂时没题了，去看了一会 C，感觉应该是一个跟 tarjan 相关的题目，但不是很有想法，而且我 tarjan 也不是很会。</font></p>
<p><font face="楷体">过了一会儿，H 好像有点东西。</font></p>
<p><font face="楷体">去看了一眼，发现小清新。</font></p>
<p><font face="楷体">大概先分个讨。把 $m\neq n-1$ 的情况讨论掉，然后要找那个中心，一个比较显然的结论：中心的度数一定是最大的，而且出了中心之外的点的度数都是小于 3 的。所以判断一下是否有超过 1 个度数超过 2 的点。</font></p>
<p><font face="楷体">然后，然后我就发现，好像做完了。。。</font></p>
<p><font face="楷体">原本以为还要再 dfs 一下的，想了一下发现不用。</font></p>
<p><font face="楷体">这时已经 1 个小时了（因为我中途曾反复回去纠结那个 A 题）</font></p>
<p><font face="楷体">再度入手 B，发现思路一下子就出来了，二分 d，然后枚举组 1 和组 2 的二元组，在组 3 和组 4 中找到一个合法的匹配，就是解一个不等式组。</font></p>
<p>$(a,b),(c,d)\rightarrow b-c\leq d’\ \land\ d-a\leq d’$</p>
<p>$\begin{cases}c\geq b-d’\newline d\leq a+d’\end{cases}$</p>
<p><font face="楷体">只需要把组 3 和组 4 的二元组按 c 升序后，维护一个 d 的后缀 min 即可。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log ^2n)$。</font></p>
<p><font face="楷体">不懂为什么 B 1e5 $n\log^2$ 开 2s，I 题却只开 1s。</font></p>
<p><font face="楷体">此时才 1 个半小时。</font></p>
<p><font face="楷体">剩下的时间基本上就是在干 I 题。</font></p>
<p><font face="楷体">中间也曾看过 D 题，但是鉴定为答辩 BFS 模拟题，没什么意思。</font></p>
<p><font face="楷体">I 题，按我开始的思路就是，每对二元组（$s_i$,$s_j$）对答案的贡献就是 $\binom{j-i-1}{l-2}$。</font></p>
<p><font face="楷体">预处理 $c[x][y][len]$，单次询问 $O(n)$。</font></p>
<p><font face="楷体">但是就这个做法，TLE 了两个小时。硬是没有 WA。</font></p>
<p><font face="楷体">最后一个小时的时候，看出了后面那个题意。</font></p>
<p><font face="楷体">顿时的想法就是维护一个 $dp[i][j]$ 表示前 $i$ 个字符选出长度为 $j$ 的本质不同子序列个数。对于询问 $(X,Y,l)$ 就是从后往前找到 $X$ 的位置最靠后的第一组 $(s_i,s_j)$。答案就是 $dp[i-1][l-2]$，将询问离线，预处理 $O(26n^2)$。单次询问 $O(1)$。但是那个 $dp$ 数组处理不好。一会 WA，一会 TLE。</font></p>
<hr>
<p>排名从十多名，掉到了 200 多名，但是组委会好像说那个榜单是没有分组的。</p>
<p>按有提交就算，总参数人数 3386。5% 一等，总共会有 169 个一等。去掉 A 组后应该比较有希望，但是还有 C 组。。。</p>
<p>那就不知道了。</p>
<p>感觉不是很稳。</p>
<p>无所谓了。</p>
<p>不知道它们最后这个 A 题怎么处理。如果取消 A 的罚时（包括通过用时）。</p>
<p>那我肯定是 6 题第一。</p>
<ul>
<li>重现传智杯初赛 5 题第一（</li>
</ul>
<p>结束后稍微想了下 D 题，发现其实不用 BFS，两个状态之间的最小操作数是可以直接确定的。具体就是两个等式之间，先判一下火柴数量是否相等，然后求有多少位置是一个等式有而另一个等式没有的即可。</p>
<p>这样就只需要枚举一下三个数字和运算符，单次 $O(2\times 10^3)$。</p>
]]></content>
  </entry>
  <entry>
    <title>计算几何（四）</title>
    <url>/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>凸包进阶</p>
<span id="more"></span>

<h2 id="凸包二分"><a href="#凸包二分" class="headerlink" title="凸包二分"></a><font face="楷体">凸包二分</font></h2><h3 id="判断点是否在凸多边形中"><a href="#判断点是否在凸多边形中" class="headerlink" title="判断点是否在凸多边形中"></a><font face="楷体">判断点是否在凸多边形中</font></h3><h4 id="按横坐标（x）二分"><a href="#按横坐标（x）二分" class="headerlink" title="按横坐标（x）二分"></a><font face="楷体">按横坐标（x）二分</font></h4><p><font face="楷体">按最左和最右的点把凸包分成上凸壳和下凸壳。</font></p>
<p><font face="楷体">通过一次 to-left 测试找出在上半部分还是下半部分。</font></p>
<p><font face="楷体">在对应凸壳上二分找到点在哪两条过相邻的极点的平行 $y$ 轴的竖线之间。</font></p>
<p><font face="楷体">最后与找到的对应极边进行一次 to-left 测试，确定其是否位于凸多边形内。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h4 id="利用极角序二分"><a href="#利用极角序二分" class="headerlink" title="利用极角序二分"></a><font face="楷体">利用极角序二分</font></h4><p><font face="楷体">从最下方的点出发向其它各点连射线，这些射线方向是按极角序排好的。</font></p>
<p><font face="楷体">通过 to-left 测试与二分查找，可以找出点是在哪两条射线之间。</font></p>
<p><font face="楷体">最后与找到的对应极边进行一次 to-left 测试，确定其是否位于凸多边形内。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h3 id="判断直线是否与凸多边形相交"><a href="#判断直线是否与凸多边形相交" class="headerlink" title="判断直线是否与凸多边形相交"></a><font face="楷体">判断直线是否与凸多边形相交</font></h3><p><font face="楷体">找到与该直线平行的凸多边形的两条切线，判断该直线是否在两条切线之间。</font></p>
<p><font face="楷体">凸多边形各边对应的向量是按照极角序有序的。</font></p>
<p><font face="楷体">二分查找 前驱和后继 分别以向上和向下穿过直线的切点。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h3 id="过一点求凸多边形切线"><a href="#过一点求凸多边形切线" class="headerlink" title="过一点求凸多边形切线"></a><font face="楷体">过一点求凸多边形切线</font></h3><p><font face="楷体">存在切线当且仅当点严格在凸包外。</font></p>
<p><font face="楷体">首先 $O(\log n)$ 地判断点是否在凸包外。</font></p>
<p><font face="楷体">切线：切点前后的点在切线同一侧。</font></p>
<p><font face="楷体">对于凸包上一点 $V_i$，如果 $V_{i+1}$ 在射线 $PV_i$ 左侧，则 $V_i$ 点标记为 <code>L</code>，否则标记为 <code>R</code>。</font></p>
<p><font face="楷体">如果 $V_{i-1}$ 的标记与 $V_i$ 不同，则 $V_i$ 是切点。</font></p>
<h4 id="方法一：上下凸壳"><a href="#方法一：上下凸壳" class="headerlink" title="方法一：上下凸壳"></a><font face="楷体">方法一：上下凸壳</font></h4><h5 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a><font face="楷体">情况一：</font></h5><p><font face="楷体">点在左极点左侧或右极点右侧。</font></p>
<p><font face="楷体">此时，切点一个在上凸壳，一个在下凸壳。</font></p>
<p><font face="楷体">上下凸壳的序列都满足 <code>LLL...RRR...</code> 或 <code>RRR...RRR...</code>，各自二分即可。</font></p>
<h5 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a><font face="楷体">情况二：</font></h5><p><font face="楷体">两个切点均在上凸壳或下凸壳</font></p>
<p><font face="楷体">以上凸壳为例，此时的序列为：<code>LLL...LLLRRR...RRRLLL...LLL</code></font></p>
<p><font face="楷体">二分找到横坐标（x）离该点最近的点，然后将上凸壳分为两部分，这两部分又可以各自二分找到切点。</font></p>
<h4 id="方法二：射线划分"><a href="#方法二：射线划分" class="headerlink" title="方法二：射线划分"></a><font face="楷体">方法二：射线划分</font></h4><p><font face="楷体">点向凸多边形上任意一点作射线，将凸多边形分为左右部分。</font></p>
<p><font face="楷体">在两部分上分别二分即可。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h4 id="方法三：射线划分-cdot-改"><a href="#方法三：射线划分-cdot-改" class="headerlink" title="方法三：射线划分$\cdot$改"></a><font face="楷体">方法三：射线划分$\cdot$改</font></h4><p><font face="楷体">以找到最左侧的切线为例。</font></p>
<h5 id="情况一：-1"><a href="#情况一：-1" class="headerlink" title="情况一："></a><font face="楷体">情况一：</font></h5><p><font face="楷体">序列中第一个点是 R，则序列形如 <code>RRR...RRRLLL...LLLRRR...RRR</code></font></p>
<p><font face="楷体">如果把最开始的几个 <code>R</code> 视作 <code>L</code>，那么序列则转化为可以二分的形式，并且可以二分找到切点。</font></p>
<p><font face="楷体">最开始的几个 <code>R</code> 一定在第一条切线的右侧。</font></p>
<h5 id="情况二：-1"><a href="#情况二：-1" class="headerlink" title="情况二："></a><font face="楷体">情况二：</font></h5><p><font face="楷体">序列中第一个点是 <code>L</code>，则序列形如 <code>LLL...LLLRRR...RRRLLL...LLL</code>。</font></p>
<p><font face="楷体">如果把最后的几个 <code>L</code> 视作 <code>R</code>，那么序列则转化为可以二分的形式，并且可以二分找到切点。</font></p>
<p><font face="楷体">最后的几个 <code>L</code> 一定在第一条切线的右侧。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h2 id="动态凸包"><a href="#动态凸包" class="headerlink" title="动态凸包"></a><font face="楷体">动态凸包</font></h2><p><font face="楷体">增量法求凸包，根据已有知识，可以做到 $O(n^2)$。</font></p>
<p><font face="楷体">维护一个数据结构，支持以下两个操作</font></p>
<ul>
<li><font face="楷体">修改：往当前点集中加入一点。</font></li>
<li><font face="楷体">询问：查询一点是否在当前点集的凸包内。</font></li>
</ul>
<p><font face="楷体">以按横坐标（x）维护上凸壳为例，即 set 中的点按横坐标（x）维护。</font></p>
<ul>
<li><font face="楷体">询问，使用前文 $O(\log n)$ 判断点是否在凸包内的做法即可。</font></li>
<li><font face="楷体">修改，二分找到横坐标（x）最近的点，然后分别向左向右遍历各点找切线，对于找到切线前的点将其删除。</font></li>
</ul>
<p><font face="楷体">特殊情况：点在凸包左极点左侧。</font></p>
<p><font face="楷体">考虑一条切线即可，另一个切线在下凸壳考虑。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$。</font></p>
<p><font face="楷体">极角序维护方式同理。</font></p>
<h2 id="闵可夫斯基和"><a href="#闵可夫斯基和" class="headerlink" title="闵可夫斯基和"></a><font face="楷体">闵可夫斯基和</font></h2><p>$A+B&#x3D;\lbrace \vec a+\vec b\mid \vec a\in A,\vec b\in B \rbrace$</p>
<p><font face="楷体">性质：原凸边形的一条极边对应闵可夫斯基和的一条极边。</font></p>
<h3 id="求闵可夫斯基和"><a href="#求闵可夫斯基和" class="headerlink" title="求闵可夫斯基和"></a><font face="楷体">求闵可夫斯基和</font></h3><p><font face="楷体">对两个凸多边形的所有边按极角排序。</font></p>
<p><font face="楷体">确定起点，然后依次加入各边即可。</font></p>
<p><font face="楷体">特殊情况：三点共线。</font></p>
<h3 id="求两个凸多边形之间的最大-小距离"><a href="#求两个凸多边形之间的最大-小距离" class="headerlink" title="求两个凸多边形之间的最大&#x2F;小距离"></a><font face="楷体">求两个凸多边形之间的最大&#x2F;小距离</font></h3><p><font face="楷体">令两个凸多边形对应的点集分别为 $A$ 和 $B$。</font></p>
<p>$A-B&#x3D;A+(-B)&#x3D;\lbrace\vec a-\vec b\mid \vec a\in A,\vec b\in B \rbrace$</p>
<p><font face="楷体">它们之间的最大&#x2F;小距离是所有 $\vec a-\vec b$ 中长度最大&#x2F;小的。</font></p>
<p><font face="楷体">求出闵可夫斯基和，找到离原点最远&#x2F;近的点即可。</font></p>
<p><font face="楷体">时间复杂度：$O(n)$。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（三）</title>
    <url>/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>凸包基础</p>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font face="楷体">定义</font></h2><h3 id="凸多边形"><a href="#凸多边形" class="headerlink" title="凸多边形"></a><font face="楷体">凸多边形</font></h3><p><font face="楷体">所有内角大小都在 $[0,\pi]$ 范围内的简单多边形。</font></p>
<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a><font face="楷体">凸包</font></h3><p><font face="楷体">在平面上能包含所有给定点的最小凸多边形。</font></p>
<p><font face="楷体">可以理解为用一个橡皮筋包含住所有给定点的形态。</font></p>
<p><font face="楷体">性质：凸包用最小的周长围住了所有点。</font></p>
<h3 id="极点"><a href="#极点" class="headerlink" title="极点"></a><font face="楷体">极点</font></h3><p><font face="楷体">凸包的顶点</font></p>
<p><font face="楷体">性质：若点 P 是点集 S 的一个极点，那么存在一条经过点 P 的直线 l，使得点集 S 中除了 P 的所有点都在 l 的同一侧。</font></p>
<h3 id="极边"><a href="#极边" class="headerlink" title="极边"></a><font face="楷体">极边</font></h3><p><font face="楷体">凸包的边</font></p>
<p><font face="楷体">性质：点集中除了极边上的点外都在极边所在直线的同一侧。</font></p>
<h2 id="求凸包"><a href="#求凸包" class="headerlink" title="求凸包"></a><font face="楷体">求凸包</font></h2><h3 id="极点法"><a href="#极点法" class="headerlink" title="极点法"></a><font face="楷体">极点法</font></h3><p><font face="楷体">枚举每个点，判断每个点是否是极点。</font></p>
<p><font face="楷体">依据：将凸包以凸包内一点为顶点进行三角剖分，非极点一定落在某个三角形内部，枚举另外三个点组成三角形，若点落在了某个三角形内部，则它不是极点。</font></p>
<p><font face="楷体">时间复杂度：$O(n^4)$。</font></p>
<h3 id="极边法"><a href="#极边法" class="headerlink" title="极边法"></a><font face="楷体">极边法</font></h3><p><font face="楷体">枚举两点组成的边，判断它是否是极边。</font></p>
<p><font face="楷体">依据：其它点在极边所在直线的同一侧。</font></p>
<p><font face="楷体">时间复杂度：$O(n^3)$。</font></p>
<h3 id="增量法"><a href="#增量法" class="headerlink" title="增量法"></a><font face="楷体">增量法</font></h3><p><font face="楷体">每次用一个点去更新凸包。</font></p>
<ul>
<li><font face="楷体">若点在凸包内，舍弃</font></li>
<li><font face="楷体">若点在凸包外，找凸包的切线</font></li>
</ul>
<p><font face="楷体">可推广至三维凸包、动态凸包。</font></p>
<p><font face="楷体">判断点在凸包内：$n$ 次 to-left 测试。$O(n)$。</font></p>
<p><font face="楷体">找凸包的切线：前驱和后继都在射线的同一侧。暴力 $O(n)$。</font></p>
<p><font face="楷体">时间复杂度：$O(n^2)$。</font></p>
<p><font face="楷体">判断点在凸包内和找凸包的切线均存在 $O(n\log n)$ 做法。</font></p>
<h3 id="Gift-wrapping"><a href="#Gift-wrapping" class="headerlink" title="Gift wrapping"></a><font face="楷体">Gift wrapping</font></h3><p><font face="楷体">从一条极边出发遍历其它点找到下一条极边。</font></p>
<p><font face="楷体">时间复杂度：$O(nh)$，最坏 $O(n^2)$，$h$ 表示凸包的极点数。</font></p>
<p><font face="楷体">起点的确定：</font></p>
<p><font face="楷体">点集中最左&#x2F;右&#x2F;上&#x2F;下的点一定是凸包的极点（若最左&#x2F;右&#x2F;上&#x2F;下的点不唯一，则是极边上的点，此时取另一个方向上坐标最大&#x2F;小的点）。</font></p>
<h3 id="Graham-scan"><a href="#Graham-scan" class="headerlink" title="Graham scan"></a><font face="楷体">Graham scan</font></h3><p><font face="楷体">基于极角排序的求凸包算法。</font></p>
<p><font face="楷体">算法流程：</font></p>
<ul>
<li><font face="楷体">以最左下角的点为极点，进行极角排序。</font></li>
<li><font face="楷体">将极点与极点的下一个点入栈。</font></li>
<li><font face="楷体">对于要入栈的下一个点，如果从栈顶连向该点需要顺时针旋转，则弹出栈顶。</font></li>
<li><font face="楷体">重复 3，直到从栈顶连向该点需要逆时针旋转。</font></li>
<li><font face="楷体">将下一个点入栈，回到 3。</font></li>
</ul>
<p><font face="楷体">时间复杂度：$O(n\log n)$。瓶颈为极角排序。</font></p>
<h3 id="Andrew’s-algorithm"><a href="#Andrew’s-algorithm" class="headerlink" title="Andrew’s algorithm"></a><font face="楷体">Andrew’s algorithm</font></h3><p><font face="楷体">基于横坐标（x）排序的求凸包算法。</font></p>
<p><font face="楷体">以最左最右两点为界，凸包可以分为上凸包和下凸包两部分。</font></p>
<p><font face="楷体">算法流程：</font></p>
<ul>
<li><font face="楷体">对点集以横坐标（x）为第一关键字，纵坐标（y）为第二关键字排序。</font></li>
<li><font face="楷体">正序遍历每个点，用栈维护下凸包。</font></li>
<li><font face="楷体">倒序遍历每个点，用栈维护上凸包。</font></li>
</ul>
<p><font face="楷体">栈的维护方式与 Graham scan 一致。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$。瓶颈为排序。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（二）</title>
    <url>/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>极角序</p>
<span id="more"></span>

<h2 id="极坐标系"><a href="#极坐标系" class="headerlink" title="极坐标系"></a><font face="楷体">极坐标系</font></h2><ul>
<li><font face="楷体">极点：O</font></li>
<li><font face="楷体">极轴：$\overrightarrow{OL}$</font></li>
<li><font face="楷体">极径：$r$</font></li>
<li><font face="楷体">极角：$\varphi$</font></li>
<li><font face="楷体">极坐标：$(r,\varphi)$</font></li>
</ul>
<p>$\tan\varphi&#x3D;\dfrac{y}{x}$</p>
<h2 id="极角排序"><a href="#极角排序" class="headerlink" title="极角排序"></a><font face="楷体">极角排序</font></h2><ul>
<li><font face="楷体">半平面内的极角排序</font></li>
</ul>
<h3 id="排序范围小于-180-circ"><a href="#排序范围小于-180-circ" class="headerlink" title="排序范围小于 $180^\circ$"></a><font face="楷体">排序范围小于 $180^\circ$</font></h3><p><font face="楷体">to-left 测试，即叉积比较。</font></p>
<h3 id="排序范围小于-360-circ"><a href="#排序范围小于-360-circ" class="headerlink" title="排序范围小于 $360^\circ$"></a><font face="楷体">排序范围小于 $360^\circ$</font></h3><h4 id="有精度损失"><a href="#有精度损失" class="headerlink" title="有精度损失 "></a><font face="楷体">有精度损失 </font></h4><p><font face="楷体">使用反三角函数 $\text{atan2}(y,x)$（精度更高） 函数计算极角，然后排序。</font></p>
<h4 id="无精度损失"><a href="#无精度损失" class="headerlink" title="无精度损失"></a><font face="楷体">无精度损失</font></h4><p><font face="楷体">先划分上下平面，同一部分内进行叉积比较。</font></p>
<p><font face="楷体">下半平面$&lt;$原点$&lt;$ x 正半轴$&lt;$上半平面$&lt;$ x 负半轴</font></p>
<hr>
<p><font face="楷体">时间复杂度：$O(n\log n)$。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（一）</title>
    <url>/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p> 二维几何基础知识</p>
<span id="more"></span>

<h2 id="浮点数与精度问题"><a href="#浮点数与精度问题" class="headerlink" title="浮点数与精度问题"></a><font face="楷体">浮点数与精度问题</font></h2><h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a><font face="楷体">特殊值</font></h3><ul>
<li><font face="楷体">+0.0 -0.0</font></li>
<li><font face="楷体">1.0&#x2F;0.0&#x3D;+inf，1.0&#x2F;-0.0&#x3D;-inf</font></li>
<li><font face="楷体">nan，非数字，例如：$\sqrt{-2}$</font><ul>
<li><font face="楷体">nan 除了 $\neq$ 时返回 <code>true</code> 外，其它比较运算符均返回 <code>false</code></font></li>
</ul>
</li>
</ul>
<p><font face="楷体">1.若问题能用整数解决则不用浮点数。</font></p>
<p><font face="楷体">2.除非时限紧张，否则使用 <code>long double</code>。</font></p>
<p><font face="楷体">3.减少数学库函数的调用。</font></p>
<p><font face="楷体">4.进行浮点数比较时，加入容限（误差）eps。</font></p>
<h2 id="点"><a href="#点" class="headerlink" title="点"></a><font face="楷体">点</font></h2><h3 id="using-Point-complex"><a href="#using-Point-complex" class="headerlink" title="using Point=complex&lt;double&gt;"></a><code>using Point=complex&lt;double&gt;</code></h3><ul>
<li><font face="楷体">横坐标（x）：.real()</font></li>
<li><font face="楷体">纵坐标（y）：.imag()</font></li>
</ul>
<p><font face="楷体">优点：自带各种运算</font></p>
<p><font face="楷体">缺点：慢</font></p>
<h3 id="using-Point-pair"><a href="#using-Point-pair" class="headerlink" title="using Point=pair&lt;double,double&gt;"></a><code>using Point=pair&lt;double,double&gt;</code></h3><ul>
<li><font face="楷体">横坐标（x）：first</font></li>
<li><font face="楷体">纵坐标（y）：second</font></li>
</ul>
<p><font face="楷体">优点：自带比较运算</font></p>
<p><font face="楷体">缺点：自由度不高</font></p>
<h3 id="struct-Point-double-x-y"><a href="#struct-Point-double-x-y" class="headerlink" title="struct Point {double x,y;}"></a><code>struct Point &#123;double x,y;&#125;</code></h3><ul>
<li><font face="楷体">横坐标（x）：x</font></li>
<li><font face="楷体">纵坐标（y）：y</font></li>
</ul>
<p><font face="楷体">优点：自由度高</font></p>
<p><font face="楷体">缺点：功能为零</font></p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a><font face="楷体">向量</font></h2><p><font face="楷体">表示上和点一致，因为坐标系中一个点对应一个向量。</font></p>
<h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a><font face="楷体">点积</font></h3><p>$\vec{a}\cdot \vec b&#x3D;a_xb_x+a_yb_y$</p>
<p><font face="楷体">几何意义：$\vec a\cdot \vec b&#x3D;|\vec a|\times |\vec b|\times \cos\theta$</font></p>
<ul>
<li><font face="楷体">向量的长度：$|\vec a|&#x3D;\sqrt{\vec a\times \vec a}$</font></li>
<li><font face="楷体">向量的夹角：$\cos \theta&#x3D;\dfrac{\vec a\cdot \vec b}{|\vec a|\times |\vec b|}$</font></li>
<li><font face="楷体">向量的投影：$|\vec a|\times cos\theta&#x3D;\dfrac{\vec a\cdot \vec b}{|\vec b|}$</font></li>
<li><font face="楷体">向量垂直：$\vec a\cdot \vec b&#x3D;0$</font></li>
</ul>
<h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a><font face="楷体">叉积</font></h3><p>$\vec a\times \vec b&#x3D;(a_xb_y-a_yb_x)\hat k$</p>
<p><font face="楷体">几何意义：$\vec a\times \vec b&#x3D;|\vec a|\times |\vec b|\times \sin \theta \hat k$</font></p>
<ul>
<li><font face="楷体">平行四边形面积：$|\vec a\times \vec b|&#x3D;|\vec a|\times |\vec b|\times |\sin \theta|$</font></li>
<li><font face="楷体">向量平行：$\vec a\times \vec b&#x3D;\vec 0$</font></li>
<li><font face="楷体">to-left 测试</font></li>
</ul>
<h4 id="to-left-测试"><a href="#to-left-测试" class="headerlink" title="to-left 测试"></a><font face="楷体">to-left 测试</font></h4><p><font face="楷体">判断点 P 在有向直线 AB 左侧&#x2F;右侧上。</font></p>
<p>$\begin{cases}\overrightarrow {AB}\times \overrightarrow{AP}&gt;0&amp; P\ 在有向直线\ AB\ 左侧\newline \overrightarrow {AB}\times \overrightarrow{AP}&lt;0&amp;P\ 在有向直线\ AB\ 右侧\newline\overrightarrow {AB}\times \overrightarrow{AP}&#x3D;0&amp; P\ 在有向直线\ AB\ 上\end{cases}$</p>
<h3 id="向量逆时针旋转"><a href="#向量逆时针旋转" class="headerlink" title="向量逆时针旋转"></a><font face="楷体">向量逆时针旋转</font></h3><p><font face="楷体">$\vec a$ 逆时针旋转 $\theta$，$(a_x,a_y)\rightarrow(\cos\theta a_x-\sin\theta a_y,\sin\theta a_x+\cos\theta a_y)$</font></p>
<h2 id="线段"><a href="#线段" class="headerlink" title="线段"></a><font face="楷体">线段</font></h2><p><code>struct segement&#123;Point a,b;&#125;</code></p>
<p><font face="楷体">记录左右端点</font></p>
<h3 id="判断点是否在线段上"><a href="#判断点是否在线段上" class="headerlink" title="判断点是否在线段上"></a><font face="楷体">判断点是否在线段上</font></h3><ul>
<li><font face="楷体">点 P 在 AB 上：$\overrightarrow {PA}\times \overrightarrow{PB}&#x3D;\vec 0$</font></li>
<li><font face="楷体">点 P 在 AB 之间：</font><ul>
<li>$\overrightarrow{PA}\cdot \overrightarrow{PB}\leq 0$</li>
<li>$\min(A_x,B_x)\leq P_x\leq\max(A_x,B_x)\ \land\ \min(A_y,B_y)\leq P_y\leq\max(A_y,B_y)$</li>
</ul>
</li>
</ul>
<h3 id="判断两条线段是否相交"><a href="#判断两条线段是否相交" class="headerlink" title="判断两条线段是否相交"></a><font face="楷体">判断两条线段是否相交</font></h3><ul>
<li><font face="楷体">点 A 和点 B 在直线 CD 的不同侧</font></li>
<li><font face="楷体">点 C 和点 D 在直线 AB 的不同侧</font></li>
<li><font face="楷体">三点共线、四点共线特判</font></li>
</ul>
<h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a><font face="楷体">直线</font></h2><h3 id="斜截式"><a href="#斜截式" class="headerlink" title="斜截式"></a><font face="楷体">斜截式</font></h3><p>$y&#x3D;kx+b$</p>
<h3 id="截距式"><a href="#截距式" class="headerlink" title="截距式"></a><font face="楷体">截距式</font></h3><p>$\dfrac{x}{a}+\dfrac{y}{b}&#x3D;1$</p>
<h3 id="一般式"><a href="#一般式" class="headerlink" title="一般式"></a><font face="楷体">一般式</font></h3><p>$Ax+By+C&#x3D;0$</p>
<h3 id="点斜式"><a href="#点斜式" class="headerlink" title="点斜式"></a><font face="楷体">点斜式</font></h3><p>$y-y_1&#x3D;k(x-x_1)$</p>
<h3 id="两点式"><a href="#两点式" class="headerlink" title="两点式"></a><font face="楷体">两点式</font></h3><p>$\dfrac{x-x_1}{x_2-x_1}&#x3D;\dfrac{y-y_1}{y_2-y_1}$</p>
<h3 id="点向式"><a href="#点向式" class="headerlink" title="点向式"></a><font face="楷体">点向式</font></h3><p><font face="楷体">直线上一点 P + 方向向量 $\vec v$ 表示一条直线。</font></p>
<h3 id="求直线与点-A-的距离"><a href="#求直线与点-A-的距离" class="headerlink" title="求直线与点 A 的距离"></a><font face="楷体">求直线与点 A 的距离</font></h3><p>$d&#x3D;\dfrac{|\vec v\times \overrightarrow{PA}|}{|\vec v|}$</p>
<h3 id="求点-A-在直线上的投影点-B"><a href="#求点-A-在直线上的投影点-B" class="headerlink" title="求点 A 在直线上的投影点 B"></a><font face="楷体">求点 A 在直线上的投影点 B</font></h3><p>$\overrightarrow {OB}&#x3D;\overrightarrow{OP}+\overrightarrow{PB}&#x3D;\overrightarrow{OP}+\dfrac{|\overrightarrow{PB}|}{|\vec v|}\vec v&#x3D;\overrightarrow{OP}+\dfrac{\overrightarrow{PA}\cdot\vec v}{\vec v^2}\vec v$</p>
<h3 id="两直线交点"><a href="#两直线交点" class="headerlink" title="两直线交点"></a><font face="楷体">两直线交点</font></h3><p>$\overrightarrow {OQ}&#x3D;\overrightarrow{OP_1}+\dfrac{|\vec{v_2}\times \overrightarrow{P_2P_1}|}{|\vec{v_1}\times \vec{v_2}|}\vec{v_1}$</p>
<h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a><font face="楷体">多边形</font></h2><p><font face="楷体">由点集描述。</p>
<ul>
<li><font face="楷体">一般按逆时针顺序</font></li>
<li><font face="楷体">不一定满足凸性</font></li>
<li><font face="楷体">注意第一个点与最后一个点的处理</font></li>
</ul>
<h3 id="多边形的面积"><a href="#多边形的面积" class="headerlink" title="多边形的面积"></a><font face="楷体">多边形的面积</font></h3><p><font face="楷体">三角形的面积：$\dfrac{1}{2}|\vec a\times \vec b|$</font></p>
<p><font face="楷体">多边形的面积：分解为若干三角形的面积</font></p>
<p>$S&#x3D;\dfrac{1}{2}|\sum\limits_{i&#x3D;0}^{n-1}\overrightarrow{OP_i}\times \overrightarrow{OP_{(i+1)\bmod n}}|$</p>
<h3 id="判断点是否在多边形内"><a href="#判断点是否在多边形内" class="headerlink" title="判断点是否在多边形内"></a><font face="楷体">判断点是否在多边形内</font></h3><h4 id="光线投影法"><a href="#光线投影法" class="headerlink" title="光线投影法"></a><font face="楷体">光线投影法</font></h4><p><font face="楷体">从该点引出一条射线，如果这条射线与多边形有奇数个交点，则该点在多边形内部，否则该点在多边形外部。</font></p>
<h4 id="回转数法"><a href="#回转数法" class="headerlink" title="回转数法"></a><font face="楷体">回转数法</font></h4><p><font face="楷体">回转数：面内闭合曲线逆时针绕过该点的总次数。</font></p>
<p><font face="楷体">遵循非零规则：当回转次数为 0 时，点在曲线外部。</font></p>
<ul>
<li><p><font face="楷体">一种实现方法：计算相邻两边夹角（有方向）的和。</font></p>
<img src="/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class="" title="咕咕咕">

<img src="/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/2.png" class="" title="咕咕咕"></li>
<li><p><font face="楷体">另一种实现方法：从该点引出一条射线，每经过一条自上而下穿过该射线的边，贡献 -1；每经过一条自下而上穿过该射线的边，贡献 +1。</font></p>
<img src="/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/3.png" class="" title="咕咕咕">

<img src="/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/4.png" class="" title="咕咕咕"></li>
</ul>
<p><font face="楷体">边界情况</font></p>
<ul>
<li><font face="楷体">点在多边形上，对于每条边特判。</font></li>
<li><font face="楷体">引出射线交多边形于顶点，视作在在射线上侧（影响自下而上还是自上而下的判断）</font>。</li>
</ul>
<h3 id="判断点是否在凸多边形内"><a href="#判断点是否在凸多边形内" class="headerlink" title="判断点是否在凸多边形内"></a><font face="楷体">判断点是否在凸多边形内</font></h3><h4 id="n-次-to-left-测试"><a href="#n-次-to-left-测试" class="headerlink" title="n 次 to-left 测试"></a><font face="楷体">n 次 to-left 测试</font></h4><p>$O(n)$</p>
<h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a><font face="楷体">二分</font></h4><p>$O(\log n)$</p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>个人博客搭建笔记</title>
    <url>/2023/12/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>  选择 hexo 框架和 next 主题搭建个人博客。</p>
<span id="more"></span>

<p>$\sum\limits_{i&#x3D;1}^n a_i$</p>
<h2 id="1-0-注册-GitHub"><a href="#1-0-注册-GitHub" class="headerlink" title="1.0 注册 GitHub"></a>1.0 注册 GitHub</h2><p>&emsp;&emsp;Github 官网：<a href="https://github.com/">Github</a></p>
<p>&emsp;&emsp;正常注册网站账户流程即可。</p>
<p>&emsp;&emsp;注意一点：在选择账户类型时，选择 GitHub 的仓库分为两种，一种是 public repositories 公开免费版，一种是 private repositories 私有付费版。其中，免费版是完全公开的，而私有版一般是由企业或者不愿公开仓库的个人用户购买，在这里，我们选择免费版即可。</p>
<h2 id="2-0-下载-Git"><a href="#2-0-下载-Git" class="headerlink" title="2.0 下载 Git"></a>2.0 下载 Git</h2><p>&emsp;&emsp;Git 官网：<a href="https://git-scm.com/">Git</a></p>
<p>&emsp;&emsp;除了安装位置设置一下外，一路 next 即可。</p>
<p>&emsp;&emsp;安装完成后，任一目录下鼠标右键出现下图即可。</p>
<p>​    <img src="/2023/12/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.jpg" class="" title="咕咕咕"></p>
<p>&emsp;&emsp;打开 Git Bash，输入 <code>git</code> 命令，查看详细信息。</p>
<h2 id="3-1-绑定-Github"><a href="#3-1-绑定-Github" class="headerlink" title="3.1 绑定 Github"></a>3.1 绑定 Github</h2><p>&emsp;&emsp;我们要用 Git 上传文件到 GitHub 首先得利用 SSH 登录远程主机，而登录方式有两种：一种是口令登录；另一种是公钥登录。我们选择公钥授权。首先我们得在 GitHub 上添加 SSH key 配置，要想生成 SSH key，就要先安装 SSH，不过我们安装了 Git Bash，其应该自带了 SSH。检验一下是否安装 SSH，我们在新建的文件夹（git codelife 目录下新建）中右键打开 Git Bash：</p>
<p>&emsp;&emsp;输入 <code>ssh</code> 命令，查看是否安装 ssh。</p>
<p>&emsp;&emsp;确认安装后，输入 <code>ssh-keygen -t rsa</code> 命令，然后敲四次回车键。生成秘钥 id_rsa 和公钥 id_rsa.pub 文件。默认生成在以下目录：<code>C:/Users/ASUS/.ssh</code>。</p>
<p>&emsp;&emsp;接下来我们要做的事情就是把公钥 id_rsa.pub 的内容添加到 GitHub。复制公钥 id_rsa.pub 文件里的内容，你可以通过目录找到 id_rsa.pub 文件的位置，用记事本打开文件复制。</p>
<p>&emsp;&emsp;接下来进入我们的 GitHub 主页，先点击右上角，再点击 settings。进入后，先点击 SSH and GPG keys，再点击 New SSH key。将复制的公钥 id_rsa.pub 的内容粘贴到 key 内，再点击 Add SSH key。</p>
<p>&emsp;&emsp;验证是否成功，我们可以通过在 Git Bash 中输入 <code>ssh -T git@github.com</code> 进行检验。第一次会询问是否继续，<code>yes</code> 即可。</p>
<h2 id="3-1-提交文件"><a href="#3-1-提交文件" class="headerlink" title="3.1 提交文件"></a>3.1 提交文件</h2><p>&emsp;&emsp;提交文件有两种方法。这里只介绍第一种（就我搭建过程而言只用到了第一种而且我认为这一步仅仅是测试作用，不是关键作用）。</p>
<p>&emsp;&emsp;在准备存储 Git 仓库的目录下，执行 <code>git clone github仓库地址</code> 命令即可。Github 仓库地址在 Github 个人中心查看。（选择 ssh 即可，不知道 https 和 ssh 地址在此处有什么区别，笔者选择的是 ssh）。（Git 中的复制和粘贴为 <code>ctrl+insert</code> 和 <code>shift+insert</code>）</p>
<p>&emsp;&emsp;新建文件测试本地仓库与远程仓库内容是否一致，在本地仓库中创建 text.txt 文件。</p>
<p>&emsp;&emsp;使用 <code>git add 文件</code> 命令将文件添加到「临时缓冲区」，再用 <code>git commit -m</code> “提交信息” 将其提交到本地仓库。</p>
<p>&emsp;&emsp;第一次提交需要输入用户名和邮箱（注册GitHub 时使用的用户名和邮箱）具体命令按照 git bash 提示输入即可。</p>
<p>&emsp;&emsp;最后输入 <code>git push origin main</code> 命令，将本地仓库提交到远程仓库。</p>
<h2 id="4-0-域名"><a href="#4-0-域名" class="headerlink" title="4.0 域名"></a>4.0 域名</h2><p>&emsp;&emsp;不要域名的这一步可以省略，不是硬性的。</p>
<p>&emsp;&emsp;笔者选择的阿里云。具体流程按照阿里云流程指南做就行，这比较容易。</p>
<h2 id="5-0-安装-node-js"><a href="#5-0-安装-node-js" class="headerlink" title="5.0 安装 node.js"></a>5.0 安装 node.js</h2><p>&emsp;&emsp;node.js 官网：<a href="https://nodejs.org/en/">node.js</a>。</p>
<p>&emsp;&emsp;设置 npm 在安装全局模块时的路径和环境变量。在 nodejs 文件夹下新建两个空文件夹 node_cache、node_global。打开 cmd，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;设置环境变量：直接本地搜索“系统环境变量”。然后在系统变量中新建一个变量名为<code>NODE_PATH</code>，值为 <code>D:\nodejs\node_global\node_modules</code>。然后编辑用户变量里的 Path，将相应 npm 的路径改为：<code>D:\nodejs\node_global</code>。</p>
<p>&emsp;&emsp;在 cmd 命令下执行 <code>npm install webpack -g</code>。然后 wepack 这个模块就在我们设置默认的文件夹中了。</p>
<h2 id="5-1-安装-hexo"><a href="#5-1-安装-hexo" class="headerlink" title="5.1 安装 hexo"></a>5.1 安装 hexo</h2><p>&emsp;&emsp;先在 GitHub 创建一个名为 <code>用户名.github.io</code> 的仓库。</p>
<p>&emsp;&emsp;新建一个空文件夹，打开 Git Bash，输入 <code>npm install -g hexo-cli</code> 命令安装 hexo。安装完成后，输入 <code>hexo init</code> 命令初始化博客。再输入 <code>hexo g</code> 静态部署。</p>
<p>&emsp;&emsp;将 hexo 部署到 Github 上，在根目录（安装 hexo 的目录）下打开 _config.yml 文件（站点部署文件），添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:   #你的仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;回到根目录，输入 <code>npm install hexo-deployer-git --save</code> 命令。</p>
<p>&emsp;&emsp;最后 hexo 三连。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至此，使用 <code>https://xxx.github.io</code> 即可访问博客。不要域名的话，至此已结束。</p>
<h2 id="6-0-解析域名"><a href="#6-0-解析域名" class="headerlink" title="6.0 解析域名"></a>6.0 解析域名</h2><p>&emsp;&emsp;在阿里云控制台中，为要使用的域名添加两条解析记录：</p>
<ul>
<li>第一条：主机记录选择 www，记录类型选择 CNAME，记录值为 GitHub 仓库名。</li>
<li>第二条：主机记录选择 @，记录类型选择 A，记录值为 IPV4 地址。</li>
</ul>
<p>&emsp;&emsp; IPV4 地址获取方式为：在 cmd 中输入 <code>ping + 你的GitHub的网址</code> 命令查询。</p>
<p>&emsp;&emsp;上述步骤完成后，在根目录下的 source 文件夹中，添加 CNAME（无后缀） 文件，内容写上要使用的域名。完成后，在根目录下 hexo 三连。最后在 GitHub 的仓库 settings 中查看 Github Pages，可以看到 Custom domain 如果域名没有被填进去，手动填写保存即可。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>工业</tag>
      </tags>
  </entry>
</search>
