<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>“锐评”清华社杯</title>
    <url>/2023/12/03/%E2%80%9C%E9%94%90%E8%AF%84%E2%80%9D%E6%B8%85%E5%8D%8E%E7%A4%BE%E6%9D%AF/</url>
    <content><![CDATA[<blockquote>
<p>为了深入贯彻党的二十大提出的构建新一代信息技术、人工智能增长引擎,加快发展数字经济，促进数字经济和实体经济深度融合.打造具有国际竞争力的数字产业集群的政策方针，同时积极响应教育部、国家发展改革委、财政部三部委发文加快人工智能领域人才培养的文件精神，中国电子学会现代教育技术分会决定联合清华大学出版社等单位面向全国高等学校在读全日制研究生和大学生举办2023第二届“清华社杯”大学生算法大赛，旨在促进大学生学习计算机领域专业知识与技能的兴趣，邀发大学生在信息技术和人工智能的算法编程领域勇于发现问题、提出问题和解决问题，有效提升算法设计、逻辑推理、数学建模、编程实现和计算机系统能力，培养团队合作意识、挑战精神和创新能力。</p>
</blockquote>
<span id="more"></span>

<h2 id="体验极差"><a href="#体验极差" class="headerlink" title="体验极差"></a>体验极差</h2><p>抛开这个比赛本身不谈，我觉得这场比赛就是依托答辩。</p>
<p>明面上都第二届了，却给我一种办赛水平甚至不如蓝桥杯周赛。</p>
<h2 id="题面描述不清"><a href="#题面描述不清" class="headerlink" title="题面描述不清"></a>题面描述不清</h2><p>整套题不止一处题面描述不清。</p>
<h3 id="A-题"><a href="#A-题" class="headerlink" title="A 题"></a>A 题</h3><p>整场比赛最大的锅。</p>
<p>A 作为一个签到，却成了通过率最低的题目（题面没改前）。小于 10% 的通过率，我愿称之为算法竞赛有史以来最有“实”力的签到题。</p>
<p>显然答案会是小数，题面却不说保留几位小数。</p>
<p>样例也恰好给一个答案为整数的数据。</p>
<p>要不是我赛时想到了，不然我还真以为出题人埋了个好坑：</p>
<ul>
<li>因为题目的特殊性，所以结果的小数部分只可能是 0.5,0.25,0.75 中的一个，所以特判一下就可以了。</li>
</ul>
<p>但是我这样写没过。</p>
<p>那就是纯纯初生出题人&#x2F;主办方了。</p>
<p>这题导致我吃了 8 发罚时，并且在 2:30 才过了此题（题面 2:00 就修改了，却没有公告广播，只有一个在比赛详情页的，右边一小块地方提了一下，我直接麻了）</p>
<p>也觉得神奇，那些在题面修改前过的是什么样的人？</p>
<ul>
<li>实验了一下，知道了，printf 输出 double 类型，默认六位小数。</li>
</ul>
<center>6！</center>

<h3 id="F-题"><a href="#F-题" class="headerlink" title="F 题"></a>F 题</h3><p>题面里写的是</p>
<blockquote>
<p>前 $i$ 个元素中的最大元素，且小于等于 $X_i$。如果没有答案，请打印 -1。</p>
</blockquote>
<p>但是实际上，是小于等于 $X_i$ 的最大元素。</p>
<p>虽然这个点可以从样例里看出来，但是出题人的描述能力，可见一斑。</p>
<h3 id="E-题"><a href="#E-题" class="headerlink" title="E 题"></a>E 题</h3><p>最后说到：“每两个连续数字之间的绝对值”</p>
<p>我想但凡打过 CF 的人都不会这么描述两个相邻元素。</p>
<h3 id="I-题"><a href="#I-题" class="headerlink" title="I 题"></a>I 题</h3><blockquote>
<p>不同的子序列连续以字母 X 和 Y 结尾</p>
</blockquote>
<blockquote>
<p>对于某些索引 S1[i] 不等于 S2[i]，则 S1 和 S2 被视为不相同</p>
</blockquote>
<p>从未见过在中文题面里写“索引”的。</p>
<p>这题是导致我这场比赛炸裂的罪魁祸首。</p>
<p>我读错了整整<strong>两个多小时</strong>的题面。从 10:30 读错到 12:50。</p>
<p>我赛中以为求的是以 X 开头，Y 结尾的子序列（下标）的个数。</p>
<p>就比如说，第一个样例：<code>xhapxcicbt</code>，我以为的解是 p x c&#x2F;p c c&#x2F;p i c。</p>
<p>并且我还纠结了很久，他这个不同的子序列，到底是不是“本质不同”的个数。</p>
<p>后面我才意识到应该是求以 XY 结尾的本质不同子序列的数量。</p>
<p>最伤心的是：按我之前的题意理解做法得到的 O(nm) 做法，一直卡在 1.5 s 时间超限，导致我一直以为是卡常，卡了整整两个小时的常。从 1.6s 卡到 1.3 s 还是时间超限。</p>
<p>而且我后面揣度出正确题意后，用时 1.3s 时，有时返回时间超限，有时返回答案错误。不懂 OJ 在干什么。</p>
<p>抛开事实不谈，这个样例屁用没有。</p>
<h2 id="赛时无答疑"><a href="#赛时无答疑" class="headerlink" title="赛时无答疑"></a>赛时无答疑</h2><p>一开始我就发了 A 题的询问，到结束，没有回复。不懂他那个“私信官方”是不是就一个摆设？</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>总的来看，这比赛是不是没有验题人？</p>
<p>A 题这样的锅都能出现。已经不是能力问题了。</p>
<p>从题面上，我一个很大的感觉是，大概率是大学老师出的题，而不是 ACM 选手出题。</p>
<p>也不懂这个监控体系是在干什么。</p>
<p>中途上厕所往哪报备？</p>
<p>官网写的是“报名编号+姓名+去做什么+预计多久的形式发给组委会老师”。</p>
<p>通过什么形式发？</p>
<p>我以为它都这么说了，监控系统里应该有申请入口。结果屁都没有。</p>
<p>而且这个报备，也没什么意义吧。该“厕所战神”还是“厕所战神”。</p>
<hr>
<p><font face="楷体">但是打都打了，复盘也写一下好了。</font></p>
<p><font face="楷体">开局 A 先 WA 三发，没什么好说的。</font></p>
<p><font face="楷体">因为记得 QQ 群里组委会老师说题目分布从易到难，所以直接从 B 往后做，但是这个 B 看着不是很能做。看了半天也只看出一个二分性。以及一个枚举 min，然后 max 只能是不小于 min 的最小值，这样就是，组 1 和 组 2 共产生 2n 个二元组，组 3 和组 4 同理。</font></p>
<p><font face="楷体">看了眼榜，G 被开了，就去跟榜了，G 也是签到，没什么好说的。</font></p>
<p><font face="楷体">然后依次跟榜开了 F E，F 开始那个错误的描述，我还以为一个前缀 max 就好了，结果还是得 set。</font></p>
<p><font face="楷体">E 是一个打表猜结论的贪心，虽然这个类似的思路已经烂大街了。</font></p>
<p><font face="楷体">就是把 n&#x2F;2 放到最前面，然后一大一小就好了。</font></p>
<p><font face="楷体">此时榜上暂时没题了，去看了一会 C，感觉应该是一个跟 tarjan 相关的题目，但不是很有想法，而且我 tarjan 也不是很会。</font></p>
<p><font face="楷体">过了一会儿，H 好像有点东西。</font></p>
<p><font face="楷体">去看了一眼，发现小清新。</font></p>
<p><font face="楷体">大概先分个讨。把 $m\neq n-1$ 的情况讨论掉，然后要找那个中心，一个比较显然的结论：中心的度数一定是最大的，而且出了中心之外的点的度数都是小于 3 的。所以判断一下是否有超过 1 个度数超过 2 的点。</font></p>
<p><font face="楷体">然后，然后我就发现，好像做完了。。。</font></p>
<p><font face="楷体">原本以为还要再 dfs 一下的，想了一下发现不用。</font></p>
<p><font face="楷体">这时已经 1 个小时了（因为我中途曾反复回去纠结那个 A 题）</font></p>
<p><font face="楷体">再度入手 B，发现思路一下子就出来了，二分 d，然后枚举组 1 和组 2 的二元组，在组 3 和组 4 中找到一个合法的匹配，就是解一个不等式组。</font></p>
<p>$(a,b),(c,d)\rightarrow b-c\leq d’\ \land\ d-a\leq d’$</p>
<p>$\begin{cases}c\geq b-d’\newline d\leq a+d’\end{cases}$</p>
<p><font face="楷体">只需要把组 3 和组 4 的二元组按 c 升序后，维护一个 d 的后缀 min 即可。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log ^2n)$。</font></p>
<p><font face="楷体">不懂为什么 B 1e5 $n\log^2$ 开 2s，I 题却只开 1s。</font></p>
<p><font face="楷体">此时才 1 个半小时。</font></p>
<p><font face="楷体">剩下的时间基本上就是在干 I 题。</font></p>
<p><font face="楷体">中间也曾看过 D 题，但是鉴定为答辩 BFS 模拟题，没什么意思。</font></p>
<p><font face="楷体">I 题，按我开始的思路就是，每对二元组（$s_i$,$s_j$）对答案的贡献就是 $\binom{j-i-1}{l-2}$。</font></p>
<p><font face="楷体">预处理 $c[x][y][len]$，单次询问 $O(n)$。</font></p>
<p><font face="楷体">但是就这个做法，TLE 了两个小时。硬是没有 WA。</font></p>
<p><font face="楷体">最后一个小时的时候，看出了后面那个题意。</font></p>
<p><font face="楷体">顿时的想法就是维护一个 $dp[i][j]$ 表示前 $i$ 个字符选出长度为 $j$ 的本质不同子序列个数。对于询问 $(X,Y,l)$ 就是从后往前找到 $X$ 的位置最靠后的第一组 $(s_i,s_j)$。答案就是 $dp[i-1][l-2]$，将询问离线，预处理 $O(26n^2)$。单次询问 $O(1)$。但是那个 $dp$ 数组处理不好。一会 WA，一会 TLE。</font></p>
<hr>
<p>排名从十多名，掉到了 200 多名，但是组委会好像说那个榜单是没有分组的。</p>
<p>按有提交就算，总参数人数 3386。5% 一等，总共会有 169 个一等。去掉 A 组后应该比较有希望，但是还有 C 组。。。</p>
<p>那就不知道了。</p>
<p>感觉不是很稳。</p>
<p>无所谓了。</p>
<p>不知道它们最后这个 A 题怎么处理。如果取消 A 的罚时（包括通过用时）。</p>
<p>那我肯定是 6 题第一。</p>
<ul>
<li>重现传智杯初赛 5 题第一（</li>
</ul>
<p>结束后稍微想了下 D 题，发现其实不用 BFS，两个状态之间的最小操作数是可以直接确定的。具体就是两个等式之间，先判一下火柴数量是否相等，然后求有多少位置是一个等式有而另一个等式没有的即可。</p>
<p>这样就只需要枚举一下三个数字和运算符，单次 $O(2\times 10^3)$。</p>
]]></content>
  </entry>
  <entry>
    <title>Codeforces-Round-920-Div3</title>
    <url>/2024/01/16/Codeforces-Round-920-Div3/</url>
    <content><![CDATA[<p>A-D，耻辱之夜。</p>
<span id="more"></span>

<h2 id="A-Square"><a href="#A-Square" class="headerlink" title="A.Square"></a>A.Square</h2><p>题意：以任意顺序给出正方形的四个顶点坐标，求面积。</p>
<p>解：</p>
<p>$(\max\lbrace x\rbrace-\min\lbrace x\rbrace)^2$ 即可。</p>
<h2 id="B-Arranging-Cats"><a href="#B-Arranging-Cats" class="headerlink" title="B.Arranging Cats"></a>B.Arranging Cats</h2><p>题意：可以取出，交换，放入 $1$，求将 $a$ 变成 $b$ 的最小操作数。</p>
<p>解：</p>
<p>首先，对于 $a_i&#x3D;b_i$ 的位置，不用考虑，</p>
<p>其次，那就只有 $a_i&#x3D;1,b_i&#x3D;0$ 或 $a_i&#x3D;0,b_i&#x3D;1$ 的情况了。贪心地想，先移动 $1$ 去匹配 $1<br>$，然后把多的 $1$ 取出即可。 </p>
<p>答案就是 $\max\lbrace[a_i&#x3D;1],[b_i&#x3D;1]\rbrace$。</p>
<h2 id="C-Sending-Messages"><a href="#C-Sending-Messages" class="headerlink" title="C.Sending Messages"></a>C.Sending Messages</h2><p>题意：在 $t_i$ 时刻，手机必须是开机状态。开机状态下，每持续 $1s$，消耗 $a$ 能量；关机不消耗能量，但是开机消耗 $b$ 的能量，初始第 $0s$ 有 $c$ 的能量且出于开机状态。判断是否可以在能量耗尽前满足 $n$ 个时刻都是开机状态。</p>
<p>解：</p>
<p>$t_i$ 必是开机状态，那么 $t_i$ 时刻之后便与 $t_i$ 之前无关，即：贪心地让 $t_i$ 时刻的能量尽可能大即可。在 $t_{i-1}$ 到 $t_i$ 之间，只能是开机一次，或者全程开机。那么比较一下这两者的大小即可。</p>
<h2 id="D-Very-Different-Array"><a href="#D-Very-Different-Array" class="headerlink" title="D.Very Different Array"></a>D.Very Different Array</h2><p>题意：给定两个序列 $a_n$ 和 $b_m$，要求在 $b_m$ 中选出 $n$ 个数使得 $\sum\limits_{i&#x3D;1}^n|a_i-c_i|$ 最大。求最大值。</p>
<p>解；</p>
<p>贪心地想，将 $b_m$ 中大的和 $a_n$ 中小的进行匹配，$b_m$ 中小的和 $a_n$ 中大的进行匹配。</p>
<p>答案与序列的顺序无关，那么可以先将 $a_n,b_m$ 升序，然后用 $b_m$ 的后缀和 $a_n$ 的前缀匹配，$b_m$ 的前缀和 $a_n$ 的后缀匹配即可。枚举这个分界点，一定可以找到最大值。</p>
<p>证明：</p>
<p>引理：</p>
<p>最后的答案形式一定是：</p>
<ul>
<li>在分界点前（含分界点），$a_i&lt;b_i$。</li>
<li>在分界点后：$a_i&gt;b_i$</li>
</ul>
<p>因为如果在分界点后，存在一个位置 $a_i&lt;b_i$，那么 $b_i$ 完全可以移到 $a_i$ 的前面，因为 $a_j&lt;a_i(j&lt;i)$，在前面同样满足 $a_j&lt;b_i$ 且此时答案会变大。</p>
<p>此时，若 分界点前的，不是 $b_m$ 的后缀，那么在 $b_m$ 中一定存在一个比分界点前的 $b_i$ 大的元素去替换它了。</p>
<h2 id="E-Eat-the-Chip"><a href="#E-Eat-the-Chip" class="headerlink" title="E.Eat the Chip"></a>E.Eat the Chip</h2><p>题意：Alice 每次可以向 $(x+1,y-1),(x+1,y),(x+1,y+1)$ 移动，Bob 每次可以向 $(x-1,y-1),(x-1,y),(x-1,y+1)$ 移动。一方将棋子移动到另一方上则该方获胜，反之则是平局，求胜者。</p>
<p>解：</p>
<p>引理：</p>
<p>若 $y_0&#x3D;y_1$，即 Alice 和 Bob 在同一列：</p>
<ul>
<li>$|x_0-x_1|$ 为奇数时，Alice 必胜。</li>
<li>$|x_0-x_1|$ 为偶数时，Bob 必胜。</li>
</ul>
<p>假设 $|x_0-x_1|$ 为偶数时，后手必胜。</p>
<p>那么，$|x_0-x_1|$ 为奇数时，先手往下走，使 $|x_0-x_1|$ 为偶数，且仍满足 $y_0&#x3D;y_1$，那么此时的后手必胜即为初始时的先手必胜。</p>
<p>核心变成 $|x_0-x_1|$ 为偶数时，后手必胜：</p>
<p>策略：无论先手怎么走，后手都选择走到和对方同一列。</p>
<p>那么每次 $|x_0-x_1|$ 变小 $1$，因为 $|x_0-x_1|$ 为偶数，那么最后就是后手必胜。</p>
<p>对于 $y_0\neq y_1$ 的情况：</p>
<ul>
<li>若 $|x_0-x_1|$ 为奇数，那么 Bob 不能获胜，容易发现 $|x_0-x_1|$ 为奇数时最后一步（使得 $x_0&#x3D;x_1$ 的那步）一定是 Alice 走出来的。</li>
<li>若 $|x_0-x_1|$ 为偶数，那么 Alice 不能获胜。同上。</li>
</ul>
<p>所以：</p>
<ul>
<li>$|x_0-x_1|$ 为奇数时，Alice 要在 y 轴追上 Bob，而 Bob 要尽可能地远离 Alice。因为一旦移动的过程中，出现了 $y_0&#x3D;y_1$，那就是 Alice 获胜。所以 Alice 要朝 Bob 的方向移动，Bob 要朝面向 Alice 的另一个方向移动。</li>
<li>$|x_0-x_1|$ 为偶数时，同上。</li>
</ul>
<p>因为 $h\leq 10^6$，所以最多走 $10^6$ 步，所以模拟这个过程即可。</p>
<p>同时，因为奇偶交替的强性质，直接用式子 $O(1)$ 判断也可以。</p>
<h2 id="F-Sum-of-Progression"><a href="#F-Sum-of-Progression" class="headerlink" title="F.Sum of Progression"></a>F.Sum of Progression</h2><p>题意：$q$ 次询问 $s,d,k$ 求 $a_s+a_{s+d}\times2+…+a_{s+(k-1)d}\times k$。</p>
<p>解：</p>
<p>对索引等差求和是根号分治的一种经典思路。</p>
<p>先考虑这样一个问题：</p>
<p>求 $\sum\limits_{i&#x3D;l}^r(i-l+1)\times a_i$。</p>
<p>先把式子拆成：$\sum\limits_{i&#x3D;l}^ri\times a_i-(l-1)\sum\limits_{i&#x3D;l}^ra_i$。</p>
<p>然后对前后两部分分别做前缀和差分即可。</p>
<p>那么此题也是一样。</p>
<p>设阈值为 $t$：</p>
<ul>
<li>若 $d&gt;t$，$k\leq\lfloor\frac{n}{d}\rfloor&lt;\lfloor\frac{n}{t}\rfloor$。暴力求和即可。</li>
<li>若 $d\leq t$，用上述套路解决。$sum[i][j][0&#x2F;1]$ 表示公差为 $j$ 的前 $i$ 个数的两种前缀和。</li>
</ul>
<p>时间复杂度：$O(q\lfloor\frac{n}{t}\rfloor)$。</p>
<p>空间复杂度：$O(nt)$。</p>
<p>直接将 $t$ 设为 $\sqrt n$ 即可。</p>
<p>时间复杂度；$O(n\sqrt n)$。</p>
<p>空间复杂度：$O(n\sqrt n)$。</p>
<h3 id="addition："><a href="#addition：" class="headerlink" title="addition："></a>addition：</h3><p>看到一种不显式设阈值分析的根号算法。</p>
<p>将询问离线。对于每个 $s\bmod d$，求从 $s\bmod d$ 开始的公差为 $d$ 的一个序列。同样使用前文中的两种前缀和维护。每次询问时，直接 $O(1)$ 差分询问即可。这样的询问时间复杂度就是 $O(q)$ 的了。</p>
<p>考虑从 $s\bmod d$ 开始的公差为 $d$ 的序列的维护。对于一组 $s\bmod d$，直接暴力加公差的时间复杂度为 $O(\frac{n}{d})$。但是对于同一组 $(s\bmod d,d)$（即：起点和公差相同的情况）可以略去。</p>
<p>因为 $s\bmod d$ 的值只有 $[0,d)$，所以一<strong>种</strong> $d$ 的值会产生 $d\times \frac{n}{d}&#x3D;n$ 的时间消耗。那么总共只有 $n$ 个 $d$，所以最多只会有 $\sqrt n\times n$ 的时间消耗。</p>
<p>因为 $1+2+…+d&#x3D;\frac{d\times(d+1)}{2}$，$d\leq \sqrt n$。所以最多也就只有 $\sqrt n$ 种 $d$，所以暴力预处理的时间复杂度也只有 $O(n\sqrt n)$。</p>
<p>空间复杂度同样为 $O(n\sqrt n)$。</p>
<p>但是是暴力。而且不用设阈值。</p>
<h2 id="G-Mischievous-Shooter"><a href="#G-Mischievous-Shooter" class="headerlink" title="G.Mischievous Shooter"></a>G.Mischievous Shooter</h2><p>待补。</p>
]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
  </entry>
  <entry>
    <title>个人博客搭建笔记</title>
    <url>/2023/12/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>  选择 hexo 框架和 next 主题搭建个人博客。</p>
<span id="more"></span>

<p>$\sum\limits_{i&#x3D;1}^n a_i$</p>
<h2 id="1-0-注册-GitHub"><a href="#1-0-注册-GitHub" class="headerlink" title="1.0 注册 GitHub"></a>1.0 注册 GitHub</h2><p>&emsp;&emsp;Github 官网：<a href="https://github.com/">Github</a></p>
<p>&emsp;&emsp;正常注册网站账户流程即可。</p>
<p>&emsp;&emsp;注意一点：在选择账户类型时，选择 GitHub 的仓库分为两种，一种是 public repositories 公开免费版，一种是 private repositories 私有付费版。其中，免费版是完全公开的，而私有版一般是由企业或者不愿公开仓库的个人用户购买，在这里，我们选择免费版即可。</p>
<h2 id="2-0-下载-Git"><a href="#2-0-下载-Git" class="headerlink" title="2.0 下载 Git"></a>2.0 下载 Git</h2><p>&emsp;&emsp;Git 官网：<a href="https://git-scm.com/">Git</a></p>
<p>&emsp;&emsp;除了安装位置设置一下外，一路 next 即可。</p>
<p>&emsp;&emsp;安装完成后，任一目录下鼠标右键出现下图即可。</p>
<p>​    <img src="/2023/12/01/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.jpg" class="" title="咕咕咕"></p>
<p>&emsp;&emsp;打开 Git Bash，输入 <code>git</code> 命令，查看详细信息。</p>
<h2 id="3-1-绑定-Github"><a href="#3-1-绑定-Github" class="headerlink" title="3.1 绑定 Github"></a>3.1 绑定 Github</h2><p>&emsp;&emsp;我们要用 Git 上传文件到 GitHub 首先得利用 SSH 登录远程主机，而登录方式有两种：一种是口令登录；另一种是公钥登录。我们选择公钥授权。首先我们得在 GitHub 上添加 SSH key 配置，要想生成 SSH key，就要先安装 SSH，不过我们安装了 Git Bash，其应该自带了 SSH。检验一下是否安装 SSH，我们在新建的文件夹（git codelife 目录下新建）中右键打开 Git Bash：</p>
<p>&emsp;&emsp;输入 <code>ssh</code> 命令，查看是否安装 ssh。</p>
<p>&emsp;&emsp;确认安装后，输入 <code>ssh-keygen -t rsa</code> 命令，然后敲四次回车键。生成秘钥 id_rsa 和公钥 id_rsa.pub 文件。默认生成在以下目录：<code>C:/Users/ASUS/.ssh</code>。</p>
<p>&emsp;&emsp;接下来我们要做的事情就是把公钥 id_rsa.pub 的内容添加到 GitHub。复制公钥 id_rsa.pub 文件里的内容，你可以通过目录找到 id_rsa.pub 文件的位置，用记事本打开文件复制。</p>
<p>&emsp;&emsp;接下来进入我们的 GitHub 主页，先点击右上角，再点击 settings。进入后，先点击 SSH and GPG keys，再点击 New SSH key。将复制的公钥 id_rsa.pub 的内容粘贴到 key 内，再点击 Add SSH key。</p>
<p>&emsp;&emsp;验证是否成功，我们可以通过在 Git Bash 中输入 <code>ssh -T git@github.com</code> 进行检验。第一次会询问是否继续，<code>yes</code> 即可。</p>
<h2 id="3-1-提交文件"><a href="#3-1-提交文件" class="headerlink" title="3.1 提交文件"></a>3.1 提交文件</h2><p>&emsp;&emsp;提交文件有两种方法。这里只介绍第一种（就我搭建过程而言只用到了第一种而且我认为这一步仅仅是测试作用，不是关键作用）。</p>
<p>&emsp;&emsp;在准备存储 Git 仓库的目录下，执行 <code>git clone github仓库地址</code> 命令即可。Github 仓库地址在 Github 个人中心查看。（选择 ssh 即可，不知道 https 和 ssh 地址在此处有什么区别，笔者选择的是 ssh）。（Git 中的复制和粘贴为 <code>ctrl+insert</code> 和 <code>shift+insert</code>）</p>
<p>&emsp;&emsp;新建文件测试本地仓库与远程仓库内容是否一致，在本地仓库中创建 text.txt 文件。</p>
<p>&emsp;&emsp;使用 <code>git add 文件</code> 命令将文件添加到「临时缓冲区」，再用 <code>git commit -m</code> “提交信息” 将其提交到本地仓库。</p>
<p>&emsp;&emsp;第一次提交需要输入用户名和邮箱（注册GitHub 时使用的用户名和邮箱）具体命令按照 git bash 提示输入即可。</p>
<p>&emsp;&emsp;最后输入 <code>git push origin main</code> 命令，将本地仓库提交到远程仓库。</p>
<h2 id="4-0-域名"><a href="#4-0-域名" class="headerlink" title="4.0 域名"></a>4.0 域名</h2><p>&emsp;&emsp;不要域名的这一步可以省略，不是硬性的。</p>
<p>&emsp;&emsp;笔者选择的阿里云。具体流程按照阿里云流程指南做就行，这比较容易。</p>
<h2 id="5-0-安装-node-js"><a href="#5-0-安装-node-js" class="headerlink" title="5.0 安装 node.js"></a>5.0 安装 node.js</h2><p>&emsp;&emsp;node.js 官网：<a href="https://nodejs.org/en/">node.js</a>。</p>
<p>&emsp;&emsp;设置 npm 在安装全局模块时的路径和环境变量。在 nodejs 文件夹下新建两个空文件夹 node_cache、node_global。打开 cmd，输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;D:\nodejs\node_global&quot;</span><br><span class="line">npm config set cache &quot;D:\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;设置环境变量：直接本地搜索“系统环境变量”。然后在系统变量中新建一个变量名为<code>NODE_PATH</code>，值为 <code>D:\nodejs\node_global\node_modules</code>。然后编辑用户变量里的 Path，将相应 npm 的路径改为：<code>D:\nodejs\node_global</code>。</p>
<p>&emsp;&emsp;在 cmd 命令下执行 <code>npm install webpack -g</code>。然后 wepack 这个模块就在我们设置默认的文件夹中了。</p>
<h2 id="5-1-安装-hexo"><a href="#5-1-安装-hexo" class="headerlink" title="5.1 安装 hexo"></a>5.1 安装 hexo</h2><p>&emsp;&emsp;先在 GitHub 创建一个名为 <code>用户名.github.io</code> 的仓库。</p>
<p>&emsp;&emsp;新建一个空文件夹，打开 Git Bash，输入 <code>npm install -g hexo-cli</code> 命令安装 hexo。安装完成后，输入 <code>hexo init</code> 命令初始化博客。再输入 <code>hexo g</code> 静态部署。</p>
<p>&emsp;&emsp;将 hexo 部署到 Github 上，在根目录（安装 hexo 的目录）下打开 _config.yml 文件（站点部署文件），添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository:   #你的仓库地址</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;回到根目录，输入 <code>npm install hexo-deployer-git --save</code> 命令。</p>
<p>&emsp;&emsp;最后 hexo 三连。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;至此，使用 <code>https://xxx.github.io</code> 即可访问博客。不要域名的话，至此已结束。</p>
<h2 id="6-0-解析域名"><a href="#6-0-解析域名" class="headerlink" title="6.0 解析域名"></a>6.0 解析域名</h2><p>&emsp;&emsp;在阿里云控制台中，为要使用的域名添加两条解析记录：</p>
<ul>
<li>第一条：主机记录选择 www，记录类型选择 CNAME，记录值为 GitHub 仓库名。</li>
<li>第二条：主机记录选择 @，记录类型选择 A，记录值为 IPV4 地址。</li>
</ul>
<p>&emsp;&emsp; IPV4 地址获取方式为：在 cmd 中输入 <code>ping + 你的GitHub的网址</code> 命令查询。</p>
<p>&emsp;&emsp;上述步骤完成后，在根目录下的 source 文件夹中，添加 CNAME（无后缀） 文件，内容写上要使用的域名。完成后，在根目录下 hexo 三连。最后在 GitHub 的仓库 settings 中查看 Github Pages，可以看到 Custom domain 如果域名没有被填进去，手动填写保存即可。</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>工业</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构（三）</title>
    <url>/2024/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>分块</p>
<span id="more"></span>

<p>分块是优美的暴力，但却并不是暴力。</p>
<p>常见分块为根号分块，一种基于根号均衡的根号算法。</p>
<p>在数据结构问题中，一般使用的为序列分块。</p>
<h2 id="根号均衡："><a href="#根号均衡：" class="headerlink" title="根号均衡："></a>根号均衡：</h2><p>$a\times b&#x3D;n$，$\min\lbrace a,b\rbrace\leq \sqrt n$.</p>
<p>$a+\frac na\geq 2\sqrt n$</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>序列分块。</p>
<p>将原序列按 $t$ 为块长，划分成 $\frac nt$ 块。</p>
<img src="/2024/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89/1.png" class="" title="咕咕咕">

<h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>对于一个区间 $[l,r]$，一定可以拆分成：</p>
<ul>
<li>块的三部分：$l$ 到 $l$ 所在块的右端点；$l$ 所在块的下一块到 $r$ 所在块的上一块；$r$ 所在块的左端点到 $r$。</li>
<li>特殊情况：$l,r$ 在同一块内。</li>
</ul>
<p>对于块的三部分，一个块为一个整体，共有 $O(\frac nt)$ 个块，$l$ 和 $r$ 的块内元素共有 $O(t)$ 个。同样的，$l,r$ 在同一块内，元素个数为 $O(t)$ 个。$r$ 的块内元素共有 $O(t)$ 个。同样的，$l,r$ 在同一块内，元素个数为 $O(t)$ 个。</p>
<h2 id="分（建）块："><a href="#分（建）块：" class="headerlink" title="分（建）块："></a>分（建）块：</h2><p>枚举块的编号，遍历块的范围内元素以维护整块信息即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bh</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)/t+<span class="number">1</span>;&#125;<span class="comment">//计算 x 所在的块的编号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x<span class="number">-1</span>)*t+<span class="number">1</span>;&#125;<span class="comment">//计算第 x 个块的左端点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">min</span>(n,x*t);&#125;<span class="comment">//计算 x 个块的右端点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,<span class="built_in">bh</span>(n))</span><br><span class="line">    <span class="built_in">For</span>(j,<span class="built_in">left</span>(i),<span class="built_in">right</span>(i))</span><br><span class="line">    	block[i].sum+=a[j];</span><br></pre></td></tr></table></figure>

<p>注意一点：$n$ 是序列的右端点，但不一定是整块的右端点，要小心处理。体现在代码中，计算块的右端点时，和 $n$ 取 $\min$。</p>
<h2 id="询问："><a href="#询问：" class="headerlink" title="询问："></a>询问：</h2><p>以区间求和为例分析，若维护整块的和，散块暴力累计。则单次询问时间为 $O(t+\frac nt)$。当 $t&#x3D;\sqrt n$ 时，$O(t+\frac nt)$ 取得最小值，为 $O(2\sqrt n)$。所以一般块长设为 $\sqrt n$。</p>
<p>但是具体题目具体分析。由于不同题目限制不同，所得时间复杂度也不尽相同，所以块长也会做相应调整。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="built_in">bh</span>(l)+<span class="number">1</span>,<span class="built_in">bh</span>(r)<span class="number">-1</span>) res+=block[i].sum;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bh</span>(l)==<span class="built_in">bh</span>(r))&#123;</span><br><span class="line">        <span class="built_in">For</span>(i,l,r) res+=a[i]+block[<span class="built_in">bh</span>(i)].tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">For</span>(i,l,<span class="built_in">right</span>(<span class="built_in">bh</span>(l))) res+=a[i]+block[<span class="built_in">bh</span>(i)].tag;</span><br><span class="line">        <span class="built_in">For</span>(i,<span class="built_in">left</span>(<span class="built_in">bh</span>(r)),r) res+=a[i]+block[<span class="built_in">bh</span>(i)].tag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h2><p>与询问一致，同样是散块暴力，整块整体维护。</p>
<p>但是此时存在一个问题：修改时维护了整块的整体的答案，但是整块内的信息并未得到维护，而在之后的询问中，询问到散块信息时，是需要整块内的信息的，所以这里需要借助和线段树一样的懒标记。</p>
<p>进行区间修改时，维护懒标记的信息。需要用到散块信息时，则将懒标记下传，维护散块信息。后重新维护整块信息。</p>
<p>笔者将下传标记维护散块信息写作 <code>down</code>，重新维护整块信息写作 <code>up</code>，两个过程一同视作块的重构过程。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="built_in">left</span>(<span class="built_in">bh</span>(l)),<span class="built_in">right</span>(<span class="built_in">bh</span>(r))) a[i]+=block[<span class="built_in">bh</span>(l)].tag;</span><br><span class="line">    block[<span class="built_in">bh</span>(l)].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,l,r) a[i]+=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    block[x].sum=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="built_in">left</span>(x),<span class="built_in">right</span>(x)) block[x].sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="built_in">bh</span>(l)+<span class="number">1</span>,<span class="built_in">bh</span>(r)<span class="number">-1</span>)</span><br><span class="line">        block[i].tag+=v,block[i].sum+=v*t;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bh</span>(l)==<span class="built_in">bh</span>(r))&#123;</span><br><span class="line">        <span class="built_in">down</span>(l,r,v);</span><br><span class="line">        <span class="built_in">up</span>(<span class="built_in">bh</span>(l));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">down</span>(l,<span class="built_in">right</span>(<span class="built_in">bh</span>(l)),v);</span><br><span class="line">        <span class="built_in">up</span>(<span class="built_in">bh</span>(l));</span><br><span class="line">        <span class="built_in">down</span>(<span class="built_in">left</span>(<span class="built_in">bh</span>(r)),r,v);</span><br><span class="line">        <span class="built_in">up</span>(<span class="built_in">bh</span>(r));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，对于维护可标记永久化的信息，使用标记永久化也可（就比如上文中的区间求和）。</p>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="例题讲解："><a href="#例题讲解：" class="headerlink" title="例题讲解："></a>例题讲解：</h3><p><a href="https://www.luogu.com.cn/blog/yrj20201208/fen-kuai-ru-men">分块入门-咕咕咕-LibreOJ数列分块入门</a></p>
<h3 id="值域分块："><a href="#值域分块：" class="headerlink" title="值域分块："></a>值域分块：</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构（一）</title>
    <url>/2024/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>树状数组</p>
<span id="more"></span>

<p>树状数组是一种基于二进制位性质的类树形结构，可以 $O(\log n)$ 进行单点修改，$O(\log n)$ 进行前缀询问的数据结构。</p>
<h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>$lowbit(x)&#x3D;x\And-x$</p>
<p>$lowbit(x)$ 定义为非负整数 $x$ 在二进制表达下，最低位的 $1$ 及其后面的 $0$ 构成的二进制数。同时也是最大的整除 $x$ 的 $2$ 的整数幂。</p>
<p>证明：</p>
<p>在计算机中，负整数的二进制表示，为正整数的二进制取反后加 $1$ 。</p>
<p>也就是保留从后往前第一个 $1$ 后将其它位置取反。</p>
<p>所以 $x\And-x$ 即为 $x$ 在二进制表达下，最低位的 $1$ 及其后面的 $0$ 构成的二进制数。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>树状数组定义了 $tr[x]$ 表示区间 $[x-lowbit(x)+1,x]$ 的信息和。我们称这个区间为 $x$ 的管辖区间。</p>
<img src="/2024/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class="" title="咕咕咕">

<h2 id="询问："><a href="#询问：" class="headerlink" title="询问："></a>询问：</h2><p>那么对于一个前缀区间 $[1,x]$，一定能拆分成 $x$ 的二进制上 $1$ 的位数个 $tr[x]$ 的和。</p>
<p>例如 $[1,5]$ 可以划分成 $[5,5]$ 和 $[1,4]$ 两个。</p>
<p>$5:[100+1,101] 4:[000+1,100]$</p>
<p>那么将这二进制位数个 $tr[x]$ 相加就实现了 $O(\log n)$ 的前缀查询，因为二进制位数是 $O(\log n)$ 级别的，而且是不大于 $O(\log n)$ 的。</p>
<p>每一次 $-lowbit(x)$ 即可得到下一个区间。</p>
<h2 id="修改："><a href="#修改：" class="headerlink" title="修改："></a>修改：</h2><p>要修改的是 $x$ 位置的单点值，但是我们需要修改不止一个 $tr[x’]$。因为是否修改 $tr[x’]$ 是取决于 $tr[x’]$ 是否覆盖了 $x$。</p>
<h3 id="解释-1-："><a href="#解释-1-：" class="headerlink" title="解释 $1$："></a>解释 $1$：</h3><p>$tr[x’]$ 所管辖的区间为 $[x’-lowbit(x’)+1,x’]$。当 $x’-lowbit(x’)\leq x\land x\leq x’$ 时，tr[x’] 覆盖了 $x$。此时 $x’$ 满足，$x’$ 除 $lowbit(x’)$ 外的高位 为 $x$ 的前缀，且 $lowbit(x’)$ 为 $1$ 的这一位 $x$ 为 $0$。</p>
<p>这样的 $x’$ 可以通过 $x$ 开始不断 $+lowbit(x)$ 得到。</p>
<h3 id="解释-2-："><a href="#解释-2-：" class="headerlink" title="解释 $2$："></a>解释 $2$：</h3><p>根据树状数组的树形结构，$tr[x’]$ 覆盖了 $x$ 当且仅当 $x’$ 是 $x$ 的祖先结点，那么不断跳父节点就可以得到 $x’$ 了，而跳父节点的操作，在树状数组上就是 $+lowbit(x)$。</p>
<p>每一次 $+lowbit(x)$ 都会变成下一个 $1$ 更高的第一个 $0$ 的位。所以时间复杂度同样是 $O(\log n)$ 的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line">    <span class="type">int</span> tr[N],n;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;x&lt;=n;x+=<span class="built_in">lowbit</span>(x)) tr[x]+=v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;x;x-=<span class="built_in">lowbit</span>(x)) res+=tr[x];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Bit;</span><br></pre></td></tr></table></figure>

<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="前缀-min-max-："><a href="#前缀-min-max-：" class="headerlink" title="前缀 $\min&#x2F;\max$："></a>前缀 $\min&#x2F;\max$：</h3><p>若能理解树状数组的原理，便不难解决这个问题。</p>
<p>树状数组将前缀询问分成了 $O(\log n)$ 个独立的区间，那么只要是能够通过合并两个区间信息得到的大区间信息，都可以可以维护的。</p>
<p>单点修改则用修改后的信息更新 $O(\log)$ 个区间，那么是否支持修改为任意数呢？</p>
<p>答案是否定的。对于前缀 $\min$ 只能支持单点减的修改；对于前缀 $\max$ 只能支持单点加的修改。</p>
<p>因为树状数组修改是基于旧最值和新修改的值进行的更新，而最值不能依附于旧值，因为无法确定这个最值是否恰好是被修改的数。</p>
<h3 id="区间询问："><a href="#区间询问：" class="headerlink" title="区间询问："></a>区间询问：</h3><p>树状数组本身维护的为前缀区间信息。然而若维护的信息是可差分的，即 $[l,r]$ 的信息可以通过 $[1,r]-[1,l-1]$ 得到，那么就可以利用树状数组支持区间询问。</p>
<h3 id="区间修改："><a href="#区间修改：" class="headerlink" title="区间修改："></a>区间修改：</h3><p>同样的，若维护的信息是可差分的，那么将区间修改转化成单点加和单点减，即可实现区间修改。</p>
<h3 id="区间询问-区间修改："><a href="#区间询问-区间修改：" class="headerlink" title="区间询问+区间修改："></a>区间询问+区间修改：</h3><p>使用上述差分的方法，也只能仅支持区间询问或仅支持区间修改，不能同时支持区间询问和区间修改。</p>
<p>那么是否能使用树状数组同时支持区间询问和区间修改呢？</p>
<p>也是有可能可以的。</p>
<p>牢牢把握树状数组的本质：单点修改和前缀询问。树状数组本质是不能改变的，但是具体的询问和修改却可以依题目而变，所以可以尝试从修改和询问的性质入手。</p>
<p>以区间加和区间求和为例：</p>
<p>令 $b_i&#x3D;a_i-a_{i-1}，$$\sum\limits_{i&#x3D;l}^r a_i&#x3D;\sum\limits_{i&#x3D;l}^r\sum\limits_{j&#x3D;1}^i b_j$</p>
<p>考虑每个 $b_j$ 的贡献，可得：$\sum\limits_{i&#x3D;l}^r(r-i+1)\times b_i&#x3D;(r+1)\times\sum\limits_{i&#x3D;l}^rb_i-\sum\limits_{i&#x3D;l}^rib_i$。</p>
<p>所以只要维护两个树状数组，一个维护 $b_i$，一个维护 $ib_i$，即可。</p>
<p>$b_i$ 已经是差分数组了，对 $b_i$ 的修改即为单点修改。</p>
<h3 id="树状数组维护不可差分信息："><a href="#树状数组维护不可差分信息：" class="headerlink" title="树状数组维护不可差分信息："></a>树状数组维护不可差分信息：</h3><p>此部分数据结构功能对应线段树，但时间复杂度严格劣于线段树，选择性学习。</p>
<p>树状数组维护不可差分信息，依然是只能支持单点修改和区间询问，但单点修改和区间询问时间复杂度均为 $O(\log^2n)$。</p>
<h4 id="区间询问：-1"><a href="#区间询问：-1" class="headerlink" title="区间询问："></a>区间询问：</h4><p>对于区间询问 $[l,r]$ 同样是将区间拆分成若干个区间，只是现在不能拆到 $1$ 了，即拆分成的区间的范围不能小于 $l$。</p>
<p>因此：</p>
<ul>
<li>$x-lowbit(x)&lt;l$，将 $a[x]$ 合并即可，然后继续从 $tr[x-1]$ 考虑。直到 $x&#x3D;l$，$a[x]$ 即为原序列，直接在原序列上维护即可。</li>
<li>$x-lowbit(x)\geq l$，正常考虑。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r&gt;=l)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,a[r]);</span><br><span class="line">        --r;</span><br><span class="line">        <span class="keyword">for</span>(;r-<span class="built_in">lowbit</span>(r)&gt;=l;r-=<span class="built_in">lowbit</span>(r)) ans=<span class="built_in">max</span>(ans,tr[r]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h4><p>不可差分信息单点修改同最值（最值本身即为一种不可差分信息）。不能使用旧值更新新值。</p>
<p>但是，树状数组上，$x$ 的儿子的信息是没有发生变化的（也就依然是新值），所以先用儿子更新 $tr[x]$，再用修改的新值更新 $tr[x]$ 即可。同时，由于 $x$ 的新值会破坏它的所有父节点的信息，所以 $x$ 所有的父节点也都要用儿子更新一遍</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    a[x]=v;</span><br><span class="line">    <span class="keyword">for</span> (;x&lt;=n;x+=<span class="built_in">lowbit</span>(x))&#123;</span><br><span class="line">        tr[x]=a[x];</span><br><span class="line">        <span class="keyword">for</span> (v=<span class="number">1</span>;v&lt;<span class="built_in">lowbit</span>(x);v&lt;&lt;=<span class="number">1</span>) </span><br><span class="line">            tr[x]=<span class="built_in">max</span>(tr[x],tr[x-v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述做法虽然是 $O(\log^2n)$ 的，但是很显然，其常数巨小，实际表现不一定会在所有情况下劣于线段树的 $O(\log n)$，而且代码量极短。</p>
<h3 id="权值树状数组："><a href="#权值树状数组：" class="headerlink" title="权值树状数组："></a>权值树状数组：</h3><p>正常情况下，使用树状数组维护的是一个序列，而权值树状数组维护的则是问题的值域。原理与使用与普通树状数组无异，这里不再赘述。</p>
<p>这里只是引入这样将树状数组视作“计数器”维护值域的思想。</p>
<p>通常使用权值树状数组维护逆序对数量与全局第 $k$ 小。</p>
<h3 id="树状数组二分："><a href="#树状数组二分：" class="headerlink" title="树状数组二分："></a>树状数组二分：</h3><p>例如：在保证 $a_i\geq 0$ 的情况下，求最小的 $x$ 满足 $\sum\limits_{i&#x3D;1}^x a_i&gt;y$。且要求多次询问和单点加。</p>
<h4 id="树状数组-二分："><a href="#树状数组-二分：" class="headerlink" title="树状数组$+$二分："></a>树状数组$+$二分：</h4><p>更形象的叫法应该是：树状数组套二分。那么就是在外层二分模型下，查询前缀和。同时维护单点加。</p>
<p>时间复杂度：$O(\log^2n)$。</p>
<p>虽然是 $O(\log^2n)$，但是实际表现却十分优先，许多情况下，并不比线段树上二分劣。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l,r,mid;</span><br><span class="line">l=<span class="number">1</span>,r=n;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;<span class="number">4</span>)&#123;</span><br><span class="line">    mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Bit.<span class="built_in">query</span>(mid)&gt;v) r=mid;</span><br><span class="line">    <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(mid=l;mid&lt;=r;mid++) <span class="keyword">if</span>(Bit.<span class="built_in">query</span>(mid)&gt;v) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h4 id="树状数组上二分："><a href="#树状数组上二分：" class="headerlink" title="树状数组上二分："></a>树状数组上二分：</h4><p>更准确地这里应该是树状数组上倍增，但是一般而言倍增和二分可以互相转化，所以也无伤大雅。</p>
<p>从最高位开始，若这一位的管辖区间和加上已累加的超过了 $y$，则考虑下一位，否则就累加到答案中。最多考虑 $\log n$ 位。</p>
<p>时间复杂度：$O(\log n)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> _log=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((<span class="number">1</span>&lt;&lt;_log)&lt;=n)  _log++;</span><br><span class="line">    _log--;</span><br><span class="line">    <span class="type">int</span> i,x=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">FOR</span>(i,_log,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span>(tr[x+(<span class="number">1</span>&lt;&lt;i)]&lt;=v)&#123;</span><br><span class="line">        v-=tr[x+(<span class="number">1</span>&lt;&lt;i)];</span><br><span class="line">        x+=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构（二）</title>
    <url>/2024/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>线段树</p>
<span id="more"></span>

<p>千呼万唤始出来。</p>
<p>线段树是算法竞赛中最常用的、应用最广的用来维护 <strong>区间信息</strong> 的数据结构。</p>
<p>线段树可以在 $O(\log n)$ 的时间复杂度内实现单点修改、区间修改、区间查询等操作。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>线段树将每个长度不为 $1$ 的区间划分成左右两个区间递归求解，把整个线段划分成一个树形结构。</p>
<p>设 $x$ 的管辖区间为 $[l,r]$，则 $x$ 的左儿子的管辖区间为 $[l,mid]$，$x$ 的右儿子的管辖区间为 $[mid+1,r]$。</p>
<img src="/2024/01/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89/1.jpg" class="" title="咕咕咕">

<p>在实际应用中，采用二进制编码的方式表示树上的结点：</p>
<p>设当前结点为 $x$，则左儿子为 $x&lt;&lt;1$，右儿子为 $x&lt;&lt;1|1$。</p>
<p>（用一个结构体维护结点蕴含所有信息，把左右儿子的序号直接存进结构体也是一种常见写法，但是笔者看来更适合之后的动态开点线段树）</p>
<p>因为这样的堆式存储使得部分结点就算在线段树没有实际左右儿子，但是同样会占用数组内存，所以线段树总结点个数为 $2^{\lceil{\log n}\rceil+1}-1$。当 $n&#x3D;2^x+1$ 时，结点树数取得最大值：$4n-5$。所以一般线段树开 $4n$ 的空间。</p>
<h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>对于一个 $[x,y]$ 一定能被拆分成 $O(\log n)$ 个线段树上结点所表示的区间并。</p>
<p>这是支持线段树完成 $O(\log n)$ 实现区间操作的基本原理。</p>
<p>证明：</p>
<p>在线段树上递归时，考虑第一个中点位于 $[x,y]$ 之间的区间 $[l,r]$。此时，$[x,y]$ 便可以依 $mid$ 划分为两部分：$[x,mid]$ 和 $[mid+1,y]$。$mid$ 是 $[l,mid]$ 的右端点，$mid+1$ 是 $[mid+1,r]$ 的左端点。</p>
<p>先考虑 $[mid+1,r]$ 中划分 $[mid+1,y]$ 的情况。</p>
<p>容易发现，$[mid+1,r]$ 中划分 $[mid+1,y]$ 的第一个区间长度是 $\leq y-mid$ 的最大 $2$ 的整数幂。之后的递归也是同理，所以 $[mid+1,y]$ 就被划分成了若干个严格递减的 $2$ 的整数幂长度的区间，容易发现，这个至多是 $O(\log n)$ 级别的。$[l,mid]$ 划分 $[x,mid]$ 同理。</p>
<p>综上：一个 $[x,y]$ 一定能被拆分成 $\log n$ 个线段树上结点所表示的区间并。</p>
<p>（本文以线段树维护区间和，区间加示例）</p>
<h2 id="建树："><a href="#建树：" class="headerlink" title="建树："></a>建树：</h2><p>按定义所规定的管辖区间递归建树即可。用子结点信息更新父节点信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[t].sum=a[l];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(t&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">push_up</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间询问："><a href="#区间询问：" class="headerlink" title="区间询问："></a>区间询问：</h2><p>在具体的线段树代码实现中，不唯一，不局限。只要本质相同即可。</p>
<p>下面以笔者代码分析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> tr[t].sum;<span class="comment">//返回信息</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(t&lt;&lt;<span class="number">1</span>,l,mid,x,y);<span class="comment">//返回左儿子的信息</span></span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);<span class="comment">//返回右儿子的信息</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当递归到的结点所在区间完全包含于询问区间，则直接返回结点信息。</p>
<p>询问区间在递归时，可以改成前文中的 $[x,mid]$ 和 $[mid+1,y]$，不影响结果。因为之后递归的结点区间若完全包含于 $[x,mid]$ 或 $[mid+1,y]$ 则一定也完全包含于 $[x,y]$。</p>
<h2 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h2><p>线段树的单点修改较区间修改更复杂，下面先考虑单点修改。</p>
<p>（单点修改是区间修改的子集，若线段树一定能支持某类操作的区间修改，则一定能支持单点修改，反之不然）</p>
<p>从线段树的根节点开始，递归到 $[x,x]$ 所在结点。后回溯更新祖先结点信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;<span class="comment">//l=r一定满足l=x=r</span></span><br><span class="line">        tr[t],sum+=v;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>,l,mid,x,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,v);</span><br><span class="line">    <span class="built_in">push_up</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="子结点信息更新父节点信息："><a href="#子结点信息更新父节点信息：" class="headerlink" title="子结点信息更新父节点信息："></a>子结点信息更新父节点信息：</h2><p>一般将此操作写作 <code>push_up</code> 作为一个单独的函数出现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void push_up(int t)&#123;</span><br><span class="line">    tr[t].sum=tr[t&lt;&lt;1].sum+tr[t&lt;&lt;1|1].sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间修改："><a href="#区间修改：" class="headerlink" title="区间修改："></a>区间修改：</h2><p>类比区间询问，将修改区间 $[x,y]$ 拆分成线段树上 $O(\log n)$ 个区间。把修改的信息标记到这个区间上。但是这时候就能发现，这样并没有维护住线段树的定义信息。标记的区间的儿子结点的信息没有更新，标记的区间的父节点的信息也没有更新。可要让所有结点的信息都完成更新，则需要修改 $O(n)$ 个结点的信息，这是不能接受的。</p>
<h3 id="标记永久化："><a href="#标记永久化：" class="headerlink" title="标记永久化："></a>标记永久化：</h3><p>修改操作和询问操作是紧密联系在一起的，如果不支持询问的操作，那么修改的支持便毫无意义。</p>
<p>以区间加，单点查询为例：</p>
<p>因为单点查询时，必然递归经过所有包含单点的区间。所以可以把修改的信息和初始信息分开考虑，将标记就固定在修改到的区间上。那么在查询时，把递归路径上经过的区间上的标记信息累计起来即可。</p>
<p>但是对于区间询问，就有所不同，因为区间询问时不会递归到拆分之后的区间的后代结点，而若修改的标记标记到了某个拆分之后的区间的后代结点上，就会对答案产生影响。所以对于区间询问，永久化的标记同样要作用于祖先结点。查询时只会查询到标记的某一个祖先结点而不会有多个，所以不影响答案。</p>
<p>同时，标记永久化具有较大的局限性，例如在信息不可直接叠加值时，便不具有可永久化的性质。比如：区间赋值；同时维护区间加和区间乘。</p>
<p>标记永久化也有它的优点，例如：不用像懒标记那样下传标记，常数较小；在可持久化线段树中，对区间修改标记永久化，空间复杂度可以少乘 $O(\log n)$ 。</p>
<h3 id="懒标记："><a href="#懒标记：" class="headerlink" title="懒标记："></a>懒标记：</h3><p>对于懒的解释：延迟下传。</p>
<p>在前文考虑维护住线段树定义时，是因为要保证其它点也满足线段树的定义。但是，</p>
<p><strong>修改操作和询问操作是紧密联系在一起的</strong>。试想，如果在后续的询问操作中，没有用到这里修改操作所涉及的点，那么是否还需要去把所有点都更新？</p>
<p>因此，秉持不用不管的原则，只有当询问操作递归经过这个区间时，才将这个区间上的标记信息下传更新子结点的信息。至于父结点信息，在修改操作递归到这个区间的过程中直接修改即可。</p>
<p>注意，懒标记的标记与标记永久化的标记不同，懒标记的标记是与线段树结点的信息结合起来的，是需要通过懒标记去修改结点上的信息的。而标记永久化的标记是与线段树结点的信息独立的。也就是标记永久化过程中的结点信息是不变的（始终为建树时的信息）而懒标记过程中的结点信息是会随着懒标记的下传而更新的（当前结点的懒标记下传后，懒标记信息清空，结点信息更新）</p>
<p>懒标记具有较强的扩展性，可以维护更多信息。但是需要维护的内容更多，代码更长。</p>
<p>懒标记中，懒标记下传函数一般写作 <code>push_down</code>，结点信息更新一般不写成函数，笔者写作 <code>eval</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(node &amp;t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    t.tag+=v;<span class="comment">//维护懒标记信息</span></span><br><span class="line">    t.sum+=v*(r-l+<span class="number">1</span>);<span class="comment">//维护结点信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">eval</span>(tr[t&lt;&lt;<span class="number">1</span>],l,mid,tr[t].tag);<span class="comment">//懒标记下传左儿子</span></span><br><span class="line">    <span class="built_in">eval</span>(tr[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],mid+<span class="number">1</span>,r,tr[t].tag);<span class="comment">//懒标记下传右儿子</span></span><br><span class="line">    tr[t].tag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒标记还有一个要注意的点，何时 <code>push_down</code>。</p>
<p>根据前文：“不用不管”，那么就是说只要递归到了这个区间，那就要 <code>push_down</code>。所以在递归前就 <code>push_down</code> 且任何修改和询问操作，只要递归到了这个点，就应该 <code>push_down</code>，一般应用中，<code>push_down</code> 的位置置于 <code>if</code> 后面，递归前面。</p>
<p>下面是完整的区间加、区间和的懒标记线段树代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> For(i,a,b) for(i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOR(i,a,b) for(i=a;i&gt;=b;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> sum,tag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sege</span>&#123;</span><br><span class="line">	node tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">		tr[t].sum=tr[t&lt;&lt;<span class="number">1</span>].sum+tr[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(node &amp;t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">		t.tag+=v;</span><br><span class="line">		t.sum+=v*(r-l+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push_down</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">eval</span>(tr[t&lt;&lt;<span class="number">1</span>],l,mid,tr[t].tag);</span><br><span class="line">		<span class="built_in">eval</span>(tr[t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>],mid+<span class="number">1</span>,r,tr[t].tag);</span><br><span class="line">		tr[t].tag=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">			tr[t].sum=a[l];</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">build</span>(t&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">		<span class="built_in">build</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">		<span class="built_in">push_up</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">			<span class="built_in">eval</span>(tr[t],l,r,v);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">push_down</span>(t,l,r);</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>,l,mid,x,y,v);</span><br><span class="line">		<span class="keyword">if</span>(y&gt;mid) <span class="built_in">update</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y,v);</span><br><span class="line">		<span class="built_in">push_up</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> t,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> tr[t].sum;</span><br><span class="line">		<span class="built_in">push_down</span>(t,l,r);</span><br><span class="line">		<span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(t&lt;&lt;<span class="number">1</span>,l,mid,x,y);</span><br><span class="line">		<span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,m,i,l,r,v,op;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">For</span>(i,<span class="number">1</span>,n) cin&gt;&gt;a[i];</span><br><span class="line">	tree.<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r&gt;&gt;v;</span><br><span class="line">			tree.<span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,v);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">			cout&lt;&lt;tree.<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="动态开点线段树："><a href="#动态开点线段树：" class="headerlink" title="动态开点线段树："></a>动态开点线段树：</h3><h3 id="值域线段树："><a href="#值域线段树：" class="headerlink" title="值域线段树："></a>值域线段树：</h3><h3 id="可持久化线段树："><a href="#可持久化线段树：" class="headerlink" title="可持久化线段树："></a>可持久化线段树：</h3><h3 id="线段树合并："><a href="#线段树合并：" class="headerlink" title="线段树合并："></a>线段树合并：</h3><h3 id="线段树分裂："><a href="#线段树分裂：" class="headerlink" title="线段树分裂："></a>线段树分裂：</h3><h3 id="线段树优化建图："><a href="#线段树优化建图：" class="headerlink" title="线段树优化建图："></a>线段树优化建图：</h3><h3 id="线段树分治："><a href="#线段树分治：" class="headerlink" title="线段树分治："></a>线段树分治：</h3><h3 id="zkw-线段树："><a href="#zkw-线段树：" class="headerlink" title="zkw 线段树："></a>zkw 线段树：</h3><h3 id="势能线段树："><a href="#势能线段树：" class="headerlink" title="势能线段树："></a>势能线段树：</h3><h3 id="李超线段树："><a href="#李超线段树：" class="headerlink" title="李超线段树："></a>李超线段树：</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>泰拉瑞亚-召唤师流程</title>
    <url>/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p><font face="楷体">召唤师，通过召唤武器召唤仆从，仆从跟随人物且具有无敌状态，仆从会自动攻击靠近人物的敌对生物，召唤视为增益，死亡后会消失。仆从造成召唤伤害。</font></p>
<p><font face="楷体">同时，召唤师可以使用鞭子作为人物攻击方式，攻击方式为近战，但伤害视为召唤伤害而不是近战伤害。召唤师仆从会集中攻击被鞭子攻击的敌怪</font></p>
<span id="more"></span>

<h2 id="肉前"><a href="#肉前" class="headerlink" title="肉前"></a>肉前</h2><h3 id="开荒期"><a href="#开荒期" class="headerlink" title="开荒期"></a>开荒期</h3><p><font face="楷体">召唤师前期能获得的武器较少。</font></p>
<p><font face="楷体">1.雀杖</font></p>
<p><font face="楷体">获得较为容易，但不排除脸黑到开不出来。</font></p>
<p><font face="楷体">但是其特殊的攻击方式导致其不易击中敌怪，而且不锁敌，使得其并不好用。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/1.png" class="" title="咕咕咕">

<p><font face="楷体">2.阿比盖尔之花</font></p>
<p><font face="楷体">获得较为容易，但是需要死亡后产生墓碑。</font></p>
<p><font face="楷体">输出稳定。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/2.png" class="" title="咕咕咕">

<p><font face="楷体">3.史莱姆法杖</font></p>
<p><font face="楷体">获取途径简单，但爆率极低且不可飞行。</font></p>
<p><font face="楷体">如果开局就通过击杀史莱姆获取那不失为一个好选择。但没有必要为了它而在前期刷史莱姆。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/3.png" class="" title="咕咕咕">

<p><font face="楷体">个人推荐：阿比盖尔之花 $&gt;$ 雀仗 $\geq$ 史莱姆法杖</font></p>
<p><font face="楷体">前期的第一个鞭子为动物学家 $10$ 金售卖的皮鞭。</font></p>
<p><font face="楷体">动物学家在怪物图鉴解锁 $\frac{1}{10}$ 后入住。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/4.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/5.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/18.png" class="" title="咕咕咕">

<p><font face="楷体">在前期探图的同时应尽可能多地解锁生物。</font></p>
<p><font face="楷体">先去沙漠获取仙人掌套，其套装效果可在前期和敌怪贴贴的时候避免不断的接触伤害。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/6.png" class="" title="咕咕咕">

<p><font face="楷体">解锁皮鞭后，前往地下雪原刷小雪怪皮毛，鹿角怪召唤物 $+$ 小雪怪的法杖 $+$ 小雪怪皮毛外套。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/7.png" class="" title="咕咕咕">

<p><font face="楷体">鹿角怪可掉落肉前唯一的哨兵武器-眼球激光塔（酒馆老板除外）但作用不大，自行选择。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/8.png" class="" title="咕咕咕">

<p><font face="楷体">阿比盖尔之花退役。</font></p>
<p><font face="楷体">此时可视情况选择挑战 史莱姆王-克苏鲁之眼-世界吞噬者（腐化）&#x2F;克苏鲁之脑（猩红）。</font></p>
<p><font face="楷体">史莱姆王 和 克苏鲁之眼 挑战顺序可视情况而定，无先后要求。</font></p>
<p><font face="楷体">建议在挑战 BOSS 前获得 赫尔墨斯靴（可在地下和洞穴地层中的宝箱里找到）以加强机动性，否则不好躲克苏鲁之眼的冲撞。或可用粘鞍（史莱姆王坐骑）躲避。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/9.png" class="" title="咕咕咕">

<p><font face="楷体">使用粘鞍更适合挑战世界吞噬者。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/10.png" class="" title="咕咕咕">

<p><font face="楷体">若对走位水平不自信，可以下丛林获取荆鞭。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/11.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/16.png" class="" title="咕咕咕">

<p><font face="楷体">荆鞭对敌怪有中毒减益，对人物有增加鞭速的增益。且伤害与攻击范围与皮鞭相比均有较大提升。</font></p>
<p><font face="楷体">在拥有荆鞭后，可挑战骷髅王。</font></p>
<p><font face="楷体">陨石对召唤师同样不必要，可跳过。</font></p>
<p><font face="楷体">或先获取黑曜石套，其在 世界吞噬者&#x2F;克苏鲁之脑 后即可通过熔岩熔炉合成。熔岩熔炉需要梦魇镐（腐化）&#x2F;死亡使者镐（猩红）挖掘。召唤杖亦可更新为小鬼法杖，狱石通过梦魇镐&#x2F;死亡使者镐挖掘。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/19.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/21.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/14.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/15.png" class="" title="咕咕咕">

<p><font face="楷体">使用粘鞍可较易躲避骷髅王旋转攻击。进入地牢后，通过击杀地牢内骷髅类敌怪掉落的骨头，和蛛网合成脊柱骨鞭。以及在地牢中获取可以增加一个仆从位的施法桌。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/12.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/17.png" class="" title="咕咕咕">

<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/20.png" class="" title="咕咕咕">

<p><font face="楷体">召唤师蜂王不必要，可以跳过。虽然蜂王掉落物可以合成另一套召唤师套装-蜜蜂套装，但是出了蜜蜂套装可以再额外多加 $1$ 个仆从位外，其它属性不如黑曜石套，可自行选择。</font></p>
<img src="/2024/01/06/%E6%B3%B0%E6%8B%89%E7%91%9E%E4%BA%9A-%E5%8F%AC%E5%94%A4%E5%B8%88%E6%B5%81%E7%A8%8B/13.png" class="" title="咕咕咕">

<p><font face="楷体">接下来便是肉前最后的 BOSS，肉山。</font></p>
]]></content>
      <tags>
        <tag>泰拉瑞亚</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何（一）</title>
    <url>/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p> 二维几何基础知识</p>
<span id="more"></span>

<h2 id="浮点数与精度问题"><a href="#浮点数与精度问题" class="headerlink" title="浮点数与精度问题"></a><font face="楷体">浮点数与精度问题</font></h2><h3 id="特殊值"><a href="#特殊值" class="headerlink" title="特殊值"></a><font face="楷体">特殊值</font></h3><ul>
<li><font face="楷体">+0.0 -0.0</font></li>
<li><font face="楷体">1.0&#x2F;0.0&#x3D;+inf，1.0&#x2F;-0.0&#x3D;-inf</font></li>
<li><font face="楷体">nan，非数字，例如：$\sqrt{-2}$</font><ul>
<li><font face="楷体">nan 除了 $\neq$ 时返回 <code>true</code> 外，其它比较运算符均返回 <code>false</code></font></li>
</ul>
</li>
</ul>
<p><font face="楷体">1.若问题能用整数解决则不用浮点数。</font></p>
<p><font face="楷体">2.除非时限紧张，否则使用 <code>long double</code>。</font></p>
<p><font face="楷体">3.减少数学库函数的调用。</font></p>
<p><font face="楷体">4.进行浮点数比较时，加入容限（误差）eps。</font></p>
<h2 id="点"><a href="#点" class="headerlink" title="点"></a><font face="楷体">点</font></h2><h3 id="using-Point-complex"><a href="#using-Point-complex" class="headerlink" title="using Point=complex&lt;double&gt;"></a><code>using Point=complex&lt;double&gt;</code></h3><ul>
<li><font face="楷体">横坐标（x）：.real()</font></li>
<li><font face="楷体">纵坐标（y）：.imag()</font></li>
</ul>
<p><font face="楷体">优点：自带各种运算</font></p>
<p><font face="楷体">缺点：慢</font></p>
<h3 id="using-Point-pair"><a href="#using-Point-pair" class="headerlink" title="using Point=pair&lt;double,double&gt;"></a><code>using Point=pair&lt;double,double&gt;</code></h3><ul>
<li><font face="楷体">横坐标（x）：first</font></li>
<li><font face="楷体">纵坐标（y）：second</font></li>
</ul>
<p><font face="楷体">优点：自带比较运算</font></p>
<p><font face="楷体">缺点：自由度不高</font></p>
<h3 id="struct-Point-double-x-y"><a href="#struct-Point-double-x-y" class="headerlink" title="struct Point {double x,y;}"></a><code>struct Point &#123;double x,y;&#125;</code></h3><ul>
<li><font face="楷体">横坐标（x）：x</font></li>
<li><font face="楷体">纵坐标（y）：y</font></li>
</ul>
<p><font face="楷体">优点：自由度高</font></p>
<p><font face="楷体">缺点：功能为零</font></p>
<h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a><font face="楷体">向量</font></h2><p><font face="楷体">表示上和点一致，因为坐标系中一个点对应一个向量。</font></p>
<h3 id="点积"><a href="#点积" class="headerlink" title="点积"></a><font face="楷体">点积</font></h3><p>$\vec{a}\cdot \vec b&#x3D;a_xb_x+a_yb_y$</p>
<p><font face="楷体">几何意义：$\vec a\cdot \vec b&#x3D;|\vec a|\times |\vec b|\times \cos\theta$</font></p>
<ul>
<li><font face="楷体">向量的长度：$|\vec a|&#x3D;\sqrt{\vec a\times \vec a}$</font></li>
<li><font face="楷体">向量的夹角：$\cos \theta&#x3D;\dfrac{\vec a\cdot \vec b}{|\vec a|\times |\vec b|}$</font></li>
<li><font face="楷体">向量的投影：$|\vec a|\times cos\theta&#x3D;\dfrac{\vec a\cdot \vec b}{|\vec b|}$</font></li>
<li><font face="楷体">向量垂直：$\vec a\cdot \vec b&#x3D;0$</font></li>
</ul>
<h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a><font face="楷体">叉积</font></h3><p>$\vec a\times \vec b&#x3D;(a_xb_y-a_yb_x)\hat k$</p>
<p><font face="楷体">几何意义：$\vec a\times \vec b&#x3D;|\vec a|\times |\vec b|\times \sin \theta \hat k$</font></p>
<ul>
<li><font face="楷体">平行四边形面积：$|\vec a\times \vec b|&#x3D;|\vec a|\times |\vec b|\times |\sin \theta|$</font></li>
<li><font face="楷体">向量平行：$\vec a\times \vec b&#x3D;\vec 0$</font></li>
<li><font face="楷体">to-left 测试</font></li>
</ul>
<h4 id="to-left-测试"><a href="#to-left-测试" class="headerlink" title="to-left 测试"></a><font face="楷体">to-left 测试</font></h4><p><font face="楷体">判断点 P 在有向直线 AB 左侧&#x2F;右侧上。</font></p>
<p>$\begin{cases}\overrightarrow {AB}\times \overrightarrow{AP}&gt;0&amp; P\ 在有向直线\ AB\ 左侧\newline \overrightarrow {AB}\times \overrightarrow{AP}&lt;0&amp;P\ 在有向直线\ AB\ 右侧\newline\overrightarrow {AB}\times \overrightarrow{AP}&#x3D;0&amp; P\ 在有向直线\ AB\ 上\end{cases}$</p>
<h3 id="向量逆时针旋转"><a href="#向量逆时针旋转" class="headerlink" title="向量逆时针旋转"></a><font face="楷体">向量逆时针旋转</font></h3><p><font face="楷体">$\vec a$ 逆时针旋转 $\theta$，$(a_x,a_y)\rightarrow(\cos\theta a_x-\sin\theta a_y,\sin\theta a_x+\cos\theta a_y)$</font></p>
<h2 id="线段"><a href="#线段" class="headerlink" title="线段"></a><font face="楷体">线段</font></h2><p><code>struct segement&#123;Point a,b;&#125;</code></p>
<p><font face="楷体">记录左右端点</font></p>
<h3 id="判断点是否在线段上"><a href="#判断点是否在线段上" class="headerlink" title="判断点是否在线段上"></a><font face="楷体">判断点是否在线段上</font></h3><ul>
<li><font face="楷体">点 P 在 AB 所在直线上：$\overrightarrow {PA}\times \overrightarrow{PB}&#x3D;\vec 0$</font></li>
<li><font face="楷体">点 P 在 AB 之间：</font><ul>
<li>$\overrightarrow{PA}\cdot \overrightarrow{PB}&lt; 0$</li>
<li>$\min(A_x,B_x)\leq P_x\leq\max(A_x,B_x)\ \land\ \min(A_y,B_y)\leq P_y\leq\max(A_y,B_y)$</li>
</ul>
</li>
</ul>
<h3 id="判断两条线段是否相交"><a href="#判断两条线段是否相交" class="headerlink" title="判断两条线段是否相交"></a><font face="楷体">判断两条线段是否相交</font></h3><ul>
<li><font face="楷体">点 A 和点 B 在直线 CD 的不同侧</font></li>
<li><font face="楷体">点 C 和点 D 在直线 AB 的不同侧</font></li>
<li><font face="楷体">三点共线、四点共线特判</font></li>
</ul>
<h2 id="直线"><a href="#直线" class="headerlink" title="直线"></a><font face="楷体">直线</font></h2><h3 id="斜截式"><a href="#斜截式" class="headerlink" title="斜截式"></a><font face="楷体">斜截式</font></h3><p>$y&#x3D;kx+b$</p>
<h3 id="截距式"><a href="#截距式" class="headerlink" title="截距式"></a><font face="楷体">截距式</font></h3><p>$\dfrac{x}{a}+\dfrac{y}{b}&#x3D;1$</p>
<h3 id="一般式"><a href="#一般式" class="headerlink" title="一般式"></a><font face="楷体">一般式</font></h3><p>$Ax+By+C&#x3D;0$</p>
<h3 id="点斜式"><a href="#点斜式" class="headerlink" title="点斜式"></a><font face="楷体">点斜式</font></h3><p>$y-y_1&#x3D;k(x-x_1)$</p>
<h3 id="两点式"><a href="#两点式" class="headerlink" title="两点式"></a><font face="楷体">两点式</font></h3><p>$\dfrac{x-x_1}{x_2-x_1}&#x3D;\dfrac{y-y_1}{y_2-y_1}$</p>
<h3 id="点向式"><a href="#点向式" class="headerlink" title="点向式"></a><font face="楷体">点向式</font></h3><p><font face="楷体">直线上一点 P + 方向向量 $\vec v$ 表示一条直线。</font></p>
<h3 id="求直线与点-A-的距离"><a href="#求直线与点-A-的距离" class="headerlink" title="求直线与点 A 的距离"></a><font face="楷体">求直线与点 A 的距离</font></h3><p>$d&#x3D;\dfrac{|\vec v\times \overrightarrow{PA}|}{|\vec v|}$</p>
<h3 id="求点-A-在直线上的投影点-B"><a href="#求点-A-在直线上的投影点-B" class="headerlink" title="求点 A 在直线上的投影点 B"></a><font face="楷体">求点 A 在直线上的投影点 B</font></h3><p>$\overrightarrow {OB}&#x3D;\overrightarrow{OP}+\overrightarrow{PB}&#x3D;\overrightarrow{OP}+\dfrac{|\overrightarrow{PB}|}{|\vec v|}\vec v&#x3D;\overrightarrow{OP}+\dfrac{\overrightarrow{PA}\cdot\vec v}{\vec v^2}\vec v$</p>
<h3 id="两直线交点"><a href="#两直线交点" class="headerlink" title="两直线交点"></a><font face="楷体">两直线交点</font></h3><p>$\overrightarrow {OQ}&#x3D;\overrightarrow{OP_1}+\dfrac{|\vec{v_2}\times \overrightarrow{P_2P_1}|}{|\vec{v_1}\times \vec{v_2}|}\vec{v_1}$</p>
<h2 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a><font face="楷体">多边形</font></h2><p><font face="楷体">由点集描述。</p>
<ul>
<li><font face="楷体">一般按逆时针顺序</font></li>
<li><font face="楷体">不一定满足凸性</font></li>
<li><font face="楷体">注意第一个点与最后一个点的处理</font></li>
</ul>
<h3 id="多边形的面积"><a href="#多边形的面积" class="headerlink" title="多边形的面积"></a><font face="楷体">多边形的面积</font></h3><p><font face="楷体">三角形的面积：$\dfrac{1}{2}|\vec a\times \vec b|$</font></p>
<p><font face="楷体">多边形的面积：分解为若干三角形的面积</font></p>
<p>$S&#x3D;\dfrac{1}{2}|\sum\limits_{i&#x3D;0}^{n-1}\overrightarrow{OP_i}\times \overrightarrow{OP_{(i+1)\bmod n}}|$</p>
<h3 id="判断点是否在多边形内"><a href="#判断点是否在多边形内" class="headerlink" title="判断点是否在多边形内"></a><font face="楷体">判断点是否在多边形内</font></h3><h4 id="光线投影法"><a href="#光线投影法" class="headerlink" title="光线投影法"></a><font face="楷体">光线投影法</font></h4><p><font face="楷体">从该点引出一条射线，如果这条射线与多边形有奇数个交点，则该点在多边形内部，否则该点在多边形外部。</font></p>
<h4 id="回转数法"><a href="#回转数法" class="headerlink" title="回转数法"></a><font face="楷体">回转数法</font></h4><p><font face="楷体">回转数：面内闭合曲线逆时针绕过该点的总次数。</font></p>
<p><font face="楷体">遵循非零规则：当回转次数为 0 时，点在曲线外部。</font></p>
<ul>
<li><p><font face="楷体">一种实现方法：计算相邻两边夹角（有方向）的和。</font></p>
<img src="/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class="" title="咕咕咕">

<img src="/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/2.png" class="" title="咕咕咕"></li>
<li><p><font face="楷体">另一种实现方法：从该点引出一条射线，每经过一条自上而下穿过该射线的边，贡献 -1；每经过一条自下而上穿过该射线的边，贡献 +1。</font></p>
<img src="/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/3.png" class="" title="咕咕咕">

<img src="/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/4.png" class="" title="咕咕咕"></li>
</ul>
<p><font face="楷体">边界情况</font></p>
<ul>
<li><font face="楷体">点在多边形上，对于每条边特判。</font></li>
<li><font face="楷体">引出射线交多边形于顶点，视作在在射线上侧（影响自下而上还是自上而下的判断）</font>。</li>
</ul>
<h3 id="判断点是否在凸多边形内"><a href="#判断点是否在凸多边形内" class="headerlink" title="判断点是否在凸多边形内"></a><font face="楷体">判断点是否在凸多边形内</font></h3><h4 id="n-次-to-left-测试"><a href="#n-次-to-left-测试" class="headerlink" title="n 次 to-left 测试"></a><font face="楷体">n 次 to-left 测试</font></h4><p>$O(n)$</p>
<h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a><font face="楷体">二分</font></h4><p>$O(\log n)$</p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>牛客小白月赛85</title>
    <url>/2024/01/06/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B85/</url>
    <content><![CDATA[<p>概述：</p>
<ul>
<li>阅读理解，题面普遍片场（讲故事）（为什么我当初出了一道阅读理解就被dis了，这场全是。</li>
<li>A-D 都是一种：我不会 $\neq$ 我不能过。</li>
<li>开场 50 分钟才想起来还有小白月赛，D 题思路秒了（假贪心）WA 了半小时。然后去拿了个外卖，回来意识到想假了，又想了一下过了。本来不打算写了，看到榜一 10 分钟不到秒了前三题，最后 14 分钟打算挣扎一下，结果 C 上来就 WA 了两发，直接下机。</li>
<li>总结：不训练导致的（自从南京回来快两个月了）！</li>
<li>碎碎念：如果这场我把题面变一下，测试数据不变，通过率绝对高好多。</li>
</ul>
<span id="more"></span>

<h2 id="A-ACCEPT"><a href="#A-ACCEPT" class="headerlink" title="A.ACCEPT"></a>A.ACCEPT</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给一个只含 <code>A</code> <code>C</code> <code>E</code> <code>P</code> <code>T</code> 的字符串，问重新排列后最多几个 <code>ACCEPT</code>。</p>
<h3 id="解："><a href="#解：" class="headerlink" title="解："></a>解：</h3><p>经典思路，统计五种字符的数量，按比例求最小值即可（1:2:1:1:1）</p>
<h2 id="B-咕呱蛙"><a href="#B-咕呱蛙" class="headerlink" title="B.咕呱蛙"></a>B.咕呱蛙</h2><h3 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h3><p>第 $i$ 层有 $i$ 个青蛙，问前 $i$ 层青蛙总数为偶数的第 $x$ 个 $i$ 是几。</p>
<h3 id="解：-1"><a href="#解：-1" class="headerlink" title="解："></a>解：</h3><p>实际就是求数列 $a_i&#x3D;\dfrac{i\times (i+1)}{2}$ 的第 $x$ 个偶数。</p>
<p>打表打出来发现就是 $4i-3,4i$ 是偶数。答案就是 $\lfloor\frac{n}{2}\rfloor\times 4+[n\bmod 2]\times 3$。</p>
<p>直接研究式子，或者考虑 $1…i$ 的奇偶性也可以。</p>
<h2 id="C-得分显示"><a href="#C-得分显示" class="headerlink" title="C.得分显示"></a>C.得分显示</h2><h3 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a>题目描述：</h3><p>$a_i&#x3D;\lfloor i\times x\rfloor$。求 $\max\lbrace x\rbrace$。 </p>
<h3 id="解：-2"><a href="#解：-2" class="headerlink" title="解："></a>解：</h3><p>$a_i&#x3D;\lfloor i\times x\rfloor\Rightarrow x\in [\lceil\frac{a_i}{i}\rceil,\lfloor\frac{a_i+1}{i}\rfloor)$</p>
<p>所以其实就是 $n$ 个区间求交，左端点求 $max$，右端点求 $min$ 即可，同时又因为题目保证有解且求 $max\lbrace x\rbrace$，所以答案就是 $\min\lbrace\lfloor\frac{a_i+1}{i}\rfloor\rbrace$。</p>
<p>但是这个题面就把题目变得迷惑起来（引导人考虑相邻两个数之间的增量）。</p>
<p>从另一个角度去二分也可以。</p>
<h2 id="D-阿里马马与四十大盗"><a href="#D-阿里马马与四十大盗" class="headerlink" title="D.阿里马马与四十大盗"></a>D.阿里马马与四十大盗</h2><h3 id="题目描述：-3"><a href="#题目描述：-3" class="headerlink" title="题目描述："></a>题目描述：</h3><p>在 $a_i&#x3D;0$ 的位置可以选择回满血，并花费恢复生命值的时间，或者直接走。</p>
<p>在 $a_i&gt;0$ 的位置会损失 $a_i$ 的生命，求从 $1$ 到 $n$ 的最小时间。</p>
<p>移动一格花费 $1$ 的时间，只能往相邻的格子移动。</p>
<h3 id="解：-3"><a href="#解：-3" class="headerlink" title="解："></a>解：</h3><p>题目大量冗余信息。</p>
<p>移动的时间没用，直接在答案上 $+n-1$ 即可。因为不能往回走，$a_i$ 不会消失，时间不会变少。</p>
<p>一个错误的贪心：能不回血就不回血。想假的原因是贪心的滞后性。</p>
<p>正确的贪心：花费的时间只和起止血量和经过的 $a_i$ 之和有关。所以枚举最后一次回血的位置，算 $a_i$ 的前缀和即可。</p>
<h2 id="E-烙饼"><a href="#E-烙饼" class="headerlink" title="E.烙饼"></a>E.烙饼</h2><h3 id="题目描述：-4"><a href="#题目描述：-4" class="headerlink" title="题目描述："></a>题目描述：</h3><p>$n$ 张饼，第 $i$ 张饼需要 $a_i$ 的制作时间，每张饼可以分为若干次安排在 $m$ 机器上制作。求做完所有饼的最短时间。要求所有机器工作总次数不超过 $2n$。</p>
<h3 id="解：-4"><a href="#解：-4" class="headerlink" title="解："></a>解：</h3><p>逃不过阅读理解去剥离题目的外衣。</p>
<p>一个容易的小结论：最短时间 $\geq$ $\max\lbrace a_i\rbrace$。</p>
<p>所以其实，就很迷惑行为了，有了这个结论，那么最后所有机器的工作总次数本身就是不会超过 $2n$ 的。即：这个工作次数没什么大的意义。</p>
<p>简单证明：</p>
<p>$x&#x3D;\max$，若当前 $now+a_i&gt;x$，那么 $a_i-(x-now)&lt;now$，所以 $a_i$ 这个饼花费的时间不会超过 $x$（在两台机器上时间不会有重合）且最多只会被划分成 $2$ 段。</p>
<p>假设答案为 $x$，那么又是一个经典的 trick：$x$ 满足单调性。直接对 $x$ 二分即可。check 的时候只需要从前往后满了就放到下一台机器就好了。</p>
<p>那么出题人给出了一个巧妙一点的偏思维的做法，我觉得供参考，学习价值不如二分。</p>
<p>首先，最短时间也是 $\geq$ $\lceil\frac{\sum a_i}{m}\rceil$ 的，因为假设“抛开事实不谈”，仅考虑总耗时，然后分配给 $m$ 台机器，那么答案就是均分的结果。</p>
<p>那么结果上文的结论，再分讨一下：</p>
<ul>
<li>如果 $\max\leq \lceil\frac{\sum a_i}{m}\rceil$，那么最终的 $x$ 就是 $\lceil\frac{\sum a_i}{m}\rceil$</li>
<li>反之就是 $\max$。</li>
</ul>
<h2 id="F-龙吸水"><a href="#F-龙吸水" class="headerlink" title="F.龙吸水"></a>F.龙吸水</h2><h3 id="题目描述：-5"><a href="#题目描述：-5" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给出 $n$ 天的水位，魔法师可以在任意天降低任意数值的水位。求最多可以有多少天水位在要求区间内。</p>
<h3 id="解：-5"><a href="#解：-5" class="headerlink" title="解："></a>解：</h3><p>先阅读理解。$n$ 天的水位不关心，只关心每一天的变化量，即：$a_i-a_{i-1}$（那我觉得这里出题人不说变化量纯纯是给题目加阅读理解）。</p>
<p>同时变化后的水位相比 $a_i$ 不会增加。</p>
<p>而第 $i$ 天之后的结果只跟第 $i$ 天的水位有关，这就非常适合 dp 了。</p>
<h4 id="easy-version："><a href="#easy-version：" class="headerlink" title="easy version："></a>easy version：</h4><p>$a_i\leq 5\times 10^3$，直接设 $dp[i][j]$ 表示仅考虑前 $i$ 个且第 $i$ 天水位为 $j$ 的答案。</p>
<p>转移时，因为可以用魔法，所以</p>
<p>$dp[i][j]$</p>
<p>可以由 </p>
<p>$dp[i-1][k]+[j\geq l \land j\leq r](k\in [j-(a[i]-a[i-1]),+∞])$</p>
<p>转移而来。</p>
<p>维护一个 $dp[i]$ 的后缀 $\max$ 即可。</p>
<p>时间复杂度：$O(na)$</p>
<p>空间复杂度：$O(na)$</p>
<h4 id="hard-version"><a href="#hard-version" class="headerlink" title="hard version:"></a>hard version:</h4><p>hard version 主要是 $a_i$ 变大了，最直接的使用动态开点线段树，只需要支持：区间加（$[l,r]+1$），后缀 $\max$ 即可。</p>
<p>时间复杂度：$O(n\log a_i)$</p>
<p>空间复杂度：$O(n\log a_i\log n)$</p>
<p>但是貌似卡空间。</p>
<p>那么把要用的值离线下来后离散化再用一般线段树维护即可。</p>
<p>鉴定为锻炼考验码力。</p>
]]></content>
      <tags>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何（七）</title>
    <url>/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<p>扫描线</p>
<span id="more"></span>

<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a><font face="楷体">引入</font></h2><h3 id="矩形面积并"><a href="#矩形面积并" class="headerlink" title="矩形面积并"></a><font face="楷体">矩形面积并</font></h3><p><font face="楷体">给出 $n$ 个边平行于坐标轴的矩形，求它们的面积并。</font></p>
<h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a><font face="楷体">扫描线</font></h2><p><font face="楷体">将问题拆解成时间序列关键点，可以想象一条线在平面上扫过，在一些特定的位置这条线上对应的状态会发生变化。</font></p>
<p><font face="楷体">两要素：</font></p>
<ul>
<li><font face="楷体">时间序列：状态发生变化的关键点。</font></li>
<li><font face="楷体">维护当前时间状态的数据结构。</font></li>
</ul>
<h2 id="引入的解"><a href="#引入的解" class="headerlink" title="引入的解"></a><font face="楷体">引入的解</font></h2><p><font face="楷体">两要素：</font></p>
<ul>
<li><font face="楷体">时间序列：每个矩形的上下边</font></li>
<li><font face="楷体">数据结构：线段树（区间修改，查询覆盖的区间长度）</font></li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a><font face="楷体">应用</font></h2><h3 id="判断-n-条线段中是否存在有交点的线段"><a href="#判断-n-条线段中是否存在有交点的线段" class="headerlink" title="判断 $n$ 条线段中是否存在有交点的线段"></a><font face="楷体">判断 $n$ 条线段中是否存在有交点的线段</font></h3><p><font face="楷体">朴素做法：$O(n^2)$。</font></p>
<p><font face="楷体">尝试扫描线，一条垂直于 $x$ 轴的线从左向右扫。</font></p>
<p><font face="楷体">关键点：线段的端点（左端点加入，右端点删除）</font></p>
<p><font face="楷体">考虑对于每一个时间点的竖线，把所有与之相交的线段，按纵坐标（y）升序排序。那么两条有交点的线段的先后顺序会在某一时刻发生变化。</font></p>
<p><font face="楷体">具体而言，其先后顺序发生变化的情况有两种：</font></p>
<ul>
<li><font face="楷体">新加入一条线段，与这条线段相邻的两条线段先后顺序发生变化。</font></li>
<li><font face="楷体">删除一条线段，原本被这条线段隔开的两条线段先后顺序发生变化。</font></li>
</ul>
<p><font face="楷体">使用 set 维护。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$。</font></p>
<p><font face="楷体">细节：</font></p>
<ul>
<li><font face="楷体">一个关键点上有多个操作的情况（多条线段共端点）</font></li>
<li><font face="楷体">线段与扫描线平行的情况（平行 y 轴）</font></li>
</ul>
<h3 id="面积并问题"><a href="#面积并问题" class="headerlink" title="面积并问题"></a><font face="楷体">面积并问题</font></h3><p><font face="楷体">对于部分问题，扫描线并不是最优解。</font></p>
<h4 id="三角形面积并"><a href="#三角形面积并" class="headerlink" title="三角形面积并"></a><font face="楷体">三角形面积并</font></h4><h5 id="法一：扫描线"><a href="#法一：扫描线" class="headerlink" title="法一：扫描线"></a><font face="楷体">法一：扫描线</font></h5><ul>
<li><font face="楷体">关键点：三角形顶点，交点。</font></li>
<li><font face="楷体">关键点之间的面积可用梯形面积公式计算。</font></li>
</ul>
<p><font face="楷体">时间复杂度：$O(n^3)$</font></p>
<h5 id="法二：轮廓法"><a href="#法二：轮廓法" class="headerlink" title="法二：轮廓法"></a><font face="楷体">法二：轮廓法</font></h5><p><font face="楷体">三角形的并本质上是多边形，如果能找到这个多边形的轮廓，可用直接使用求多边形面积的算法求得面积并。</font></p>
<p><font face="楷体">对于每一条边，求出它与其它所有三角形的交点，找到没有包含在任何三角形内部的部分。</font></p>
<p><font face="楷体">时间复杂度：$O(n^2)$</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（三）</title>
    <url>/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>凸包基础</p>
<span id="more"></span>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a><font face="楷体">定义</font></h2><h3 id="凸多边形"><a href="#凸多边形" class="headerlink" title="凸多边形"></a><font face="楷体">凸多边形</font></h3><p><font face="楷体">所有内角大小都在 $[0,\pi]$ 范围内的简单多边形。</font></p>
<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a><font face="楷体">凸包</font></h3><p><font face="楷体">在平面上能包含所有给定点的最小凸多边形。</font></p>
<p><font face="楷体">可以理解为用一个橡皮筋包含住所有给定点的形态。</font></p>
<p><font face="楷体">性质：凸包用最小的周长围住了所有点。</font></p>
<h3 id="极点"><a href="#极点" class="headerlink" title="极点"></a><font face="楷体">极点</font></h3><p><font face="楷体">凸包的顶点</font></p>
<p><font face="楷体">性质：若点 P 是点集 S 的一个极点，那么存在一条经过点 P 的直线 l，使得点集 S 中除了 P 的所有点都在 l 的同一侧。</font></p>
<h3 id="极边"><a href="#极边" class="headerlink" title="极边"></a><font face="楷体">极边</font></h3><p><font face="楷体">凸包的边</font></p>
<p><font face="楷体">性质：点集中除了极边上的点外都在极边所在直线的同一侧。</font></p>
<h2 id="求凸包"><a href="#求凸包" class="headerlink" title="求凸包"></a><font face="楷体">求凸包</font></h2><h3 id="极点法"><a href="#极点法" class="headerlink" title="极点法"></a><font face="楷体">极点法</font></h3><p><font face="楷体">枚举每个点，判断每个点是否是极点。</font></p>
<p><font face="楷体">依据：将凸包以凸包内一点为顶点进行三角剖分，非极点一定落在某个三角形内部，枚举另外三个点组成三角形，若点落在了某个三角形内部，则它不是极点。</font></p>
<p><font face="楷体">时间复杂度：$O(n^4)$。</font></p>
<h3 id="极边法"><a href="#极边法" class="headerlink" title="极边法"></a><font face="楷体">极边法</font></h3><p><font face="楷体">枚举两点组成的边，判断它是否是极边。</font></p>
<p><font face="楷体">依据：其它点在极边所在直线的同一侧。</font></p>
<p><font face="楷体">时间复杂度：$O(n^3)$。</font></p>
<h3 id="增量法"><a href="#增量法" class="headerlink" title="增量法"></a><font face="楷体">增量法</font></h3><p><font face="楷体">每次用一个点去更新凸包。</font></p>
<ul>
<li><font face="楷体">若点在凸包内，舍弃</font></li>
<li><font face="楷体">若点在凸包外，找凸包的切线</font></li>
</ul>
<p><font face="楷体">可推广至三维凸包、动态凸包。</font></p>
<p><font face="楷体">判断点在凸包内：$n$ 次 to-left 测试。$O(n)$。</font></p>
<p><font face="楷体">找凸包的切线：前驱和后继都在射线的同一侧。暴力 $O(n)$。</font></p>
<p><font face="楷体">时间复杂度：$O(n^2)$。</font></p>
<p><font face="楷体">判断点在凸包内和找凸包的切线均存在 $O(n\log n)$ 做法。</font></p>
<h3 id="Gift-wrapping"><a href="#Gift-wrapping" class="headerlink" title="Gift wrapping"></a><font face="楷体">Gift wrapping</font></h3><p><font face="楷体">从一条极边出发遍历其它点找到下一条极边。</font></p>
<p><font face="楷体">时间复杂度：$O(nh)$，最坏 $O(n^2)$，$h$ 表示凸包的极点数。</font></p>
<p><font face="楷体">起点的确定：</font></p>
<p><font face="楷体">点集中最左&#x2F;右&#x2F;上&#x2F;下的点一定是凸包的极点（若最左&#x2F;右&#x2F;上&#x2F;下的点不唯一，则是极边上的点，此时取另一个方向上坐标最大&#x2F;小的点）。</font></p>
<h3 id="Graham-scan"><a href="#Graham-scan" class="headerlink" title="Graham scan"></a><font face="楷体">Graham scan</font></h3><p><font face="楷体">基于极角排序的求凸包算法。</font></p>
<p><font face="楷体">算法流程：</font></p>
<ul>
<li><font face="楷体">以最左下角的点为极点，进行极角排序。</font></li>
<li><font face="楷体">将极点与极点的下一个点入栈。</font></li>
<li><font face="楷体">对于要入栈的下一个点，如果从栈顶连向该点需要顺时针旋转，则弹出栈顶。</font></li>
<li><font face="楷体">重复 3，直到从栈顶连向该点需要逆时针旋转。</font></li>
<li><font face="楷体">将下一个点入栈，回到 3。</font></li>
</ul>
<p><font face="楷体">时间复杂度：$O(n\log n)$。瓶颈为极角排序。</font></p>
<h3 id="Andrew’s-algorithm"><a href="#Andrew’s-algorithm" class="headerlink" title="Andrew’s algorithm"></a><font face="楷体">Andrew’s algorithm</font></h3><p><font face="楷体">基于横坐标（x）排序的求凸包算法。</font></p>
<p><font face="楷体">以最左最右两点为界，凸包可以分为上凸包和下凸包两部分。</font></p>
<p><font face="楷体">算法流程：</font></p>
<ul>
<li><font face="楷体">对点集以横坐标（x）为第一关键字，纵坐标（y）为第二关键字排序。</font></li>
<li><font face="楷体">正序遍历每个点，用栈维护下凸包。</font></li>
<li><font face="楷体">倒序遍历每个点，用栈维护上凸包。</font></li>
</ul>
<p><font face="楷体">栈的维护方式与 Graham scan 一致。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$。瓶颈为排序。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（九）</title>
    <url>/2023/12/07/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    <content><![CDATA[<p>杂项</p>
<span id="more"></span>

<h2 id="皮克定理"><a href="#皮克定理" class="headerlink" title="皮克定理"></a><font face="楷体">皮克定理</font></h2><p><font face="楷体">顶点坐标均是整点的简单多边形，其面积 $A$ 和内部格点数目 $i$ 和边上格点数目 $b$ 的关系为 $A&#x3D;i+\frac{b}{2}-1$。</font></p>
<h2 id="平面最近点对"><a href="#平面最近点对" class="headerlink" title="平面最近点对"></a><font face="楷体">平面最近点对</font></h2><p><font face="楷体">问题描述：给出平面上 $n$ 个点，求距离最近的点对。</font></p>
<p><font face="楷体">引理：如果平面上 $n$ 个点的最近点对距离为 $d$，那么将这 $n$ 个点放进 $d\times d$ 的网格中，每个网格中的点数不超过 4。</font></p>
<h3 id="法一：经典分治算法"><a href="#法一：经典分治算法" class="headerlink" title="法一：经典分治算法"></a><font face="楷体">法一：经典分治算法</font></h3><ul>
<li><font face="楷体">分：画一条垂直的线将点集均分为左右两个子集。</font></li>
<li><font face="楷体">治：分别求出左右两个子集的最近点对。</font></li>
<li><font face="楷体">合：求出跨越分界线的最近点对，与子问题的最近点对比较取最优。</font></li>
</ul>
<p><font face="楷体">令两个子问题中的最近点对距离为 $d$。</font></p>
<p><font face="楷体">找出所有离分界线距离 $d$ 以内的所有点，并按纵坐标（y） 坐标排序。</font></p>
<p><font face="楷体">对每个范围内的点，遍历与其纵坐标（y）之差 d 以内的所有点，更新最近点对。</font></p>
<p><font face="楷体">根据引理，此范围内的点能更新的最近点对是常数级别的。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$</font></p>
<h3 id="法二：扫描线"><a href="#法二：扫描线" class="headerlink" title="法二：扫描线"></a><font face="楷体">法二：扫描线</font></h3><p><font face="楷体">对所有点按横坐标（x）排序，从左到右扫描，记录当前的最近点对距离 $d$。</font></p>
<p><font face="楷体">对于一个新的点，遍历之前的点中所有与其横坐标（x）之差小于 d 且纵坐标（y）之差小于 d 的所有点，更新最近点对。</font></p>
<p><font face="楷体">用一个 multiset 存放与新点横坐标（x）之差小于 d 的点，内部按纵坐标（y）排序。</font></p>
<p><font face="楷体">使用队列按 x 坐标顺序入队各点，当队首与新点横坐标（x）之差大于 d 时出队，并且将其从 multiset 中移除。</font></p>
<p><font face="楷体">在 multiset 中二分找到纵坐标（y）之差小于 d 的分界点。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$</font></p>
<h3 id="法三：随机化算法"><a href="#法三：随机化算法" class="headerlink" title="法三：随机化算法"></a><font face="楷体">法三：随机化算法</font></h3><p><font face="楷体">令前 $i-1$ 个点的最近点对距离为 $d$，作 $d\times d$ 的网格图，使用哈希表记录每个格子内有哪些点。</font></p>
<p><font face="楷体">对第 $i$ 个点，找到其所在的格子，并找到以此格子为中心的九宫格内的所有点，更新最近点对。</font></p>
<p><font face="楷体">如果最近点对被更新，以新的最近点对距离 $d’$ 重构网格图。</font></p>
<p><font face="楷体">若点的顺序为随机打乱的。那么期望时间复杂度为 $O(n)$。</font></p>
<h2 id="最小圆覆盖"><a href="#最小圆覆盖" class="headerlink" title="最小圆覆盖"></a><font face="楷体">最小圆覆盖</font></h2><p><font face="楷体">问题描述：给定平面上 $n$ 个点，求一个半径最小的圆，能覆盖所有的点。</font></p>
<p><font face="楷体">引理：过三个不共线的点可以唯一确定一个圆。</font></p>
<p><font face="楷体">定理：如果点 $p$ 不在点集 S 的最小圆覆盖圆内，那么它一定在 $\lbrace p\rbrace\bigcup S$ 的最小覆盖圆上，即最小覆盖圆一定经过点 $p$。</font></p>
<h3 id="算法："><a href="#算法：" class="headerlink" title="算法："></a><font face="楷体">算法：</font></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最小圆覆盖（点集 p，边界点集 R）</span><br><span class="line">	如果 P 为空 或 |R|==3</span><br><span class="line">		返回 R 确定的圆</span><br><span class="line">	p = P 中随机选一点</span><br><span class="line">	D = 最小圆覆盖（P-&#123;p&#125;，R）</span><br><span class="line">	如果 p 不在 D 中</span><br><span class="line">		D = 最小圆覆盖（P-&#123;p&#125;，R ∪ &#123;p&#125;）</span><br><span class="line">	返回 D</span><br></pre></td></tr></table></figure>

<p><font face="楷体">时间复杂度：$O(n)$</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（二）</title>
    <url>/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>极角序</p>
<span id="more"></span>

<h2 id="极坐标系"><a href="#极坐标系" class="headerlink" title="极坐标系"></a><font face="楷体">极坐标系</font></h2><ul>
<li><font face="楷体">极点：O</font></li>
<li><font face="楷体">极轴：$\overrightarrow{OL}$</font></li>
<li><font face="楷体">极径：$r$</font></li>
<li><font face="楷体">极角：$\varphi$</font></li>
<li><font face="楷体">极坐标：$(r,\varphi)$</font></li>
</ul>
<p>$\tan\varphi&#x3D;\dfrac{y}{x}$</p>
<h2 id="极角排序"><a href="#极角排序" class="headerlink" title="极角排序"></a><font face="楷体">极角排序</font></h2><ul>
<li><font face="楷体">半平面内的极角排序</font></li>
</ul>
<h3 id="排序范围小于-180-circ"><a href="#排序范围小于-180-circ" class="headerlink" title="排序范围小于 $180^\circ$"></a><font face="楷体">排序范围小于 $180^\circ$</font></h3><p><font face="楷体">to-left 测试，即叉积比较。</font></p>
<h3 id="排序范围小于-360-circ"><a href="#排序范围小于-360-circ" class="headerlink" title="排序范围小于 $360^\circ$"></a><font face="楷体">排序范围小于 $360^\circ$</font></h3><h4 id="有精度损失"><a href="#有精度损失" class="headerlink" title="有精度损失 "></a><font face="楷体">有精度损失 </font></h4><p><font face="楷体">使用反三角函数 $\text{atan2}(y,x)$（精度更高） 函数计算极角，然后排序。</font></p>
<h4 id="无精度损失"><a href="#无精度损失" class="headerlink" title="无精度损失"></a><font face="楷体">无精度损失</font></h4><p><font face="楷体">先划分上下平面，同一部分内进行叉积比较。</font></p>
<p><font face="楷体">下半平面$&lt;$原点$&lt;$ x 正半轴$&lt;$上半平面$&lt;$ x 负半轴</font></p>
<hr>
<p><font face="楷体">时间复杂度：$O(n\log n)$。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（五）</title>
    <url>/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p><font face="楷体">半平面交</font></p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font face="楷体">概念</font></h2><p><font face="楷体">半平面：有向直线左侧的区域。</font></p>
<p><font face="楷体">半平面交：多个半平面的交集。</font></p>
<p><font face="楷体">半平面交涉及直线均使用点向式表示。</font></p>
<p><font face="楷体">性质：半平面交一定是凸集。</font></p>
<p><font face="楷体">特别地，可以加入一个相当大的边界，将交集无穷大的情况转化为有边界，这样交集可以用一个凸多边形表示。</font></p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a><font face="楷体">做法</font></h2><h3 id="法一：朴素算法"><a href="#法一：朴素算法" class="headerlink" title="法一：朴素算法"></a><font face="楷体">法一：朴素算法</font></h3><p><font face="楷体">求出各直线的交点，判断各交点是否在所有平面内。</font></p>
<p><font face="楷体">对满足条件的各点求凸包。</font></p>
<p><font face="楷体">时间复杂度：$O(n^3)$。</font></p>
<h3 id="法二：增量法；"><a href="#法二：增量法；" class="headerlink" title="法二：增量法；"></a><font face="楷体">法二：增量法；</font></h3><p><font face="楷体">每次用直线去切割当前的凸多边形。</font></p>
<p><font face="楷体">时间复杂度：$O(n^2)$。</font></p>
<h3 id="法三：排序增量法："><a href="#法三：排序增量法：" class="headerlink" title="法三：排序增量法："></a><font face="楷体">法三：排序增量法：</font></h3><p><font face="楷体">求凸包算法中，对点进行排序可以有效降低复杂度。</font></p>
<p><font face="楷体">利用凸多边形各边方向向量的有序性，同样可以对各直线进行排序后求半平面交。</font></p>
<p><font face="楷体">对于方向向量同向的直线，只需要考虑最左的一个。</font></p>
<h4 id="维护过程"><a href="#维护过程" class="headerlink" title="维护过程"></a><font face="楷体">维护过程</font></h4><p><font face="楷体">用双端队列维护当前的半平面交：</font></p>
<p><font face="楷体">当加入一个新的半平时，可能有以下几种情况。</font></p>
<ul>
<li><font face="楷体">队尾的一些半平面变成冗余的，从队尾弹出。</font></li>
<li><font face="楷体">队首的一些半平面变成冗余的，从队首弹出。</font></li>
<li><font face="楷体">半平面交变成空集。</font></li>
</ul>
<p><font face="楷体">时间复杂度：$O(n\log n)$。瓶颈在于排序。</font></p>
<h4 id="判断冗余"><a href="#判断冗余" class="headerlink" title="判断冗余"></a><font face="楷体">判断冗余</font></h4><p><font face="楷体">队尾&#x2F;首两条直线的交点在新加入的直线右侧。</font></p>
<h4 id="外边界"><a href="#外边界" class="headerlink" title="外边界"></a><font face="楷体">外边界</font></h4><p><font face="楷体">在加入外边界的前提下，半平面交中相邻各边逆时针旋转不超过 $180^\circ$。</font></p>
<p><font face="楷体">当无解的情况出现时，新加入的直线与队首差。一定大于等于 $180^\circ$，并且会把队中除队首外的直线全部弹出。</font></p>
<p><font face="楷体">因此，每加入一条新直线，弹出冗余半平面后与队尾比较，如果逆时针旋转大于等于  $180^\circ$，则交集为空。</font></p>
<p><font face="楷体">此时，外边界的加入是必要的。</font></p>
<h4 id="先处理队尾，再处理队首"><a href="#先处理队尾，再处理队首" class="headerlink" title="先处理队尾，再处理队首"></a><font face="楷体">先处理队尾，再处理队首</font></h4><p><font face="楷体">当出现一个可以把队列里的点全部弹出去的向量（即队列里的所有点都在该向量的右侧），则我们必须先处理队尾，再处理队首。</font></p>
<p><font face="楷体">原因如下：</font></p>
<img src="/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%94%EF%BC%89/1.jpg" class="" title="咕咕咕">

<p><font face="楷体">一般情况下，我们在队列里（队列顺序为 $\lbrace\vec u,\vec v\rbrace$）后面加一条边（向量 $\vec w$）,会产生一个交点 $N$，缩小 $\vec v$ 后面的范围。</font></p>
<img src="/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%94%EF%BC%89/2.jpg" class="" title="咕咕咕">

<p><font face="楷体">但是毕竟每次操作都是1一般的，因此可能会有把 $M$ 点 $\lceil$挤出去$\rfloor$  的情况。</font></p>
<img src="/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E4%BA%94%EF%BC%89/3.jpg" class="" title="咕咕咕">

<p><font face="楷体">如果此时出现了 $\vec a$，使得 $M$ 在 $\vec a$ 的右侧，那么 $M$ 就要出队了。此时如果先处理队首，显然是扩大了范围。实际上 $M$ 点是由 $\vec u$ 和 $\vec v$ 共同构成的，因此需要考虑影响到现有进程的是 $\vec u$ 还是 $\vec v$。而因为我们在极角排序后，向量是逆时针顺序，所以 $\vec v$ 的影响更大一些。</font></p>
<p><font face="楷体">就如上图，如果 $M$ 确认在 $\vec a$ 的右侧，那么此时 $\vec v$ 的影响一定不会队半平面交的答案作出任何的贡献。</font></p>
<p><font face="楷体">而我们排除队首的原因是 <strong>当前直线的限制比队首大</strong>，这个条件的前提是队列里有不止两个直线，不然就会出现上面的情况。</font></p>
<p><font face="楷体">所以一定要先排除队尾在排除队首。</font></p>
<h4 id="交点在新加入直线上"><a href="#交点在新加入直线上" class="headerlink" title="交点在新加入直线上"></a><font face="楷体">交点在新加入直线上</font></h4><p><font face="楷体">队尾&#x2F;首两条直线的交点在新加入的直线上时，一般不认为这时的队尾&#x2F;首是冗余的，这样便可区分出交集面积为 0 与交集为空。</font></p>
<p><font face="楷体">特殊情况：多条直线交于一点。</font></p>
<h3 id="法四：分治法"><a href="#法四：分治法" class="headerlink" title="法四：分治法"></a><font face="楷体">法四：分治法</font></h3><p><font face="楷体">时间复杂度：$O(n\log n)$。</font></p>
<p><font face="楷体">$[l,r]$ 直线的半平面交是$[l,mid]$ 半平面交和 $[mid+1,r]$ 半平面交的交集。</font></p>
<p><font face="楷体">核心在于实现 $O(n)$ 求两个凸多边形的交。</font></p>
<h4 id="实现一："><a href="#实现一：" class="headerlink" title="实现一："></a><font face="楷体">实现一：</font></h4><p><font face="楷体">使用法三求两个凸多边形半平面交得到凸多边形的交。</font></p>
<p><font face="楷体">因为半平面交求出的交的边是有序的，所以合并 $[l,mid]$ 和 $[mid+1,r]$ 时，两个凸多边形都是有序的，那么使用法三维护的时间复杂度瓶颈即为维护双端队列的复杂度。为 $O(n)$。</font></p>
<h4 id="实现二："><a href="#实现二：" class="headerlink" title="实现二："></a><font face="楷体">实现二：</font></h4><p><font face="楷体">对两个凸多边形的顶点进行扫描线，对两相邻竖线之间的梯形求交。单次 $O(1)$。共 $O(n)$ 条竖线。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（八）</title>
    <url>/2023/12/07/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<p>圆</p>
<span id="more"></span>

<h2 id="圆基础"><a href="#圆基础" class="headerlink" title="圆基础"></a><font face="楷体">圆基础</font></h2><ul>
<li><font face="楷体">圆的表示：圆心、半径</font></li>
<li><font face="楷体">圆的周长：$C&#x3D;2\pi r$</font></li>
<li><font face="楷体">圆的面积：$S&#x3D;\pi r^2$</font></li>
</ul>
<h2 id="关系问题"><a href="#关系问题" class="headerlink" title="关系问题"></a><font face="楷体">关系问题</font></h2><h3 id="点与圆的关系"><a href="#点与圆的关系" class="headerlink" title="点与圆的关系"></a><font face="楷体">点与圆的关系</font></h3><ul>
<li><font face="楷体">点在圆外</font></li>
<li><font face="楷体">点在圆上</font></li>
<li><font face="楷体">点在圆内</font></li>
</ul>
<p><font face="楷体">判定方法：点到圆心距离（平方）与圆的半径（平方）比较。</font></p>
<p><font face="楷体">无精度误差。</font></p>
<h3 id="直线与圆的关系"><a href="#直线与圆的关系" class="headerlink" title="直线与圆的关系"></a><font face="楷体">直线与圆的关系</font></h3><ul>
<li><font face="楷体">相离</font></li>
<li><font face="楷体">相切</font></li>
<li><font face="楷体">相交</font></li>
</ul>
<p><font face="楷体">判定方法：圆心到直线距离与圆的半径比较</font></p>
<p><font face="楷体">可以做到无精度误差。</font></p>
<h3 id="圆与圆的关系"><a href="#圆与圆的关系" class="headerlink" title="圆与圆的关系"></a><font face="楷体">圆与圆的关系</font></h3><p><font face="楷体">令两圆半径分别为 $r_1$ 和 $r_2$，两圆圆心的距离为 $d$。</font></p>
<ul>
<li><font face="楷体">相同：$r_1&#x3D;r_2$ 且 $d&#x3D;0$</font></li>
<li><font face="楷体">相离：$d&gt;r_1+r_2$</font></li>
<li><font face="楷体">外切：$d&#x3D;r_1+r_2$</font></li>
<li><font face="楷体">相交：$|r_1-r_2|&lt;d&lt;r_1+r_2$</font></li>
<li><font face="楷体">内切：$d&#x3D;|r_1-r_2|$</font></li>
<li><font face="楷体">内含：$d&lt;|r_1-r_2|$</font></li>
</ul>
<h2 id="交集问题"><a href="#交集问题" class="headerlink" title="交集问题"></a><font face="楷体">交集问题</font></h2><h3 id="直线与圆的交点"><a href="#直线与圆的交点" class="headerlink" title="直线与圆的交点"></a><font face="楷体">直线与圆的交点</font></h3><p><font face="楷体">前提：直线与圆不相离</font></p>
<p><font face="楷体">直线：$\lbrace P,\vec v\rbrace$</font></p>
<p><font face="楷体">圆：$\lbrace C,r\rbrace$</font></p>
<p><font face="楷体">设圆心到直线距离为 $d$，投影为 $C’$，则：</font></p>
<p><font face="楷体">交点：$\overrightarrow{OC’}±\dfrac{\sqrt{r^2-d^2}}{|\vec v|}\vec v$。</font></p>
<h3 id="圆与圆交点"><a href="#圆与圆交点" class="headerlink" title="圆与圆交点"></a><font face="楷体">圆与圆交点</font></h3><p><font face="楷体">前提：两圆不相同、不相离、不内含</font></p>
<p><font face="楷体">两圆圆心连线与一圆心到交点连线夹角 $\alpha$。</font></p>
<p><font face="楷体">根据余弦定理：$\cos\alpha&#x3D;\dfrac{r_1^2+d^2-r_2^2}{2r_1d},\sin\alpha &#x3D;\sqrt{1-\cos^2\alpha}$。</font></p>
<p><font face="楷体">将两圆心连线对应向量进行伸缩旋转。</font></p>
<h3 id="圆与圆面积交"><a href="#圆与圆面积交" class="headerlink" title="圆与圆面积交"></a><font face="楷体">圆与圆面积交</font></h3><p><font face="楷体">两个弓形（扇形减去三角形）面积和。</font></p>
<p><font face="楷体">扇形面积：$\pi r^2\times\dfrac{2\alpha}{2\pi}&#x3D;r^2\alpha$。</font></p>
<p><font face="楷体">三角形面积：$\dfrac12\times 2r\sin\alpha\times r\cos\alpha&#x3D;r^2\sin\alpha\cos\alpha$</font></p>
<p><font face="楷体">弓形面积：$r^2(\alpha-\sin\alpha\cos\alpha)$</font></p>
<h3 id="圆与多边形面积交"><a href="#圆与多边形面积交" class="headerlink" title="圆与多边形面积交"></a><font face="楷体">圆与多边形面积交</font></h3><p><font face="楷体">从圆心将多边形剖分成若干三角形，求三角形与原的面积交。</font></p>
<h3 id="多个圆的面积并"><a href="#多个圆的面积并" class="headerlink" title="多个圆的面积并"></a><font face="楷体">多个圆的面积并</font></h3><p><font face="楷体">对于极角在 $\theta_l$ 到 $\theta_r$ 之间的一段圆弧。</font></p>
<p>$2S&#x3D;x_0r(\sin\theta_r-\sin\theta_l)-y_0r(\cos\theta_r-\cos\theta_l)+r^2(\theta_r-\theta_l)$。</p>
<p><font face="楷体">时间复杂度：$O(n^2\log n)$。</font></p>
<h2 id="切线问题"><a href="#切线问题" class="headerlink" title="切线问题"></a><font face="楷体">切线问题</font></h2><h3 id="过圆外一点圆的切线"><a href="#过圆外一点圆的切线" class="headerlink" title="过圆外一点圆的切线"></a><font face="楷体">过圆外一点圆的切线</font></h3><ul>
<li>$\cos\alpha&#x3D;\dfrac{r}{d}$</li>
<li><font face="楷体">向量伸缩、旋转</font></li>
</ul>
<h3 id="两圆的公切线"><a href="#两圆的公切线" class="headerlink" title="两圆的公切线"></a><font face="楷体">两圆的公切线</font></h3><ul>
<li><font face="楷体">相离：4 条</font></li>
<li><font face="楷体">外切：3 条</font></li>
<li><font face="楷体">相交：2 条</font></li>
<li><font face="楷体">内切：1 条</font></li>
<li><font face="楷体">内含：0 条</font></li>
</ul>
<h4 id="外公切线"><a href="#外公切线" class="headerlink" title="外公切线"></a><font face="楷体">外公切线</font></h4><p>$\cos\alpha&#x3D;\dfrac{r_1-r_2}{d}$</p>
<h4 id="内公切线"><a href="#内公切线" class="headerlink" title="内公切线"></a><font face="楷体">内公切线</font></h4><p>$\cos\alpha&#x3D;\dfrac{r_1+r_2}{d}$</p>
<h2 id="圆的反演"><a href="#圆的反演" class="headerlink" title="圆的反演"></a><font face="楷体">圆的反演</font></h2><p><font face="楷体">给定反演中心点 $O$ 和反演半径 $R$。若平面上点 $P$ 和 $P’$ 满足：</font></p>
<ul>
<li><font face="楷体">点 $P’$ 在射线 $OP$ 上</font></li>
<li>$|\overrightarrow{OP}|\times|\overrightarrow{OP’}|&#x3D;R^2$</li>
</ul>
<p><font face="楷体">则称点 $P$ 和点 $P’$ 互为反演点</font></p>
<p><font face="楷体">性质：</font></p>
<ul>
<li><font face="楷体">圆外的点的反演点在圆内，反之亦然。</font></li>
<li><font face="楷体">圆上的点的反演点为其自身。</font></li>
<li><font face="楷体">不过点 $O$ 的圆，其反演图形也是不过点 $O$ 的圆。</font></li>
<li><font face="楷体">过点 $O$ 的圆，其反演图形是不过点 $O$ 的直线。</font></li>
<li><font face="楷体">两个图形相切，则它们的反演图形也相切。</font></li>
</ul>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（六）</title>
    <url>/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<p>旋转卡壳</p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><font face="楷体">概念</font></h2><p><font face="楷体">点集的直径：平面最远点对（一定是其凸包上的某两个极点）。</font></p>
<p><font face="楷体">性质</font></p>
<ul>
<li><font face="楷体">各极点到其中一点的距离并不存在单调性。</font></li>
<li><font face="楷体">但是各极点到一条极边的距离存在单峰性。</font></li>
</ul>
<h2 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a><font face="楷体">旋转卡壳</font></h2><p><font face="楷体">卡尺绕凸包旋转，其两边经过的点构成对踵点。</font></p>
<img src="/2023/12/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E5%85%AD%EF%BC%89/1.gif" class="" title="咕咕咕">

<p><font face="楷体">一个点的对踵点不好直接得出，且可能不止一个。但一条边的对踵点可以利用上页提到的单峰性找出。</font></p>
<p><font face="楷体">卡尺的一条边逆时针经过各条极边时，另一条边对应的对踵点也是逆时针依次经过，因此二者可以通过双指针进行遍历。</font></p>
<p><font face="楷体">卡尺旋转过程中一定存在某时刻其两边经过直径对应的两点。</font></p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a><font face="楷体">算法流程</font></h2><ul>
<li><font face="楷体">设定初始边指针 p，并找到其对踵点 q。</font></li>
<li><font face="楷体">p 指向下一条边。</font></li>
<li><font face="楷体">如果 q 点到 p 边的距离小于等于 q 的下一个点到 p 边的距离，则 q 指向下一个点。</font></li>
<li><font face="楷体">重复 3 直到找到 p 边的对踵点，更新答案。</font></li>
<li><font face="楷体">回到 2。</font></li>
</ul>
<p><font face="楷体">此处的距离比较可转化为面积比较，从而可以使用叉积解决。</font></p>
<p><font face="楷体">时间复杂度：$O(n)$。</font></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a><font face="楷体">应用</font></h2><h3 id="凸多边形间最大-小距离"><a href="#凸多边形间最大-小距离" class="headerlink" title="凸多边形间最大&#x2F;小距离"></a><font face="楷体">凸多边形间最大&#x2F;小距离</font></h3><p><font face="楷体">重新定义“对踵点”：</font></p>
<p><font face="楷体">以凸多边形某条边作为 y 轴，x 坐标最小的点。</font></p>
<p><font face="楷体">在此定义下，该点依然是和该边组成叉积最大的点。</font></p>
<p><font face="楷体">除此之外，算法流程与求点集直径一致。</font></p>
<h3 id="凸多边形间最小面积-周长外接矩形"><a href="#凸多边形间最小面积-周长外接矩形" class="headerlink" title="凸多边形间最小面积&#x2F;周长外接矩形"></a><font face="楷体">凸多边形间最小面积&#x2F;周长外接矩形</font></h3><p><font face="楷体">不论是最小周长还是面积的外接矩形，其一定有一条边与凸包的一条极边共线。</font></p>
<p><font face="楷体">在旋转卡壳时，多维护方向上的两个极点即可。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何（四）</title>
    <url>/2023/12/02/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>凸包进阶</p>
<span id="more"></span>

<h2 id="凸包二分"><a href="#凸包二分" class="headerlink" title="凸包二分"></a><font face="楷体">凸包二分</font></h2><h3 id="判断点是否在凸多边形中"><a href="#判断点是否在凸多边形中" class="headerlink" title="判断点是否在凸多边形中"></a><font face="楷体">判断点是否在凸多边形中</font></h3><h4 id="按横坐标（x）二分"><a href="#按横坐标（x）二分" class="headerlink" title="按横坐标（x）二分"></a><font face="楷体">按横坐标（x）二分</font></h4><p><font face="楷体">按最左和最右的点把凸包分成上凸壳和下凸壳。</font></p>
<p><font face="楷体">通过一次 to-left 测试找出在上半部分还是下半部分。</font></p>
<p><font face="楷体">在对应凸壳上二分找到点在哪两条过相邻的极点的平行 $y$ 轴的竖线之间。</font></p>
<p><font face="楷体">最后与找到的对应极边进行一次 to-left 测试，确定其是否位于凸多边形内。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h4 id="利用极角序二分"><a href="#利用极角序二分" class="headerlink" title="利用极角序二分"></a><font face="楷体">利用极角序二分</font></h4><p><font face="楷体">从最下方的点出发向其它各点连射线，这些射线方向是按极角序排好的。</font></p>
<p><font face="楷体">通过 to-left 测试与二分查找，可以找出点是在哪两条射线之间。</font></p>
<p><font face="楷体">最后与找到的对应极边进行一次 to-left 测试，确定其是否位于凸多边形内。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h3 id="判断直线是否与凸多边形相交"><a href="#判断直线是否与凸多边形相交" class="headerlink" title="判断直线是否与凸多边形相交"></a><font face="楷体">判断直线是否与凸多边形相交</font></h3><p><font face="楷体">找到与该直线平行的凸多边形的两条切线，判断该直线是否在两条切线之间。</font></p>
<p><font face="楷体">凸多边形各边对应的向量是按照极角序有序的。</font></p>
<p><font face="楷体">二分查找 前驱和后继 分别以向上和向下穿过直线的切点。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h3 id="过一点求凸多边形切线"><a href="#过一点求凸多边形切线" class="headerlink" title="过一点求凸多边形切线"></a><font face="楷体">过一点求凸多边形切线</font></h3><p><font face="楷体">存在切线当且仅当点严格在凸包外。</font></p>
<p><font face="楷体">首先 $O(\log n)$ 地判断点是否在凸包外。</font></p>
<p><font face="楷体">切线：切点前后的点在切线同一侧。</font></p>
<p><font face="楷体">对于凸包上一点 $V_i$，如果 $V_{i+1}$ 在射线 $PV_i$ 左侧，则 $V_i$ 点标记为 <code>L</code>，否则标记为 <code>R</code>。</font></p>
<p><font face="楷体">如果 $V_{i-1}$ 的标记与 $V_i$ 不同，则 $V_i$ 是切点。</font></p>
<h4 id="方法一：上下凸壳"><a href="#方法一：上下凸壳" class="headerlink" title="方法一：上下凸壳"></a><font face="楷体">方法一：上下凸壳</font></h4><h5 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a><font face="楷体">情况一：</font></h5><p><font face="楷体">点在左极点左侧或右极点右侧。</font></p>
<p><font face="楷体">此时，切点一个在上凸壳，一个在下凸壳。</font></p>
<p><font face="楷体">上下凸壳的序列都满足 <code>LLL...RRR...</code> 或 <code>RRR...RRR...</code>，各自二分即可。</font></p>
<h5 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a><font face="楷体">情况二：</font></h5><p><font face="楷体">两个切点均在上凸壳或下凸壳</font></p>
<p><font face="楷体">以上凸壳为例，此时的序列为：<code>LLL...LLLRRR...RRRLLL...LLL</code></font></p>
<p><font face="楷体">二分找到横坐标（x）离该点最近的点，然后将上凸壳分为两部分，这两部分又可以各自二分找到切点。</font></p>
<h4 id="方法二：射线划分"><a href="#方法二：射线划分" class="headerlink" title="方法二：射线划分"></a><font face="楷体">方法二：射线划分</font></h4><p><font face="楷体">点向凸多边形上任意一点作射线，将凸多边形分为左右部分。</font></p>
<p><font face="楷体">在两部分上分别二分即可。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h4 id="方法三：射线划分-cdot-改"><a href="#方法三：射线划分-cdot-改" class="headerlink" title="方法三：射线划分$\cdot$改"></a><font face="楷体">方法三：射线划分$\cdot$改</font></h4><p><font face="楷体">以找到最左侧的切线为例。</font></p>
<h5 id="情况一：-1"><a href="#情况一：-1" class="headerlink" title="情况一："></a><font face="楷体">情况一：</font></h5><p><font face="楷体">序列中第一个点是 R，则序列形如 <code>RRR...RRRLLL...LLLRRR...RRR</code></font></p>
<p><font face="楷体">如果把最开始的几个 <code>R</code> 视作 <code>L</code>，那么序列则转化为可以二分的形式，并且可以二分找到切点。</font></p>
<p><font face="楷体">最开始的几个 <code>R</code> 一定在第一条切线的右侧。</font></p>
<h5 id="情况二：-1"><a href="#情况二：-1" class="headerlink" title="情况二："></a><font face="楷体">情况二：</font></h5><p><font face="楷体">序列中第一个点是 <code>L</code>，则序列形如 <code>LLL...LLLRRR...RRRLLL...LLL</code>。</font></p>
<p><font face="楷体">如果把最后的几个 <code>L</code> 视作 <code>R</code>，那么序列则转化为可以二分的形式，并且可以二分找到切点。</font></p>
<p><font face="楷体">最后的几个 <code>L</code> 一定在第一条切线的右侧。</font></p>
<p><font face="楷体">时间复杂度：$O(\log n)$。</font></p>
<h2 id="动态凸包"><a href="#动态凸包" class="headerlink" title="动态凸包"></a><font face="楷体">动态凸包</font></h2><p><font face="楷体">增量法求凸包，根据已有知识，可以做到 $O(n^2)$。</font></p>
<p><font face="楷体">维护一个数据结构，支持以下两个操作</font></p>
<ul>
<li><font face="楷体">修改：往当前点集中加入一点。</font></li>
<li><font face="楷体">询问：查询一点是否在当前点集的凸包内。</font></li>
</ul>
<p><font face="楷体">以按横坐标（x）维护上凸壳为例，即 set 中的点按横坐标（x）维护。</font></p>
<ul>
<li><font face="楷体">询问，使用前文 $O(\log n)$ 判断点是否在凸包内的做法即可。</font></li>
<li><font face="楷体">修改，二分找到横坐标（x）最近的点，然后分别向左向右遍历各点找切线，对于找到切线前的点将其删除。</font></li>
</ul>
<p><font face="楷体">特殊情况：点在凸包左极点左侧。</font></p>
<p><font face="楷体">考虑一条切线即可，另一个切线在下凸壳考虑。</font></p>
<p><font face="楷体">时间复杂度：$O(n\log n)$。</font></p>
<p><font face="楷体">极角序维护方式同理。</font></p>
<h2 id="闵可夫斯基和"><a href="#闵可夫斯基和" class="headerlink" title="闵可夫斯基和"></a><font face="楷体">闵可夫斯基和</font></h2><p>$A+B&#x3D;\lbrace \vec a+\vec b\mid \vec a\in A,\vec b\in B \rbrace$</p>
<p><font face="楷体">性质：原凸边形的一条极边对应闵可夫斯基和的一条极边。</font></p>
<h3 id="求闵可夫斯基和"><a href="#求闵可夫斯基和" class="headerlink" title="求闵可夫斯基和"></a><font face="楷体">求闵可夫斯基和</font></h3><p><font face="楷体">对两个凸多边形的所有边按极角排序。</font></p>
<p><font face="楷体">确定起点，然后依次加入各边即可。</font></p>
<p><font face="楷体">特殊情况：三点共线。</font></p>
<h3 id="求两个凸多边形之间的最大-小距离"><a href="#求两个凸多边形之间的最大-小距离" class="headerlink" title="求两个凸多边形之间的最大&#x2F;小距离"></a><font face="楷体">求两个凸多边形之间的最大&#x2F;小距离</font></h3><p><font face="楷体">令两个凸多边形对应的点集分别为 $A$ 和 $B$。</font></p>
<p>$A-B&#x3D;A+(-B)&#x3D;\lbrace\vec a-\vec b\mid \vec a\in A,\vec b\in B \rbrace$</p>
<p><font face="楷体">它们之间的最大&#x2F;小距离是所有 $\vec a-\vec b$ 中长度最大&#x2F;小的。</font></p>
<p><font face="楷体">求出闵可夫斯基和，找到离原点最远&#x2F;近的点即可。</font></p>
<p><font face="楷体">时间复杂度：$O(n)$。</font></p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构（四）</title>
    <url>/2024/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>莫队</p>
<span id="more"></span>

<p>普通莫队是一个基于分块的离线解决静态区间询问问题的算法。</p>
<p>但莫队算法扩展性极强，具有许多扩展莫队算法，</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>设询问区间为 $[l_i,r_i]$。对原序列索引分块。将询问区间离线后以 $l_i$ 所在块的编号为第一关键字，$r_i$ 为第二关键字升序。</p>
<p>对于每个询问 $[l_i,r_i]$ 的答案，由 $[l_1,r_1]$ 扩展而来，每次用 while 暴力移动 $l,r$ 指针。</p>
<p>此时，升序后的 $[l_i,r_i]$ 呈现，同一块内的 $l_i$ 对应的询问 $[l_i,r_i]$ 视作一个整体，共有 $\frac nt$ 个块。在一个块内的 $r$ 最多移动 $n$ 次（因为同一块内的 $r$ 升序，最多从 $1$ 移动到 $n$。在同一个块内 $l$ 每次扩展最多移动 $t$ 次。同时，从一个块的右端点询问的 $l$ 向下一个块的左端点的 $l$ 扩展时，$l$ 最多移动 $2t$，$r$ 最多移动 $n$。</p>
<p>综上：处理完 $m$ 个询问，$l,r$ 指针的总移动次数为：$O(\frac{n^2}{t}+mt)$。</p>
<p>当 $t&#x3D;\frac{n}{\sqrt m}$ 时，时间复杂度最优为：$O(n\sqrt m)$。</p>
<p>一般认为 $n,m$ 同阶，所以直接取 $\sqrt n$。</p>
<p>上述只是考虑了指针移动次数。每次指针移动都要一次更新操作的时间复杂度。根据更新的复杂度不同，莫队的时间复杂度不同。</p>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="关于四个循环位置的讨论："><a href="#关于四个循环位置的讨论：" class="headerlink" title="关于四个循环位置的讨论："></a>关于四个循环位置的讨论：</h3><p>莫队区间的移动过程，就相当于加入了 $[1,r]$ 的元素，并删除了 $[1,l-1]$ 的元素，因此：</p>
<ul>
<li>对于 $l\leq r$ 的情况，$[1,l-1]$ 的元素相当于被加入了一次又被删除了一次，$[l,r]$ 的元素被加入一次，$[r+1,+∞)$ 的元素没有被加入。这个区间是合法区间。</li>
<li>对于 $l&#x3D;r+1$ 的情况，$[1,r]$ 的元素相当于被加入了一次又被删除了一次，$[r+1,+∞)$ 的元素没有被加入。这时这个区间表示空区间。</li>
<li>对于 $l&gt;r+1$ 的情况，那么 $[r+1,l-1]$（这个区间非空）的元素被删除了一次但没有被加入，因此这个元素被加入的次数是负数。</li>
</ul>
<p>代码中四个 while 循环一共有 $4!&#x3D;24$ 种排列顺序，不妨设第一个为移动 $l$，那么只考虑 $12$ 种，剩下 $12$ 种对称。 </p>
<img src="/2024/01/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89/1.png" class="" title="咕咕咕">

<h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><p>奇偶化排序：对奇数块内的询问的 $r$ 进行升序，对偶数块内的询问的 $r$ 进行降序。</p>
<p>这是很自然的，因为按原本的排序方式，每次进入一个新块时，r 都会从最大值降到最小值，再又升到最大值。这当然是不优的。</p>
<p>当然，这并不能改变复杂度，只是一个常用的有效的常数优化。</p>
<h2 id="扩展：-1"><a href="#扩展：-1" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="带修莫队："><a href="#带修莫队：" class="headerlink" title="带修莫队："></a>带修莫队：</h3><h3 id="回滚莫队："><a href="#回滚莫队：" class="headerlink" title="回滚莫队："></a>回滚莫队：</h3><h3 id="树上莫队："><a href="#树上莫队：" class="headerlink" title="树上莫队："></a>树上莫队：</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>搜索</title>
    <url>/2024/01/17/%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>搜索</p>
<span id="more"></span>

<p>也就是对状态空间进行枚举，通过穷尽所有的可能来找到最优解，或者统计合法解的个数。</p>
<h2 id="搜索的基本概念："><a href="#搜索的基本概念：" class="headerlink" title="搜索的基本概念："></a>搜索的基本概念：</h2><p>状态：定量的描述一个唯一确定的情况。</p>
<p>状态转移：从一个状态转移到另一个状态的过程，涉及状态上信息的修改。</p>
<p>搜索树：跳过相同状态后，每一个状态视作一个结点，一个状态转移到另一个状态之间视作一条边。</p>
<h2 id="搜索的基本形式："><a href="#搜索的基本形式：" class="headerlink" title="搜索的基本形式："></a>搜索的基本形式：</h2><p>（本文讨论的 DFS 和 BFS 更多地考虑实际问题的搜索，而非图论上的 DFS 和 BFS。对于图论上的 DFS 和 BFS 具有更多更有趣的性质，将在后续中讨论）</p>
<img src="/2024/01/17/%E6%90%9C%E7%B4%A2/1.png" class="" title="咕咕咕">

<h3 id="DFS（深度优先搜索）："><a href="#DFS（深度优先搜索）：" class="headerlink" title="DFS（深度优先搜索）："></a>DFS（深度优先搜索）：</h3><p>在搜索中，DFS 表现为使用递归函数枚举所有解空间。以函数参数作为状态。递归至找到解后返回。体现在搜索树上便是深度优先。</p>
<p>例1：</p>
<p>给定 $10$ 个数，选出 $3$ 个十进制位各不相同的数且和最大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(b[<span class="number">1</span>],b[<span class="number">2</span>],b[<span class="number">3</span>])) ans=<span class="built_in">max</span>(ans,sum);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            b[++cnt]=a[i];</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(x+<span class="number">1</span>,sum+a[i]);</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BFS（宽度优先搜索）："><a href="#BFS（宽度优先搜索）：" class="headerlink" title="BFS（宽度优先搜索）："></a>BFS（宽度优先搜索）：</h3><p>在搜索中，BFS 表现为使用队列枚举所有解空间。以队列元素作为状态。不断入队出队至找到解后终止。体现在搜索树上便是宽度优先。</p>
<p>同样解决例 1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,sum;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>],b[<span class="number">3</span>];</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; q;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">if</span>(now.x==<span class="number">3</span>)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,now.sum);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,<span class="number">10</span>)&#123;</span><br><span class="line">    	<span class="built_in">For</span>(j,<span class="number">1</span>,now.x) <span class="keyword">if</span>(now.a[j]!=i&amp;&amp;<span class="built_in">check</span>(a[i],now.b[j]))&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur=now;</span><br><span class="line">            cur.x++;</span><br><span class="line">            cur.a[cur.x]=i;</span><br><span class="line">            cur.b[cur.x]=a[i];</span><br><span class="line">            cur.sum+=a[i];</span><br><span class="line">            q.<span class="built_in">push</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!now.x)&#123;</span><br><span class="line">            <span class="keyword">auto</span> cur=now;</span><br><span class="line">            cur.x++;</span><br><span class="line">            cur.a[cur.x]=i;</span><br><span class="line">            cur.b[cur.x]=a[i];</span><br><span class="line">            q.<span class="built_in">push</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种搜索方式在遍历解空间角度，仅仅是实现方式不同，一个使用栈（递归栈）一个使用队列，实现功能完全相同。</p>
<h3 id="DFS-和-BFS-的比较："><a href="#DFS-和-BFS-的比较：" class="headerlink" title="DFS 和 BFS 的比较："></a>DFS 和 BFS 的比较：</h3><p>在普遍的教学中，一般以迷宫问题作为 DFS 和 BFS 的引入问题。</p>
<p>那么就来看看迷宫问题：</p>
<p>例 2：</p>
<p>给定一个 $n\times m$ 的迷宫，$0$ 表示通路，$1$ 表示障碍求从 $(1,1)$ 到 $(n,m)$ 的最短路径。</p>
<p>DFS 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==n&amp;&amp;y==m)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,z);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">For</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="type">int</span> X=dx[i]+x,Y=dy[i]+y;</span><br><span class="line">        <span class="keyword">if</span>(!vis[X][Y]&amp;&amp;maze[x][y]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            vis[X][Y]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(X,Y,z+<span class="number">1</span>);</span><br><span class="line">            vis[X][Y]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span>(now.x==n&amp;&amp;now.y==m)&#123;</span><br><span class="line">            ans=now.z;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">For</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="type">int</span> X=now.x+dx[i],Y=now.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span>(maze[X][Y]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;X,Y,now.z+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察两者，比较两者的不同。</p>
<ul>
<li>DFS 需要添加 vis，要求递归过程中不能走回头路（走过的路），因为 DFS 代表一条路走到黑是典型的“不撞南墙不回头”。若允许走回头路，最直接的问题就是在两个状态之间来回横跳，陷入死循环。</li>
<li>BFS 不严格需要添加 vis，且 BFS 过程中终点第一次出队即为最短路径。因为 BFS 过程是将新状态加入队尾，在迷宫问题中满足每次路径只会增加不会减少或不变，且增量相等（都为 $1$）。而初始状态只有一个 $0$，所以 BFS 过程中的任意时候，队列的路径长度中只会有 $2$ 种值且小的在前，大的在后。也就说，出队的路径长度为单调不减且在有限个状态后一定会增。那么就一定会达到最短路径。所以不严格需要添加标记数组，只是会让无用的状态数大量增加。根据以上结论，其实可以发现，BFS 在状态转移增量恒为 $1$ 的问题中，第一次找到的解即为最优解。</li>
</ul>
<p>对于标记数组，因为迷宫问题中，状态转移增量恒为 $1$，所以走过再走一遍的路只会让答案增大。</p>
<p>同时：</p>
<ul>
<li>DFS 的标记数组需要回溯，为单独一条路径服务。</li>
<li>BFS 的标记数组不需要回溯，为全体路径共用。（注意：此条关于 BFS 标记数组的性质是因为状态转移增量为 $1$（状态转移增量相同也可视为 $1$）。而不是因为转移增量为正。若仅满足转移增量为正，不足以支撑所有点共用一个标记数组）</li>
</ul>
<p>DFS 就像一个人独自找答案，不能同时尝试多种方法；BFS 就像一群人分别找答案，在同时尝试不同方法。</p>
<p>综上，可以发现：BFS 在状态转移增量恒为 $1$ 的问题中，第一次找到的解即为最优解且时间复杂度和空间复杂度均为 $O(nm)$ 因为每个点只会被入队一次。而 DFS 在最坏情况下仍会遍历全体解空间导致时间复杂度呈指数级。</p>
<p>而增量不恒为 $1$ 的情况下，BFS 就不能体现以上性质，因为队列中的解不呈单调不减的情况了。也就不能体现和 DFS 相比的优越性了。</p>
<p>DFS 和 BFS 均为搜索算法，仅仅是搜索角度不同。但一般提到搜索，均指 DFS。而 BFS 往往只作为在转移增量恒为 $1$ 的问题中求最小解。</p>
<p>这就是 BFS 在一般问题中标记数组不能共用导致的，在 BFS 的队列中存着若干状态，而每个状态均需要一个标记数组，那么空间复杂度便达到了状态数的平方，这是许多问题不能接受的。</p>
<p>而 DFS 不同，在 DFS 递归到某一层考虑当前函数内层，只存在一个状态，vis 仅为当前状态服务，也就只需要一个标记数组，那么空间复杂度便仅仅是状态数。</p>
<h4 id="addition"><a href="#addition" class="headerlink" title="addition:"></a>addition:</h4><p>在例 $1$ 中，不用添加 vis。因为在例 $1$ 的搜索过程中不会出现走到某一条解路径重复走一个走过的状态，即：无环（DAG）。例 $2$ 却会，即：有环。</p>
<h4 id="存储路径信息："><a href="#存储路径信息：" class="headerlink" title="存储路径信息："></a>存储路径信息：</h4><p>由于 DFS 采用栈存储既往状态，所以如果要求具体解的方案，只要把栈中状态依次取出即可。</p>
<p>而 BFS 不存储深度信息，只存储同一宽度的状态，自然就是不能得到到初始状态的方案，若是要求方案，就需要额外储存了。</p>
<p>这本身就是由深度和宽度而决定的，其实算不上什么优点或缺点，只是恰好实际中往往更需要求方案（即深度信息），而不是宽度信息，如果说现在有一题要求输出比最优解小 1 的状态，那么，DFS 就比不上 BFS 了。</p>
<h4 id="DFS："><a href="#DFS：" class="headerlink" title="DFS："></a>DFS：</h4><p>按深度递归，某一时刻状态数：$O(depth)$。</p>
<h4 id="BFS："><a href="#BFS：" class="headerlink" title="BFS："></a>BFS：</h4><p>按宽度递归，某一时刻状态数：$O(weight)$。</p>
<p>一个猜想：因为 DFS 只需使用到函数递归（递归本身便是一种栈），而不用像 BFS 那样用到数据结构 <code>queue</code>，更适合入门学习，所以更多地采用 DFS 写搜索而不是 BFS。</p>
<h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><h3 id="剪枝："><a href="#剪枝：" class="headerlink" title="剪枝："></a>剪枝：</h3><h4 id="可行性剪枝："><a href="#可行性剪枝：" class="headerlink" title="可行性剪枝："></a>可行性剪枝：</h4><p>若当前情况已经不符合题意则可以直接返回，而不需要走到头。</p>
<p>如例 $1$ 中，若搜索的第二个数已经不满足和第一个数匹配，那就没有必要继续搜索第三个数了。</p>
<h4 id="最优性剪枝："><a href="#最优性剪枝：" class="headerlink" title="最优性剪枝："></a>最优性剪枝：</h4><p>若当前情况已经劣于已经找到的最优解时，直接返回。</p>
<p>如例 $2$ 中，若当前搜到的路径已经比 $ans$ 大了，就不用继续搜了。</p>
<h4 id="搜索顺序剪枝："><a href="#搜索顺序剪枝：" class="headerlink" title="搜索顺序剪枝："></a>搜索顺序剪枝：</h4><p>虽然从某种意义上说，这仅仅是“骗过了数据”。</p>
<p>但是不可否认的是大多情况下，改变搜索顺序可以优化搜索效率。</p>
<p>如例 $1$ 中，若从最大的数开始向小的数搜索，那么效率显然更优。</p>
<h4 id="Alpha-Beta："><a href="#Alpha-Beta：" class="headerlink" title="Alpha-Beta："></a>Alpha-Beta：</h4><p>为一种固定化的剪枝手段。</p>
<p>可自行了解。</p>
<p>略。</p>
<h4 id="人类智慧："><a href="#人类智慧：" class="headerlink" title="人类智慧："></a>人类智慧：</h4><p>以上剪枝策略只是形式化的剪枝策略。还可以利用人类智慧来进行剪枝：</p>
<ul>
<li>极端法：考虑极端情况，如果最极端的情况都不满足，那一定不满足。</li>
<li>调整法：通过对子树的对比剪掉重复子树和明显不是最优的子树。</li>
<li>数学方法：比如在图论中借助连通分量，数论中借助模方程的分析，借助不等式的放缩来估计下界等等。</li>
</ul>
<p>在实际应用中，往往需要选手自行根据题目发扬剪枝艺术。并没有一个固定的写法。</p>
<h3 id="搜索状态的设计："><a href="#搜索状态的设计：" class="headerlink" title="搜索状态的设计："></a>搜索状态的设计：</h3><p>虽然搜索是遍历所有的解空间。但对于不同的状态设计，会呈现出不同的解空间。</p>
<p>以例 $1$ 为例，前文中设计是状态为选到第 $x$ 个数，和为 $sum$。将结果直接写在状态中，那么状态总数即为 $3\times sum$ 的所有可能值。而如果换一种状态设计：$\lbrace a_1,a_2,…,a_{10}\rbrace$ 其中 $a_i&#x3D;1&#x2F;0$ 表示第 $i$ 个数是否被选，状态数总数为 $2^{10}$，结果可以通过状态另外求出。</p>
<p>同时，在实际应用中，根据题目需要，还可以去掉一些无用的状态（剪枝）。</p>
<p>就如例 $1$，容易得到 $10$ 个数选 $3$ 只有 $\binom{10}{3}$ 种有用的状态。</p>
<p>不同的状态定义所形成的搜索树也不尽相同。</p>
<p>通过巧妙的状态定义，也可更好地解决问题。</p>
<p>同时，虽然搜索是遍历所有解空间，但是时间复杂度并不是解空间大小。也不是状态数大小。因为在的搜索过程中，访问到搜索树上同一个节点时，会继续往下考虑，将搜过的内容再搜一遍。</p>
<p>仍以例 1 为例。看这样一组数据：</p>
<p><code>2 3 3 2 1 4</code></p>
<p>对于 $(3,5)$ 这样的状态，能被多少个状态转移而来：$(2,2),(2,3),(2,1),(2,4)$。</p>
<p>而 $(3,5)$ 接下去的状态，$(2,2),(2,3),(2,1),(2,4)$ 都会再考虑一遍。</p>
<h3 id="记忆化搜索："><a href="#记忆化搜索：" class="headerlink" title="记忆化搜索："></a>记忆化搜索：</h3><p>记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。</p>
<p>与其说是记忆化搜索，笔者更愿称之为记忆化递归。通过递归将一个大的问题变成一个个小问题，然后拼接起来。</p>
<p>例 3：</p>
<p>给定 $10$ 个数，选出 $3$ 个数的和小于 $1000$ 且最大。</p>
<p>容易发现仅仅是三个数要满足的限制变了，所以按例 $1$ 的 DFS 写法把 check 函数变一变即可。但是这样无法记忆化的。因为它每一个状态维护的是到起点的结果，而不是到终点。既然是到终点，那么 $sum$ 就不能直接维护，而是要通过函数递归返回值求得：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(x+<span class="number">1</span>)+a[i]&lt;<span class="number">1000</span>)</span><br><span class="line">            	res=<span class="built_in">max</span>(res,<span class="built_in">dfs</span>(x+<span class="number">1</span>)+a[i]);</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记忆化搜索因为使用以往搜到是结果，那么就要保证现在到这一步时确确实实能按以往的结果做选择。如果到这一步之前的选择的不同影响了后续的可选择性，那自然是不能用之前的结果的，也就是满足“子问题”。</p>
<p>所以上述代码中仅仅用 $(x)$ 描述状态并不是一个子问题。所以需要对状态设计进行修改，使得一个状态描述确确实实是一个子问题。</p>
<p>状态可以修改为 $(i,x)$ 最后选的一个数是第 $i$ 个数，已经选了 $x$ 个数。因为限制死了后续只能选择 $i+1,i+2,…n$ 中的数，那么就保证了遇到 $(i,x)$ 这个状态时，后续的可选择性是一致的。</p>
<p>因为只需要在一般搜索的基础上进行记录状态结果的行为，所以记忆化搜索算是一种优化思想。体现在代码上也并不复杂。</p>
<p>核心变为如何存储状态信息：</p>
<p>一般而言，若状态信息并不复杂（主要是数值不大）那么便可以直接用数组进行存储，将状态信息记录为数组下标。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> _i,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_i&gt;n) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[_i][x]) <span class="keyword">return</span> mem[_i][x];</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(i,_i+<span class="number">1</span>,n)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i+<span class="number">1</span>,x+<span class="number">1</span>)+a[i]&lt;<span class="number">1000</span>)</span><br><span class="line">        	res=<span class="built_in">max</span>(res,<span class="built_in">dfs</span>(i+<span class="number">1</span>,x+<span class="number">1</span>)+a[i]);</span><br><span class="line">    vis[_i][x]=<span class="number">1</span>;</span><br><span class="line">    mem[_i][x]=res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BFS 因为不搜到底，并不能利用已经到过的状态（就算状态是到过的，但是没有它到终点的结果）。所以 BFS 不存在记忆化搜索的写法。</p>
<p>事实上，问题的 $sum$ 一般都会比较大，不能作为数组下标存储。但是我们可以使用 map 将状态和状态的结果视作一个映射，存起来。</p>
<p>因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。</p>
<h4 id="addition："><a href="#addition：" class="headerlink" title="addition："></a>addition：</h4><p>为什么要用例 $3$ 记忆化而不是例 $1$？</p>
<p>因为例 $1$ 根本无法简单地记忆化，因为例 $1$ 的后续的选择是和前面所有选的具体数字是有关的，而不是仅通过和就可以判断是否能选的（例 $3$ 中的 check 只关心和的大小，不关心具体选的数；例 $1$ 中的 check 需要关心所有选择的数）。同一个状态描述对应的不同实际状态的后续操作不尽相同。比如例 $1$ 中，选择 $2,3$ 或 $1,4$ 都对应 $(3,5)$ 的状态描述，但在选择第三个数时，他们的选择是不一样的。</p>
<p>所以例 $1$ 中的状态不足以支撑记忆化的过程。</p>
<p>但是观察会发现，其实不是状态不行，而是状态描述不行。选择的数在例 $1$ 中是要考虑到状态描述中去的，那么在状态描述中加上选择的数即可。但是这样产生的问题就是状态不易存储。</p>
<p>我们需要更巧妙的状态描述。本文不再赘述。</p>
<h3 id="双向搜索："><a href="#双向搜索：" class="headerlink" title="双向搜索："></a>双向搜索：</h3><h4 id="同时双向搜索："><a href="#同时双向搜索：" class="headerlink" title="同时双向搜索："></a>同时双向搜索：</h4><p>同时从起点和终点开始搜索。往往采用 BFS 实现。</p>
<p>把起点和终点都加入初始队列。</p>
<p>在扩展过程中，把由起点扩展的一系列点标记为 $1$，把由终点扩展的一系列点标记为 $2$。当 $1$ 能扩展到 $2$，或 $2$ 能扩展到 $1$ 时，表示找到解。</p>
<p>由于起点和终点交题前进，所以对于起点和终点，各自的深度只有原规模的一半，那么状态规模的增长也只有原来的一半。</p>
<h4 id="meet-in-middle："><a href="#meet-in-middle：" class="headerlink" title="meet in middle："></a>meet in middle：</h4><p>将原问题划分成两部分分别处理，后将两部分的结果合并。meet in middle 往往用于处理序列问题，把序列划分成左右两部分。</p>
<p>例 4：</p>
<p>给定 $40$ 个数，求选出若干个数的和不超过 $10^9$ 的方案数。</p>
<p>直接对 $40$ 个数搜索所有解的时间复杂度为：$O(2^{40})$。</p>
<p>若将序列划分成两个长度为 $20$ 的序列，首先单独处理的时间复杂度为：$O(2^{20})$。</p>
<p>之后，对于左半部分的某一个解，在右半部分中找到之和不超过 $10^9$ 的方案数。即为在若干个数中求不超过某值的数的个数，可以使用二分解决（<code>upper_bound</code>）。</p>
<p>总时间复杂度：$O(20\times 2^{20})$。</p>
<p>一般而言，决定是否能双向搜索的均为两部分信息是否能合并。</p>
<p>若原问题状态规模为 $O(a^{k})$，双向搜索状态规模降为 $O(a^{\frac{k}2})$。</p>
<h3 id="A-："><a href="#A-：" class="headerlink" title="A*："></a>A*：</h3><p>A* 是基于 BFS 的改进。</p>
<p>定义从 $x$ 到起点的距离为 $g(x)$，从 $x$ 到终点的距离为 $h(x)$，$x$ 的估价函数为 $f(x)$。初始起点入队，每次从队列中取出估价函数最小的一个元素。$h(x)$ 称为启发函数，因为无法直接获取从 $x$ 到终点的距离，所以对 $h(x)$ 采用的往往是一个估价量，要求不超过真实距离，且越接近真实距离，越优。</p>
<h3 id="迭代加深搜索："><a href="#迭代加深搜索：" class="headerlink" title="迭代加深搜索："></a>迭代加深搜索：</h3><p>每次限制递归层数的 DFS。</p>
<p>每进行一次 DFS，递归深度限制增大 $1$。</p>
<p>避免了 DFS 的递归层数过多；也避免了 BFS 在同一时刻状态数过多。</p>
<p>但存在重复搜索前缀的缺点，不过由于搜索树的规模增长一般为指数，深度增大一层的数据规模可能会超过前面所有层的数据规模之和。所以影响并不是那么大。</p>
<h3 id="IDA-："><a href="#IDA-：" class="headerlink" title="IDA*："></a>IDA*：</h3><p>A* 和迭代加深的结合。</p>
<h3 id="01-BFS："><a href="#01-BFS：" class="headerlink" title="01 BFS："></a>01 BFS：</h3><p>在前文中，提到 BFS 主要用于解决边权为 $1$ 的最短路径问题。但是注意到 BFS 过程中队列内是有两个距离值的，队尾比队首大 $1$，边权为 $1$ 时每次扩展加在队尾。如果边权还存在 $0$ 的话，则加在队首。其它部分与 BFS 完全相同。</p>
<h3 id="优先队列-BFS："><a href="#优先队列-BFS：" class="headerlink" title="优先队列 BFS："></a>优先队列 BFS：</h3><p>在前文中，提到 BFS 如果处理边权不为 $1$ 的问题，那便没有第一次出队即为最小值的性质了。究其本质，是因为队列内元素不呈现单调性了。</p>
<p>但是可以“强行”让队列内元素呈现单调性。即：采用优先队列替换队列实现。</p>
<p>但若是边权存在负值，那仍然不满足第一次出队时为最小值（不能使用 vis 数组）</p>
<p>原因显然。</p>
<h3 id="Dancing-Links："><a href="#Dancing-Links：" class="headerlink" title="Dancing Links："></a>Dancing Links：</h3><p>解决精确覆盖问题和重复覆盖问题的高效搜索算法。</p>
<p>采用十字链表加上优秀的剪枝实现。</p>
<p>略。</p>
<h3 id="启发式搜索："><a href="#启发式搜索：" class="headerlink" title="启发式搜索："></a>启发式搜索：</h3><h4 id="贪婪最佳优先搜索："><a href="#贪婪最佳优先搜索：" class="headerlink" title="贪婪最佳优先搜索："></a>贪婪最佳优先搜索：</h4><p>$h(x)&#x3D;0$ 的 A*，也就是优先队列 BFS，也可以说是 Dijkstra。</p>
<h4 id="模拟退火："><a href="#模拟退火：" class="headerlink" title="模拟退火："></a>模拟退火：</h4><p>它是一种基于概率的搜索算法，模拟固体物质的退火过程。它以一定的概率接受比当前解更差的解，以避免陷入局部最优。它的估价函数是 $f(n)&#x3D; e^{-\frac{ΔE}{T}}$，其中 $ΔE$ 表示新解和旧解的能量差，$T$ 表示温度参数。它的优点是能够跳出局部最优，缺点是参数的选择比较难，收敛速度慢。</p>
<h4 id="遗传算法："><a href="#遗传算法：" class="headerlink" title="遗传算法："></a>遗传算法：</h4><h4 id="蚁群算法："><a href="#蚁群算法：" class="headerlink" title="蚁群算法："></a>蚁群算法：</h4><h4 id="粒子群优化算法："><a href="#粒子群优化算法：" class="headerlink" title="粒子群优化算法："></a>粒子群优化算法：</h4><h2 id="番外："><a href="#番外：" class="headerlink" title="番外："></a>番外：</h2><h3 id="对抗搜索："><a href="#对抗搜索：" class="headerlink" title="对抗搜索："></a>对抗搜索：</h3><p>这里的对抗搜索是指双人进行对抗博弈。</p>
<p>博弈原理：</p>
<ul>
<li>存在先手必胜策略，当且仅当存在一种策略使得不存在后手必胜策略。</li>
<li>存在后手必胜策略，当且仅当无论先手怎么操作，都有后手必胜策略。</li>
</ul>
<p>一般状态设计为 dfs$(x,…y)$ $x&#x3D;1&#x2F;0$ 表示先手&#x2F;后手；$y&#x3D;1&#x2F;0$ 表示必胜&#x2F;必败；返回值为 $1&#x2F;0$ 表示是否存在。参数其它部分用于描述局面信息。</p>
<ul>
<li>dfs$(x,…,1)&#x3D;$dfs$(x\oplus 1,…0)$ 与之和。</li>
<li>dfs$(x,…,0)&#x3D;$dfs$(x\oplus 1,…1)$ 或之和。</li>
</ul>
<h2 id="Attention："><a href="#Attention：" class="headerlink" title="Attention："></a>Attention：</h2><p>因为搜索其本身时间复杂度上界很高，以及剪枝没有严格时间复杂度证明，所以近年来的算法竞赛中搜索相关问题的出现次数大大减少，除非题目本身明确上界也能通过，否则不会是搜索问题。</p>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
  </entry>
  <entry>
    <title>STL的使用</title>
    <url>/2024/01/19/STL%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>STL</p>
<span id="more"></span>

<p>STL 即标准模板库（Standard Template Library），是 C++ 标准库的一部分，里面包含了一些模板化的通用的数据结构和算法。</p>
<h2 id="C-标准："><a href="#C-标准：" class="headerlink" title="C++ 标准："></a>C++ 标准：</h2><p>C++ 自 1985 年诞生以来，一共由国际标准化组织（ISO）发布了 5 个正式的 C++ 标准，依次为 C++98、C++03、C++11（亦称 C++0x）、C++14（亦称 C++1y）、C++17（亦称 C++1z）、C++20（亦称 C++2a）。C++ 标准草案在 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/">open-std</a> 网站上，最新的标准 C++23（亦称 C++2b）仍在制定中。此外还有一些补充标准，例如 C++ TR1。</p>
<p>每一个版本的 C++ 标准不仅规定了 C++ 的语法、语言特性，还规定了一套 C++ 内置库的实现规范，这个库便是 C++ 标准库。C++ 标准库中包含大量常用代码的实现，如输入输出、基本数据结构、内存管理、多线程支持等。C++ 标准库中的函数或者对象都是在命名空间<code>std</code>中定义的。</p>
<p>ICPC 支持 C++20 标准。</p>
<h2 id="STL（标准模板库）："><a href="#STL（标准模板库）：" class="headerlink" title="STL（标准模板库）："></a>STL（标准模板库）：</h2><p>STL 是 C++ 标准库的一部分，里面包含了一些模板化的通用的数据结构和算法。</p>
<h2 id="STL-容器："><a href="#STL-容器：" class="headerlink" title="STL 容器："></a>STL 容器：</h2><p>容器是一个模板类，它用于存放各种类型的数据</p>
<h3 id="序列式容器："><a href="#序列式容器：" class="headerlink" title="序列式容器："></a>序列式容器：</h3><ul>
<li>向量（vector）后端可高效增加元素的顺序表。</li>
<li>数组（array）定长的顺序表，C 风格数组的简单包装。（C++11 标准）</li>
<li>双端队列（deque）双端都可高效增加元素的顺序表。</li>
<li>列表（list）可以沿双向遍历的链表。</li>
<li>单向链表（forward_list）只能沿一个方向遍历的链表。</li>
</ul>
<h3 id="有序关联式容器："><a href="#有序关联式容器：" class="headerlink" title="有序关联式容器："></a>有序关联式容器：</h3><ul>
<li>集合（set）有序地存储互异元素的容器。</li>
<li>多重集合（multiset）元素可以相等的 set。</li>
<li>映射（map）由（键，值）对（二元组）组成的容器，要求键互异，按键有序存储。</li>
<li>多重映射（multimap）键可以相等的 map。</li>
</ul>
<h3 id="无序关联式容器："><a href="#无序关联式容器：" class="headerlink" title="无序关联式容器："></a>无序关联式容器：</h3><ul>
<li>unordered_set&#x2F;unordered_multiset&#x2F;unordered_map&#x2F;unordered_multimap，元素乱序，用于判断元素是否存在。使用哈希实现。（C++11 标准）</li>
</ul>
<h3 id="容器适配器："><a href="#容器适配器：" class="headerlink" title="容器适配器："></a>容器适配器：</h3><p>容器适配器并不是容器，它们不具有容器的部分特点。</p>
<ul>
<li>栈（stack）后进先出的容器，默认是对双端队列（deque）的包装。</li>
<li>队列（queue）先进先出的容器，默认是对双端队列（deque）的包装。</li>
<li>优先队列（priority_queue）元素的有序的一种队列，默认是对向量（vector）的包装。</li>
</ul>
<h3 id="容器声明："><a href="#容器声明：" class="headerlink" title="容器声明："></a>容器声明：</h3><p><code>containerName&lt;typeName&gt; name</code>。</p>
<h3 id="迭代器："><a href="#迭代器：" class="headerlink" title="迭代器："></a>迭代器：</h3><p>在 STL 中，迭代器用来访问和检查 STL 容器中元素的对象，它的行为模式和指针类似。</p>
<p>迭代器可以看作一个数据指针，主要支持两个运算符：自增 (<code>++</code>) 和解引用（<code>*</code>），其中自增用来移动迭代器，解引用可以获取或修改它指向的元素。</p>
<p>指向某个 STL 容器 <code>container</code> 中元素的迭代器的类型一般为 <code>container::iterator</code>。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,a.<span class="built_in">size</span>()) cout&lt;&lt;a[i<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=a.<span class="built_in">begin</span>();it!=a.<span class="built_in">end</span>();it++) cout&lt;&lt;*it&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在 C++11 后，可使用 <code>auto it=a.begin();</code> 的方式自动识别迭代器类型。</p>
<h3 id="容器共有成员函数："><a href="#容器共有成员函数：" class="headerlink" title="容器共有成员函数："></a>容器共有成员函数：</h3><ul>
<li><code>=</code>：拷贝。</li>
<li><code>begin()</code>：返回指向开头元素的迭代器。</li>
<li><code>end()</code>：返回指向末尾的下一个元素的迭代器。<code>end()</code> 不指向某个元素，但它是末尾元素的后继。</li>
<li><code>size()</code>：返回容器内的元素个数。</li>
<li><code>empty()</code>：返回容器是否为空。</li>
<li><code>swap()</code>：交换两个容器。</li>
<li><code>clear()</code>：清空容器。</li>
</ul>
<h3 id="vector："><a href="#vector：" class="headerlink" title="vector："></a>vector：</h3><p>动态数组。</p>
<ul>
<li>vector 基于字典序重载了比较运算符。</li>
<li>vector 支持 &#x3D; 初始化。</li>
</ul>
<p>以下是 vector 常用方法：</p>
<ul>
<li>v.resize(x,y)将 v 的大小重设为 x，若原本大小不足 x，则用 y 填充。y 可不写，默认为 0。</li>
<li>vector&lt;int&gt; v(x,y)创建一个初始大小为 x 的 vector，并用 y 填充。y 可不写，默认为 0。</li>
<li>vector<int> v1(v2)创建一个 v2 的拷贝 v1。</li>
<li>v.front() v 的首元素。</li>
<li>v.back() v 的尾元素。</li>
<li>v.rbegin() 指向 v 逆向的首元素的迭代器。</li>
<li>v.rend()指向 v 逆向的尾元素后继的迭代器。</li>
<li>v.push_back(x)在 v 的末尾加入 x。</li>
<li>v.pop_back()删除 v 的末尾元素。</li>
<li>swap(v1,v2)交换 v1,v2。</li>
</ul>
<h3 id="array："><a href="#array：" class="headerlink" title="array："></a>array：</h3><p>静态数组。</p>
<p>略。</p>
<h3 id="deque："><a href="#deque：" class="headerlink" title="deque："></a>deque：</h3><p>双端队列。</p>
<p>内容与 vector 一致（底层实现不一致）。</p>
<p>多：</p>
<ul>
<li>q.push_front(x)在 q 头部插入一 x。</li>
<li>q.pop_front()删除 q 的头部元素。</li>
</ul>
<h3 id="list："><a href="#list：" class="headerlink" title="list："></a>list：</h3><p>双向链表。</p>
<p>使用与 deque 基本一致。</p>
<p>元素访问不一致：</p>
<p>不能随机访问，要从头或尾迭代器开始。</p>
<ul>
<li>l.front()返回首元素的引用。</li>
<li>l.back()返回末尾元素的引用。</li>
</ul>
<p>额外方法：</p>
<ul>
<li>l.splice()</li>
<li>l.remove()</li>
<li>l.sort()</li>
<li>l.unique()</li>
<li>l.merge()</li>
</ul>
<h3 id="forward-list："><a href="#forward-list：" class="headerlink" title="forward_list："></a>forward_list：</h3><p>单向链表。</p>
<p>与 list 几乎一致。</p>
<h3 id="set："><a href="#set：" class="headerlink" title="set："></a>set：</h3><p>集合。</p>
<p>set 底层逻辑为红黑树（是一种平衡二叉搜索树）。set 默认升序。</p>
<p>插入与删除：</p>
<ul>
<li>s.insert(x)将 x 插入 s。</li>
<li>s.erase(x) 将 s 中的所有 x。</li>
<li>s.erase(it)将 s 的迭代器 it 指向的元素删除，要求 it 必须合法。</li>
<li>s.erase(begin,end)将 s 中迭代器 [begin,end)之间的元素删除。</li>
</ul>
<p>迭代器：</p>
<p>与 vector 一致。</p>
<ul>
<li>s.begin()</li>
<li>s.end()</li>
<li>s.rbegin()</li>
<li>s.rend()</li>
</ul>
<p>查找：</p>
<ul>
<li>s.count(x)返回 s 中 x 的个数。</li>
<li>s.find(x)返回 s 中 x 的迭代器，若不存在则返回 s.end()。</li>
<li>s.lower_bound(x)返回首个大于等于 x 的元素的迭代器，若不存在则返回 s.end()。</li>
<li>s.upper_bound(x)返回首个大于 x 的元素的迭代器，若不存在则返回 s.end()。</li>
</ul>
<p>由于 set 作为平衡树的封装，其强大的功能和简单的使用，在很多场景下都有很好的应用，是使用最多的 STL。好好利用 set，能极大的帮助选手解决问题。</p>
<p>set 的注意点：</p>
<ul>
<li>set 迭代器的 ++&#x2F;– 时间复杂度为均摊 $O(1)$，最坏 $O(\log n)$。</li>
<li>使用 algorithm 库的 lower_bound&#x2F;upper_bound 对 set 的时间复杂度为 $O(n)$。</li>
<li>使用 algorithm 库的 nth_element 对 set 的时间复杂度为 $O(n)$。</li>
</ul>
<h3 id="multiset："><a href="#multiset：" class="headerlink" title="multiset："></a>multiset：</h3><p>可重集。</p>
<p>与 set 完全一致。</p>
<h3 id="map："><a href="#map：" class="headerlink" title="map："></a>map：</h3><p>映射。</p>
<p>键和值之间一一对应且保证键升序，不能存在多个相同键。</p>
<p>若在 map 中插入多个相同键值对，保留第一个。</p>
<p>常常应用在 string 和 int 的映射上，例如学生成绩的查询；或是统计值较大的数字个数。</p>
<p>操作与 set 一致，替换成对 map 键的操作。</p>
<p>多：</p>
<ul>
<li>可以使用 mp[key] 的方式访问键对应的值。</li>
<li>使用 mp[key] 时，若 mp 中没有键为 key 的元素则会自动加入一个，对应的值默认为 $0$。所以不建议使用 mp[key] 判断是否存在，而应使用 mp.find(key)。</li>
</ul>
<h3 id="multimap："><a href="#multimap：" class="headerlink" title="multimap："></a>multimap：</h3><p>键可以重复的 map。</p>
<p>操作与 map 一致。</p>
<p>但因为键可以重复，所以 multimap 没有通过键访问值的方法。</p>
<h3 id="unordered-set-unordered-multiset-unordered-map-unordered-multimap："><a href="#unordered-set-unordered-multiset-unordered-map-unordered-multimap：" class="headerlink" title="unordered_set&#x2F;unordered_multiset&#x2F;unordered_map&#x2F;unordered_multimap："></a>unordered_set&#x2F;unordered_multiset&#x2F;unordered_map&#x2F;unordered_multimap：</h3><p>方法与有序关联式容器一致。</p>
<p>除了没有与“有序”有关的方法，例如：lower_bound 和 upper_bound。</p>
<p>由于是基于哈希实现的，一般情况下时间复杂度为 $O(1)$。</p>
<p>但在默认情况下，可以被构造数据卡时间复杂度，将 $O(1)$ 的时间复杂度卡成 $O(n)$。</p>
<p>但可以通过自定义哈希函数，在一定程度上防止被卡。</p>
<h3 id="stack："><a href="#stack：" class="headerlink" title="stack："></a>stack：</h3><p>栈。</p>
<p>是一种后进先出的容器适配器，仅支持查询或删除最后一个加入的元素，不支持随机访问，不支持迭代器。</p>
<ul>
<li>q.top()访问栈顶元素。</li>
<li>q.push(x)将 x 插入栈顶。</li>
<li>q.pop()删除栈顶元素（栈不能为空）。</li>
<li>q.size()查询栈内元素数量。</li>
<li>q.empty()查询栈是否为空。</li>
</ul>
<h3 id="queue："><a href="#queue：" class="headerlink" title="queue："></a>queue：</h3><p>队列。</p>
<p>是一种先进先出的容器适配器，仅支持查询或删除第一个加入的元素，不支持随机访问，不支持迭代器。</p>
<ul>
<li>q.front()访问队首元素。</li>
<li>q.push(x)向队列中插入 x。</li>
<li>q.pop()删除队首元素（队列不能为空）。</li>
<li>q.size()查询队列内元素数量。</li>
<li>q.empty()查询队列是否为空。</li>
</ul>
<h3 id="priority-queue："><a href="#priority-queue：" class="headerlink" title="priority_queue："></a>priority_queue：</h3><p>优先队列（本质是一种堆，一般为二叉堆）。</p>
<p>$O(\log n)$：</p>
<ul>
<li>q.push(x)在 q 中插入元素 x。</li>
<li>q.pop()删除堆顶元素（优先队列不能为空）。</li>
</ul>
<p>$O(1)$：</p>
<ul>
<li>q.top()查询堆顶元素（优先队列不能为空）。</li>
<li>q.size()查询优先队列元素数量。</li>
<li>q.empty()查询优先队列是否为空。</li>
</ul>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="string："><a href="#string：" class="headerlink" title="string："></a>string：</h3><p>字符串。</p>
<p>string 可以动态分配内存，不用初始设定。支持 cin&#x2F;cout 进行输入输出。</p>
<p>string 重载了加法运算符，使用 + 可以简单拼接两个字符串。</p>
<p>注意：</p>
<ul>
<li>a&#x3D;a+b，时间复杂度为 $O(|a+b|)$。</li>
<li>a+&#x3D;b，时间复杂度为 $O(|b|)$。</li>
</ul>
<p>string 基于字典序重载比较运算符。</p>
<p>string 转 char：</p>
<p>通过 s.c_str() 的方式将 string 转换成 char 数组。</p>
<p>成员函数：</p>
<ul>
<li>s.length()查询 s 的长度，返回和 s.size() 相同。</li>
<li>s.size()查询 s 的大小，返回和 s.length() 相同。</li>
<li>s.find(str,pos) 从 pos 起查询 s 中第一次出现 str 的位置，如果没有出现返回 -1。pos 可不传参，默认从 0 开始。</li>
<li>s.substr(pos,len)在 s 中从 pos 起截取最多 len 个字符组成字符串。</li>
<li>s.insert(pos,cnt,str)在 s 中从 pos 起插入 cnt 个 str 字符串。cnt 可不传参，默认为 1。</li>
<li>s.erase(pos,len)在 s 中从 pos 起删除 len 个字符。len 可不传参，默认删除 pos 起的全部字符。</li>
<li>s.replace(pos,len,str)将在 s 中从 pos 起 len 个字符替换成 str 字符串。</li>
<li>s.replace(first,last,str)将在 s 中 [first,last) 之间的字符串替换成 str。</li>
</ul>
<p>注意：</p>
<ul>
<li>s.length()&#x2F;s.size() 返回值均为 unsigned。</li>
<li>C 语言中对字符串长度的处理函数 strlen() 的时间复杂度关于字符串长度呈线性。而 s.length() 和 s.size() 均为 $O(1)$。</li>
</ul>
<h3 id="bitset："><a href="#bitset：" class="headerlink" title="bitset："></a>bitset：</h3><p>bitset 是 C++ 标准库中的一个存储 0&#x2F;1 的大小不可变容器。严格来说，bitset 并不属于 STL。</p>
<p>由于内存地址是按 byte 寻址，而非 bit。一个 bool 类型的变量，虽然只存储 0&#x2F;1 但也占 1 byte 的内存。而 bitset 使得一个 byte 存储 8 位 0&#x2F;1。</p>
<p>使用：</p>
<ul>
<li>bitset&lt;size&gt; s;定义了一个拥有 size 位的 bitset。</li>
</ul>
<p>构造函数：</p>
<ul>
<li>bitset()默认每一位都是 $0$。</li>
<li>bitset(unsigned int x)初始为 x 的二进制表示。</li>
<li>bitset(const string &amp;str)初始为 01 传 str（传入非 01 串会抛出异常）。</li>
</ul>
<p>运算符：</p>
<p>bitset 支持许多独特的运算，由于 bitset 的 0&#x2F;1 性质，使得其支持位运算。</p>
<ul>
<li>[] 访问 bitset 某一位。</li>
<li>&#x3D;&#x3D;&#x2F;!&#x3D; 判断两个 bitset 内容是否完全相同。</li>
<li>&amp;、|、^、~、&lt;&lt;、&gt;&gt;，对整个 bitset 进行位运算。</li>
<li>&lt;&gt; （流运算符，注意与位运算的区分）意味着可以通过 cin&#x2F;cout 进行输入输出类似 string。</li>
</ul>
<p>成员函数：</p>
<ul>
<li>count()查询 1 的数量。</li>
<li>size()查询 bitset 的大小。</li>
<li>test(x)查询第 x 位，和 [] 的区别是越界检查，test 越界后会抛出异常。</li>
<li>any()查询是否存在 1。</li>
<li>none()查询是否不存在 1。</li>
<li>all()查询是否全是 1。（C++11 标准）</li>
<li>set(x,y)将 bitset 第 x 位设置为 y。可以无参数，将整个 bitset 设置为 1。</li>
<li>reset(x)将 bitset 第 x 位设置为 0。可以无参数，将整个 bitset 设置为 0。</li>
<li>flip(x)翻转 bitset 第 x 位。可以无参数，默认翻转整个。</li>
<li>to_string()返回将 bitset 转换为 string 的结果。</li>
<li>to_ullong()返回将 bitset 转换为 unsigned long long 的结果。(C++11 标准)</li>
</ul>
<h3 id="pair："><a href="#pair：" class="headerlink" title="pair："></a>pair：</h3><p>二元组。</p>
<p>使用：</p>
<p><code>pair&lt;Typename,Typename&gt; a;</code></p>
<p>使用 a.first 访问 a 的第一个元素，a.second 访问 a 的第二个元素。</p>
<p>pair 相较于自定义 struct 的优势是自定义了比较运算符，按照先比较第一个元素，再比较第二个元素的原则进行。在部分情形下更加方便。（前提是 pair 内的 Type 存在对应的比较运算符）</p>
<h3 id="tuple："><a href="#tuple：" class="headerlink" title="tuple："></a>tuple：</h3><p>元组（C++11 标准）。</p>
<p>类似于 n 元的 pair，通常可以用 pair 套 pair 的方式做等价实现。</p>
<p>略。</p>
<h3 id="rope："><a href="#rope：" class="headerlink" title="rope："></a>rope：</h3><p>块状链表（采用可持久化平衡树实现）。</p>
<p>rope 不是真正的块状链表，只是起到块状链表的作用，所以其时间复杂度为 $O(\log n)$。</p>
<p>使用：</p>
<p>rope 使用较特殊，需要使用以下代码来引入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/rope&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> __gnu_cxx;</span><br></pre></td></tr></table></figure>

<p><code>rope&lt;Typename&gt; a</code>。</p>
<ul>
<li>a.push_back(x)在 a 的末尾插入 x。</li>
<li>a.insert(pos,x)在 a 中的 pos 位置加入元素 x。</li>
<li>a.erase(pos,len)在 a 中的 pos 位置起删除 len 个元素。</li>
<li>a.at(x)或 a[x]查询 a 的第 x 个元素。</li>
<li>a.length()或 a.size()查询 a 的大小。</li>
</ul>
<h2 id="STL-算法："><a href="#STL-算法：" class="headerlink" title="STL 算法："></a>STL 算法：</h2><p>STL 提供了大约 100 个实现算法的模版函数，基本都包含在 <code>&lt;algorithm&gt;</code> 之中，还有一部分包含在 <code>&lt;numeric&gt;</code> 和 <code>&lt;functional&gt;</code> 中。</p>
<ul>
<li>find(s.first,s.last,v)在容器 s 中迭代器 [first,last) 之间查找 v，返回迭代器。若找不到，返回 s.last。</li>
<li>reverse(s.first,s.last)翻转容器 s 中迭代器 [first,last) 之间的内容。</li>
<li>unique(s.first,s.last)去除容器 s 中迭代器 [first,last) 之间相邻的重复元素。返回 s.last。</li>
<li>shuffle(s.first,s.last,rng)随机打乱容器 s 中迭代器 [first,last) 之间元素。rng 随机数生成器，一般情况使用以真随机数生成器 random_device 播种的梅森旋转伪随机数生成器 mt19937。</li>
<li>sort(s.first,s.last,compare)对容器 s 中迭代器 [first,last) 之间的元素排序，compare 为比较函数，可不传参。默认升序。（stable_sort 为稳定排序）</li>
<li>binary_search(s.first,s.last,v)在容器 s 中迭代器 [first,last) 范围内二分查找 v。返回 1 表示存在 v，返回 0 表示不存在 v。</li>
<li>lower_bound(s.first,s.last,v)返回容器 s 中迭代器 [first,last) 范围内找到第一个大于等于&#x2F;小于等于（取决于范围内元素是升序还是降序，若范围内元素为无序，不会报错，但结果不一定正确） v 的迭代器，找不到返回 s.last。</li>
<li>upper_bound(s.first,s.last,v)返回容器 s 中迭代器 [first,last) 范围内找到第一个大于&#x2F;小于（取决于范围内元素是升序还是降序，若范围内元素为无序，不会报错，但结果不一定正确） v 的迭代器，找不到返回 s.last。</li>
<li>merge(v1.first,v1.last,v2.first,v2.last,back_inserter(v3))把容器 v1 中迭代器 [first,last] 范围元素和容器 v2 中迭代器 [first,last) 范围内元素有序合并后插入到 v3 后。（要求 v1 v2 对应范围内均升序）线性时间复杂度。</li>
<li>inplace_merge(v.first,v.middle,v.last)将容器 v 中迭代器 [first,middle) 和 [middle,last) 范围内的元素有序合并（要求 [first,middle) 和 [middle,last) 均升序）。线性时间复杂度。</li>
<li>next_permutation(s.first,s.last) 将容器 s 中迭代器 [first,last) 范围的排列更改为全排列中的下一个排列。</li>
<li>prev_premutation(s.firts,s.last) 将容器 s 中迭代器 [first,last) 范围的排列更改为全排列中的下一个排列。</li>
<li>partial_sum(v.first,v.last)求容器 s 中迭代器 [first,last) 范围的前缀和。线性时间复杂度。</li>
</ul>
<h2 id="pb-ds："><a href="#pb-ds：" class="headerlink" title="pb_ds："></a>pb_ds：</h2><p>pb_ds 库全称 Policy-Based Data Structures。</p>
<p>pb_ds 库封装了很多数据结构，比如哈希（Hash）表，平衡二叉树，字典树（Trie 树），堆（优先队列）等。</p>
<p>就像 vector、set、map 一样，其组件均符合 STL 的相关接口规范。部分（如优先队列）包含 STL 内对应组件的所有功能，但比 STL 功能更多。</p>
<p>pb_ds 只在使用 libstdc++ 为标准库的编译器下可以用。</p>
<h3 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h3><p>在堆的实现上，pb_ds 比 STL 提供了更多的选择。</p>
<p>__gnu_pbds::priority_queue&lt;Typename,Compare,Tag&gt;</p>
<p>pb_ds 根据 Tag 参数的不同，支持五种类型的堆。</p>
<ul>
<li>pairing_heap_tag 配对堆。</li>
<li>binary_heap_tag 二叉堆。</li>
<li>binomial_heap_tag 二项堆。</li>
<li>rc_binomial_heap_tag 冗余计数二项堆。</li>
<li>thin_heap_tag 除了合并的复杂度都和 Fibonacci 堆一样。</li>
</ul>
<img src="/2024/01/19/STL%E7%9A%84%E4%BD%BF%E7%94%A8/1.png" class="" title="咕咕咕">

<h3 id="平衡树："><a href="#平衡树：" class="headerlink" title="平衡树："></a>平衡树：</h3><p>pb_ds 实现了三种类型的平衡树。</p>
<ul>
<li>rb_tree_tag 红黑树。</li>
<li>splay_tree_tag 伸展树。</li>
<li>ov_tree_tag 有序向量树。</li>
</ul>
<p>主要是和 STL 中 set 的比较。</p>
<p>pb_ds 更多地支持了：</p>
<ul>
<li>s.order_of_key(x)返回 s 中 x 的排名。</li>
<li>s.find_by_order(x)返回 s 中排名为 x 的元素。</li>
<li>s.join(S)把 S 合并到 s 中。</li>
<li>s.split(x,S)小于等于 x 的属于当前树，其余的属于 S 树。</li>
</ul>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>2023 XCPC 赛季总结</title>
    <url>/2024/01/20/2023-XCPC-%E8%B5%9B%E5%AD%A3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>随着 2023 EC final 的落幕。2023 年的最后一场 XCPC 比赛也结束了，也意味着 2023 赛季的完结。</p>
<p>~完结撒花！~</p>
<span id="more"></span>

<p>2023 年算是我大学算竞生涯的第一年。先来回顾一下，这一年我经历了哪些比赛，按时间先后：</p>
<ul>
<li>zstu 校赛</li>
<li>蓝桥杯 B 组省赛</li>
<li>天梯赛</li>
<li>浙江省赛</li>
<li>蓝桥杯 B 组国赛</li>
<li>ICPC 网络赛</li>
<li>CCPC 秦皇岛</li>
<li>ICPC 西安</li>
<li>ICPC 南京</li>
</ul>
<p>战绩：</p>
<ul>
<li>zstu 校赛 5th</li>
<li>蓝桥杯 B 组省赛 一等</li>
<li>天梯赛 个人三等，团队二等</li>
<li>浙江省赛 铜</li>
<li>蓝桥杯 B 组国赛 一等</li>
<li>ICPC 网络赛均 rank 650+</li>
<li>CCPC 秦皇岛 铜</li>
<li>ICPC 西安 银</li>
<li>ICPC 南京 银</li>
</ul>
<p>CF 1900 紫名。</p>
<p>AT 1500 青名。</p>
<p>总的来说，今年对我而言是较为满意的一年，如愿实现了 XCPC 银的目标。但是又是值得警惕的一年，因为这一年也说明我的水平亟待提高。对于 2024 年赛季 XCPC 金的目标还有很大差距。</p>
<p>先来逐个分析一波比赛表现。</p>
<p>校赛其实没什么好说的，耻辱折戟（校赛是大一大二的比赛，大三一般出题，大四退役老人，都不会凑热闹，还有部分大二做出题人，其实没什么竞争）。被一道价值维护分数的 meet in middle 卡死了（实际上可以不用维护分数）。本身是一道区分题，硬生生被我玩得把我自己区分下去了，导致另外两道简单题没做。</p>
<p>蓝桥杯省赛考得还算可以，校内第五。没想到蓝桥杯它最后一题考一个树上差分板子（是一点没改的原题）以为压轴弃了，以及被岛屿那题坑了。（心理欺骗自己是没发挥好 qwq）</p>
<p>天梯赛由于是固定分数线，导致今天题目明显比去年难，但是国三。只有后两题完全没写出来。还有一道锦标赛的题线段树维护却只得了部分分。不过校内第二。我校貌似没有国二（qwq）。</p>
<p>浙江省赛被拉去和学长组队了，虽然是第二次 XCPC 实战了，但还是几乎全程挂机（可能是没有日常联合训练导致的）我没有开出任何一道题，还浪费时间想假了几乎整场时间的一道金牌题。贡献是从头开题告诉队友 A 是签到题，以及帮队友验证了贪心&#x2F;背包那题的思路，还有写了份错误的交互题代码（思路），最后是帮队友看出了 dp 题的一个小 bug。最后 5 题罚时垫底铜。看了一眼有牌选手里最高 dirt（乐）。虽然赛后队友没有喷我，甚至还觉得我打的挺好（队长安慰的话语罢了），但我打心底感觉确实有拖后腿行为在。对不起我的队友，呜呜呜。</p>
<p>蓝桥杯国赛感觉打的不好，但可能毕竟相对别人更熟悉 OI 赛制，国赛校内第三。反倒是比省赛更好了。</p>
<p>暑假开始教练排了新队伍（看着是按上半年比赛表现分降序组队的，实际不清楚，感觉有教练独裁成分在，教练坚持“强强联合”）又是跟学长组队，但其实我感觉我的水平还不到能和学长组队的亚子。</p>
<p>暑假由于一些事情，没有参加 CCPC 网络赛，但是鉴于 2023 CCPC 网路赛的阴间程度，貌似打没打都差不多。</p>
<p>ICPC 的网络赛两场都出现一题人均过的题没过。第一场是那个两个圆的神秘期望题，第二场是那个字符串的神秘结论题。看的出来，我们队是真的不适合结论题。</p>
<p>选赛站时队长说想选几站早的，早打完早退役（两个学长队友都是最后一个赛季）。当时选了秦皇岛（因为最早，也好像是 CCPC 别的赛站被别的队选了）西安（因为队伍多）（本来说要杭州，但是当时没拿到外卡，名额不太够。虽然最后大概还是拿到了）南京不记得是为什么选的了。从结果上来看，并没有选“错”。</p>
<p>秦皇岛打还是可以的，开局很顺利，基本属于开了就会写了就过，队长甚至差几秒就抢到了全场一血，我也开出了我 XCPC 的第一题（看到 A 的构造很快就秒掉了）。前一个小时都在金牌区，实在超出预期。但是由于我 dp 那题虽然整体思路正确，但是没有考虑周全吃了三发罚时还写了好久，导致后期罚时烂掉了。可能也是因为前期太顺了，队友在我写的时候也没管我，去看另一道题了（写了之后他们发现也想假了），后面看着实在不行，就一起来帮我看 dp。队长写了一发就过了。封榜前都在银牌区，最后不出所料地掉出了银牌区。</p>
<p>复盘秦皇岛，就因为我写的太烂以及考虑不周，到手的银牌没了，狠狠地对不起我的队友。还看错了 C 题的题目（虽然就算看对了从结果来看我们也是写不出来），简直无地自容。所幸队友对我的包容性还是大的，没有怪罪于我。</p>
<p>来到西安，西安我又是零贡献的一场，全场没开出一道题。“签到题”完全不会，所幸队长数论扎实，还是开出来了。之后和队友讨论了锦标赛（和天梯赛那题类似）我还是没什么思路，只是帮队友验证，做一些辅助工作。不过最后的一个转折点——我和队友说 E 不会是随机吧，要不我们也随吧（因为我听到旁边队伍过了然后说是水题（原话说的“E才是签到吧”））。然后队长觉得行吧反正也没题了，随了几次 wa 了之后，我觉得没戏和另一个队友讨论那个 Lucas 的时候，队长说他过了。因为他直接跑完了 $n$ 次 $n^2$，而不是 rand 次，然后就过了（赛后证明这是水过去了）。之后开 F 队友推出了正确的 dp 式子，卡在那个乘法卷积那里（队内只有我会多项式相关）但是我赛场上表示 NTT 做加法卷积，乘法卷积怎么做啊？（赛后听到原根+NTT 瞬间清醒，事实上我暑假练过这个 trick 的题，原根将乘法卷积转换为加法卷积，但是，忘了）又是我背大锅。真的太多负贡献了。</p>
<p>所幸从结果上看还是好的。拿了银，也是队长的 ICPC 首牌，虽然是偷鸡行为。</p>
<p>南京的锅就不是那么大了，但感觉还是有。</p>
<p>南京整场节奏平缓，前 70 分钟开了四题，我写了 XCPC 生涯第二题，虽然有投机取巧在。C 题我打了个表后发现大致具有单调性，然后直接写了个二分，然而发现样例寄了，貌似不严格单调，但是想了一下队友提示宏观上还是单调的，只是相邻两个可能会不单调，然后我乱搞了一个：二分出结果后，往左 100，再往右 100 去掉不合法的，加上合法的。一发过了。之后我做了 2 个多小时的 M，得到一个很难写的，但赛后证明是对的一个线段树二分写法，最后也没有写出来。而我们又再现了网络赛不会一道人均会的题的情况——不会袋鼠题。但是最后凭借罚时优势，5 题垫底银。属于是秦皇岛的罚时南京补回来了。</p>
<p>XCPC 两银一铜，虽然充满遗憾，但也精彩，我们 2024 再见！</p>
<p>说起来，无论是西安还是南京，如果我西安过了 F，南京过了 M，我队都能拿到 EC final 的名额，可惜没有如果。回顾整个赛季，总觉得个人对队友的正贡献不如负贡献，整个 XCPC 的代码大都是队长写的。</p>
<p>在这里我非常感谢我的队友，无论是浙江省赛的队友还是区域赛的队友。非常感觉他们对我极大的包容，没有因为的负贡献而抛弃我。在我看到知乎上好多选手数落队友拖后腿的时候，我觉得我的队友对我是真的包容。从我对队伍的贡献上看，如果队友喷我我是无话可说的，全队码量最少，贡献最少，假做法最多。如果不是我，我的队友也许就能站上 EC final 的战场了吧。</p>
<p>最后再次感谢我的队友，如果没有他们，我无法取得如此的成绩。但也正因如此，我获得了与自身实力不大匹配的成绩，在 2024 年，我更需要加倍努力以对得起队友给我留下的牌子。</p>
<p>愿我的队友退役之后都能找到心仪的工作，考研都能上岸（省赛和区域赛四个队友都退役了）</p>
<p>个人总结：</p>
<p>从表现上来看，我大抵是没有区域赛银的水平（假设三个我打的情况下）但是区域赛铜的水平应是不成问题。代码能力是弱项，数据结构&#x2F;dp 题考虑不周，想对了却实现不了是我的问题。简单题做不快，思维题想不到是硬伤。在新的一年（2024）需要更加努力的刷题、vp（加训），从目标上看，距离 XCPC 金还有相当远的路要走。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/2024/01/20/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>贪心</p>
<span id="more"></span>

<p>贪心是一种思想，而不是一种具体的算法，没有固定的写法。</p>
<p>下面介绍几种贪心经典算法来引入贪心的思想。</p>
<p>贪心的熟练运用需要通过大量的做题自行提高。</p>
<p>贪心在算法竞赛中具有极广的应用，可以说 $50%$ 的题目都用到了贪心的思想。</p>
<h2 id="区间选点："><a href="#区间选点：" class="headerlink" title="区间选点："></a>区间选点：</h2><p>给定 $n$ 个区间 $[l_i,r_i]$，选择最少的点，使得每个区间内至少包含一个选出的点。（只关心数量）</p>
<p>将区间按 $l_i$ 为第一关键字升序，$r_i$ 为第二关键字降序排序。</p>
<p>考虑排序后的 $n$ 个区间，从第一个区间开始，用一个点覆盖尽可能多的区间，即：$l_i\leq r_1$ 的区间。从第一个满足 $l_i&gt;r_1$ 的区间开始，同样考虑。（实际上选的点就是 $r_1$）</p>
<h3 id="证明-1-："><a href="#证明-1-：" class="headerlink" title="证明 $1$："></a>证明 $1$：</h3><p>设最优解为 $ans$，上述解法求出为 $res$。</p>
<p>易得：$ans\leq res$。</p>
<p>对于 $res$ 个点，每一个点都需要用至少一个区间去覆盖，同时任意两个区间之间不会相交。因为如果相交，那么在上述算法过程中会被算在前一个区间上，不符合算法过程。即：$ans\geq res$。</p>
<p>综上：$ans&#x3D;res$。</p>
<h3 id="证明-2："><a href="#证明-2：" class="headerlink" title="证明 2："></a>证明 2：</h3><p>对于 $n$ 个区间，初始没有任何区间被覆盖，但最终所有点都会被覆盖。因此不妨选择第一个区间 $[l_1,r_1]$ 作为第一个被选的区间，考虑哪些区间是通过在 $[l_1,r_1]$ 中选择一个点就能被覆盖的：和 $[l_1,r_1]$ 有交集的区间：</p>
<ul>
<li>$l_i&lt;l_1,r_i\in [l_1,r_1]$</li>
<li>$[l_i,r_i]\subset [l_1,r_1]$ 覆盖 $[l_i,r_i]$ 一定会覆盖 $[l_1,r_1]$，所以可以去掉 $[l_1,r_1]$。</li>
<li>$r_i&gt;r_1,l_i\in[l_1,r_1]$</li>
</ul>
<p>第一类和第三类不能仅仅通过一个点覆盖，需要两个点，而区间 $[l_1,r_1]$ 被划为那一个点，是无法确定的。</p>
<p>同时，覆盖点的数量只和区间有关，而和顺序无关。所以，将区间排序，有序后，由于 $[l_1,r_1]$ 是最靠左的，所以 $[l_1,r_1]$ 不会面对第一类还是第三类的抉择，一定是第三类。往后一样考虑即可。</p>
<h2 id="最多不相交区间："><a href="#最多不相交区间：" class="headerlink" title="最多不相交区间："></a>最多不相交区间：</h2><p>给定 $n$ 个区间 $[l_i,r_i]$，选择最多的区间，使得任意区间之间不相交。（只关心数量）</p>
<p>将区间按 $r_i$ 升序。</p>
<p>考虑排序后的 $n$ 个区间，从第一个区间开始，尽可能多地选择区间。$l_i&gt;r_1$ 的区间。因为 $r_i\geq r_1,l_i\leq r_1$ 的区间和 $[l_1,r_1]$ 相交。</p>
<h3 id="证明-1："><a href="#证明-1：" class="headerlink" title="证明 1："></a>证明 1：</h3><p>设最优解为 $ans$，上述解法求出为 $res$。</p>
<p>易得：$ans\geq res$。</p>
<p>对于已经求出来的 $res$ 个区间，若存在第 $res+1$ 个区间满足不与其它任意区间相交，设这个区间为 $[L,R]$，则一定满足 $\exist\ r_i&lt;L\land R&lt;l_{i+1}$。而如果存在这样的区间 $[L,R]$ 在上述算法中一定是会被考虑到的，所以不存在这样的区间，即：$ans&lt;&#x3D;res$。</p>
<p>综上：$ans&#x3D;res$。</p>
<h3 id="证明-2：-1"><a href="#证明-2：-1" class="headerlink" title="证明 2："></a>证明 2：</h3><p>考虑选完的最终 $m$ 个区间，满足：$l$ 和 $r$ 分别严格单增。</p>
<p>同样地，考虑第一个区间，第一个区间的 $r$ 一定是最小的。若不是最小的，则换成 $r$ 最小的，并不会使答案变劣。后面的也同理，不会让答案变劣。因此将区间按 r 升序，这样得到的区间满足每次能取到的 $r$ 一定是最小的，只要考虑 $l$ 即可。</p>
<h3 id="addition："><a href="#addition：" class="headerlink" title="addition："></a>addition：</h3><p>其实可以发现：“区间选最少点”和“最多不相交区间”本质是相同的。（即：同一份代码即可以解决前者也可以解决后者）</p>
<p>因为区间选点中的点所覆盖的区间都是相交的，选择了其中之一就不能再选择其它区间。所以“一个点对应了一个区间”。选出的区间对应于选出的点。</p>
<h2 id="区间分组："><a href="#区间分组：" class="headerlink" title="区间分组："></a>区间分组：</h2><p>给定 $n$ 个区间 $[l_i,r_i]$，把区间分成最少的组，使得每组内的任意区间之间不相交。（只关心数量）</p>
<p>结合前文，在区间选点中，一个点对应的区间不能在一个组内。所以一个点对应的每个区间都对应了一个组。考虑这若干个组，在下一个点的若干个区间中，$l$ 最小的那个可以放进这若干个组中的任何一个，而放进 $r$ 最小的那个组最优。因为小的 $l$ 能放的组，大的也能放；而小的 $l$ 不能放的组当然也放不了。即：反之不优。若不能放到之前已有的组中，则新开一个组。</p>
<p>所以从前往后考虑每一个点，用优先队列维护每一个点对应的区间的 $r$ 的有序性。</p>
<p>最后的一个组对应一个优先队列。</p>
<h2 id="区间覆盖："><a href="#区间覆盖：" class="headerlink" title="区间覆盖："></a>区间覆盖：</h2><p>给定 $n$ 个区间 $[l_i,r_i]$，选择最少的区间覆盖 $[s,t]$。（只关心数量）</p>
<p>考虑第一个，覆盖 $[s,h]$（前缀）的一个区间。一定是满足 $l\leq s$ 的 $r$ 最大的一个区间。那么后续对 $(h,t]$ 同样处理就好了。</p>
<p>所以对 $n$ 个区间按 $l_i$ 为第一关键字升序，$r_i$ 为第二关键字升序排序。每次找到 $l_i\leq s$ 的最大 $r_i$ 即可。</p>
<h2 id="合并果子："><a href="#合并果子：" class="headerlink" title="合并果子："></a>合并果子：</h2><p>Huffman 树。</p>
<p>给定 $n$ 堆果子，每次可以花费两堆果子数目之和的代价合并两堆（会形成新的一堆）。求合并成 $1$ 堆的最小代价。</p>
<p>假设仅考虑选择两堆合并，那一定是果子数目最少的两堆。所以从直觉上讲，每次选择数量最少的两堆合并即可。</p>
<p>但是正向考虑每次操作不易理解，可以从“贡献”角度入手。考虑每一堆果子（初始的 $n$ 堆）被会被算几次。</p>
<p>考虑将果子合并的过程抽象成一棵二叉树：若合并 $x$ 号堆和 $y$ 号堆果子并形成一个 $z$ 号堆果子，则将 $z$ 号结点的左儿子设为 $x$，右儿子设为 $y$。</p>
<p>那么最后的代价就是：$\sum count_{叶子}\times dep_{叶子}$。</p>
<p>引理：数量最少的两堆果子堆一定是深度最大的。</p>
<p>显然。</p>
<p>如果深度最小的两堆不是最少的两堆，把最少的换过去答案一定更优。</p>
<p>而两个果子堆合并后形成了新的果子堆，这新的果子在后续的操作独立，后续操作同理即可。</p>
<p>根据数学归纳法，可得最后的 $\sum count_{叶子}\times dep_{叶子}$ 为最小值。</p>
<p>这一棵树就是 Huffman 树，也称最优二叉树。</p>
<h2 id="排队接水："><a href="#排队接水：" class="headerlink" title="排队接水："></a>排队接水：</h2><p>给定 $n$ 个人的接水时间 $t_i$，安排排队顺序使得所有人等待时间之和最小。</p>
<p>假设排队顺序为排列 $p_n$，令 $T_i&#x3D;\sum\limits_{j&#x3D;1}^i t_j$。求的即为：$\sum\limits_{i&#x3D;1}^nT_i$ 的最小值。同样考虑贡献，将式子变为：$\sum\limits_{i&#x3D;1}^n(n-i+1)t_{p_i}$。</p>
<p>$a_i&#x3D;n-i+1$ 为一个递减序列，$t_{P_i}$ 递增时 $\sum\limits_{i&#x3D;1}^n(n-i+1)t_{p_i}$ 最小。</p>
<p>这就是排序不等式：</p>
<ul>
<li>对于确定的两个序列 $a_n,b_n$，满足 $a_{p_i}$ 递增，$b_{q_i}$ 递减时 $\sum a_i\times b_i$ 取得最小。</li>
</ul>
<p>证明：</p>
<p>对于两个乱序序列 $a_n,b_n$，不妨考虑让 $a_n$ 升序。</p>
<p>若 $b_1$ 此时不是最大值，不妨令 $b_j&gt;b_1$。将 $b_j$ 和 $b_i$ 交换，做差，得新序列和原序列相差 $a_1\times b_j+a_j\times b_1-a_1\times b_1-a_j\times b_j&#x3D;a_1\times(b_j-b_1)+a_j\times(b_1-b_j)&#x3D;(b_j-b_1)(a_1-a_j)\leq0$</p>
<p>所以可以不断换最更大的，直到把最大值放到 $b_1$。对于后续 $2-n$ 同理。</p>
<h2 id="货仓选址："><a href="#货仓选址：" class="headerlink" title="货仓选址："></a>货仓选址：</h2><p>给定 $n$ 个商店的坐标 $a_i$，选定一个货仓 $x$，使得 $\sum\limits_{i&#x3D;1}^n|a_i-x|$ 最小。</p>
<p>不妨将 $a_i$ 升序，货仓的坐标即为 $a_{\lceil\frac n2\rceil}$。</p>
<p>引理 $1$：货仓的坐标为某个商店的坐标。</p>
<p>反证，若 $\forall a_i\neq x$，则 ${\exist} a_i&lt;x\land a_{i+1}&gt;x$，那么对于 $j&lt;i$ 和 $j&gt;{i+1}$ 答案不变。而对于 $a_i$ 和 $a_{i+1}$，货仓位置设置在哪事实上没有影响。所以不妨设为 $a_i$。因为这样就将待选位置缩小到 $n$ 个 $a_i$ 中。</p>
<p>此时，考虑特殊情况。</p>
<p>引理 $2$：$\sum\limits_{i&#x3D;1}^n|a_i-a_1|&gt;\sum\limits_{i&#x3D;1}^n|a_i-a_2|(n&gt;2)$。</p>
<p>展开：$\sum\limits_{i&#x3D;2}^na_i&gt;\sum\limits_{i&#x3D;3}^na_i-a_1$，易证。</p>
<p>所以，$x\neq a_1$。而对于 $x&#x3D;a_2$ 的情况，可以和 $x&#x3D;a_1$ 的情况同样考虑（在之后的过程中 $|a_1-x|+|a_n-x|&#x3D;a_n-a_1$ 为定值，所以可以消去）。</p>
<p>当 $n&#x3D;2$ 时，$x&#x3D;a_1$ 和 $x&#x3D;a_2$ 结果相等；或 $n&#x3D;1$ 时，$x&#x3D;a_1$。（取决于 $n$ 的奇偶性，因为每次去掉 $a_1$ 和 $a_n$ 两个位置）</p>
<h2 id="国王游戏："><a href="#国王游戏：" class="headerlink" title="国王游戏："></a>国王游戏：</h2><p>国王有 $n$ 个大臣，每个大臣左手有 $a_i$，右手有 $b_i$。每个大臣的得分是排在他前面的人的左手之积除以他的右手。国王的左手是 $a_0$，右手是 $b_0$，求一种排队顺序使得得分最大值最小。</p>
<p>考虑两个相邻的人谁在前面更优。$i$ 的得分：$\dfrac{\prod\limits_{j&#x3D;1}^{i-1}a_j}{b_i}$，$i+1$ 的得分：$\dfrac{\prod\limits_{j&#x3D;1}^{i}a_j}{b_{i+1}}$ 。</p>
<p>两者消去公共部分后分别为 $\dfrac{1}{b_i}$ 和 $\dfrac{a_i}{b_{i+1}}$。</p>
<p>如果交换，那么消去公共部分后分别为 $\dfrac{1}{b_{i+1}}$ 和 $\dfrac{a_{i+1}}{b_i}$。</p>
<p>注意到：$\dfrac{a_i}{b_{i+1}}&gt;\dfrac{1}{b_{i+1}},\dfrac{1}{b_i}&lt;\dfrac{a_{i+1}}{b_i}$。</p>
<p>若 $\dfrac{1}{b_i}&lt;\dfrac{a_i}{b_{i+1}}$，即：$a_i\times b_i&gt;b_{i+1}$，则交换后最大值只能是 $\dfrac{a_{i+1}}{b_i}$。</p>
<p>而如果交换更优，那么要满足 $\dfrac{a_i}{b_{i+1}}&gt;\dfrac{a_{i+1}}{b_i}$，即：$a_i\times b_i&gt;a_{i+1}\times b_{i+1}$。显然，满足这个条件的一定满足前置条件。</p>
<p>若 $\dfrac{1}{b_i}&gt;\dfrac{a_i}{b_{i+1}}$，即：$a_i\times b_i&lt;b_{i+1}$，则交换后的最大值就是 $\dfrac{a_{i+1}}{b_i}$ 且不更优。所以不需要交换。</p>
<p>所以将大臣们按照 $a_i\times b_i$ 的值升序排队即可。</p>
<p>为什么只要考虑相邻两个？</p>
<p>因为如果队伍不是按 $a_i\times b_i$ 有序的，那么就一定会有两个相邻的人满足 $a_i\times b_i&gt;a_{i+1}\times b_{i+1}$，而调整它，就会更优。所以一定会调整至 $\forall a_{i}\times b_i&lt;a_{i+1}\times b_{i+1}$。</p>
<h2 id="反悔贪心："><a href="#反悔贪心：" class="headerlink" title="反悔贪心："></a>反悔贪心：</h2><p>在一般贪心中，通常为得出一个策略，按照策略即可直接得到答案。而有的时候，结合以往的结果去对修正当前的决策也是可以的，但是从宏观上看，还是“贪心”的。对于这种贪心，一般被称为反悔贪心（也有说法细分为反悔堆和反悔自动机）。</p>
<h3 id="任务安排："><a href="#任务安排：" class="headerlink" title="任务安排："></a>任务安排：</h3><p>给定 $n$ 个任务，对于每个任务都有一个截止日期（$\leq 10^9$）和完成价值。从第一天开始，每天可以选择一个任务完成。求能获得的最大价值。</p>
<p>对于两个不同截止日期的任务，一定是先完成截止早的，显然。</p>
<p>对于两个相同截止日期的任务，一定是先完成价值大的，显然。</p>
<p>所以先将任务按截止日期升序，但是时间范围过大，不允许枚举模拟。</p>
<p>考虑反悔贪心：</p>
<p>若在某一天发现一个价值很大没有选择的任务，但是任务安排已经超过这天了。这时，我们反悔了。所以要去掉一个已经选择的中最小的一个，替换成这个价值大即可。</p>
<p>所以用一个优先队列维护已经选择的任务， 由于任务总数不大，所以最终时间复杂度为：$O(n\log n)$。</p>
<p>使用堆维护类似的过程，也被部分人称作反悔堆。</p>
<h3 id="种树："><a href="#种树：" class="headerlink" title="种树："></a>种树：</h3><p>共有 $n$ 个坑可以种树，且每个坑种树后能获利 $a_i$，但要求不能有两棵树相邻。求种 $k$ 棵树最大获利。</p>
<p>若无不能相邻的限制，则直接选取前 $k$ 大即可。</p>
<p>考虑有什么区别，不能相邻，每次有两种情况：</p>
<ul>
<li>在不相邻的位置中，选择一个最大值，贡献即为 $a_j$。</li>
<li>选择一个相邻的位置但是要把当前这棵树给挖掉，所以贡献为 $a_{i+1}-a_i$ 或者 $a_{i-1}-a_i$。可是如果 $a_{i+1}-a_i&gt;0$ 或者 $a_{i-1}-a_i&gt;0$ 的话，那么 $a_{i+1}$ 或者 $a_{i-1}$ 会在之前就被考虑，所以不能选择左右之一，只能是 $a_{i+1}+a_{i-1}-a_i&gt;0$ 即相邻的同时选。</li>
</ul>
<p>所以，每次贪心在未被选择的 $a_1,..,a_{i-2},a_{i+2},…,a_n$ 和 $a_{i+1}+a_{i-1}-a_i$ 中选择一个最大值。</p>
<p>若选择的是 $a_{i+1}+a_{i-1}-a_i$，那不能再选的是 $a_{i+2}$ 和 $a_{i-1}$。所以我们用一个新建节点来表示 $a_{i+1}+a_{i-1}-a_i$ 且用它来替代原本 $i$ 的位置，使用双向链表维护相邻元素，并标记相邻元素不能被选（如果同一个点被选三次，那么它本身的贡献会重新变成正的，此时便蕴含着反悔的含义）。</p>
<p>共选择 $k$ 次最大值。</p>
<p>上述过程也被部分人称之为反悔自动机。</p>
]]></content>
      <categories>
        <category>贪心</category>
      </categories>
  </entry>
  <entry>
    <title>DP（一）</title>
    <url>/2024/01/24/DP%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>线性 DP</p>
<span id="more"></span>

<p>笔者认为，DP 也是一种思想，是一种以空间换时间的思想。</p>
<p>DP 一般存在三种实现方式：</p>
<ul>
<li>记忆化搜索</li>
<li>拓扑排序</li>
<li>扫表</li>
</ul>
<p>三种实现方式各有一定的优劣，将在后文中分析。</p>
<p>DP 从形式上分为三部分：</p>
<ul>
<li>状态</li>
<li>状态转移</li>
<li>初始化</li>
</ul>
<p>其中实现状态转移的式子常被称为状态转移方程。</p>
<p>而转移的方式，也在部分场景下被细分为“顺推”和“逆推”。</p>
<p>“顺推”为用当前状态去更新可以转移到的状态，为“到哪去”。</p>
<p>“逆推”为用可以转移到的状态来更新当前状态，为“从哪来”。</p>
<p>“顺推”和“逆推”在部分情况下有优劣，但一般无影响，将在后文考虑。</p>
<p>DP 转移时需要保证用来转移的状态是已经正确的。</p>
<p>DP 的时间复杂度为 $O(状态数\times 转移时间)$。</p>
<p>本文将介绍若干 DP 入门例题帮助 DP 思维的建立。</p>
<p>线性 DP 是指在线性结构上进行转移。在实际问题中，一般在序列上和矩阵上考虑较多。</p>
<h2 id="矩阵-DP："><a href="#矩阵-DP：" class="headerlink" title="矩阵 DP："></a>矩阵 DP：</h2><p>$[IOI1994]$ 第一次在算法竞赛引入了动态规划的思想。</p>
<p>例 $1$：</p>
<p>给定一个 $n$ 层的数字三角形每次可以从 $(x,y)$ 走到 $(x+1,y),(x+1,y+1)$，求从 $(1,1)$ 出发经过路径上数字之和的最大值。</p>
<p>状态：</p>
<p>设 dp$[x][y]$ 为从起点到 $(x,y)$ 的答案。</p>
<p>状态转移：</p>
<p>$(x,y)\rightarrow(x+1,y),(x+1,y+1)$</p>
<p>$(x,y)\leftarrow(x-1,y),(x-1,y-1)$</p>
<p>所以写出 DP 式子：</p>
<ul>
<li>顺推：<code>dp[x+1][y]=max(dp[x][y]+a[x+1][y],dp[x+1][y]),dp[x+1][y+1]=max(dp[x][y]+a[x+1][y+1],dp[x+1][y+1])</code></li>
<li>逆推：<code>dp[x][y]=max(dp[x-1][y],dp[x-1][y-1])+a[x][y]</code></li>
</ul>
<p>在一般的 DP 问题中，普遍采用扫表的方式实现 DP。扫表即使用循环枚举状态，所以对于扫表法来说，枚举的顺序很重要。</p>
<p>此题中因为每一层的状态一定是在相邻的两层之间转移，所以按层枚举，而层内的顺序则不影响。</p>
<p>初始化：</p>
<p>从 $(1,1)$ 开始，所以可以将 $(1,1)$ 设为初始状态，初始化 dp$[1][1]&#x3D;a[1][1]$，后从第二层开始枚举。同时因为求的是极大值，所以要将 dp 数组初始化为极小值。</p>
<p>最后的解即为 dp$[n][n]$。</p>
<p>时间复杂度：$O(n^2)$。</p>
<p>空间复杂度：$O(n^2)$。</p>
<p>DP 空间换时间，所以空间复杂度普遍偏高，内存超限也多出现在 DP 问题中。</p>
<h2 id="序列-DP："><a href="#序列-DP：" class="headerlink" title="序列 DP："></a>序列 DP：</h2><p>例 2：</p>
<p>给定一个长度为 $n$ 的序列 $a_i$，求最长上升子序列。</p>
<p>状态：</p>
<p>设 dp$[i]$ 为以 $a_i$ 结尾的最长上升子序列长度。</p>
<p>状态转移：</p>
<p>$(i)\rightarrow (j)(a_j&gt;a_i)$</p>
<p>$(i)\leftarrow(j)(a_j&lt;a_i)$</p>
<p>这里一个小区别就是转移的状态不确定了，不是固定的。</p>
<p>所以需要去枚举转移：</p>
<ul>
<li>顺推：<code>For(j,i+1,n) if(a[j]&gt;a[i]) dp[j]=max(dp[j],dp[i]+1)</code></li>
<li>逆推：<code>For(j,1,i-1) if(a[j]&lt;a[i]) dp[i]=max(dp[i],dp[j]+1)</code></li>
</ul>
<p>初始化：</p>
<p>每一个位置本身可以是最长上升子序列的开始，所以可以将 $(1),…,(n)$ 都初始化为 $1$ 以作为初始状态。</p>
<p>在序列上，每一个位置的答案一定是由它之前的转移过来，所以按顺序枚举即可。</p>
<p>最后的解即为：dp$[n]$。</p>
<p>时间复杂度：$O(n^2)$。</p>
<p>空间复杂度：$O(n)$。</p>
<p>事实上，此处的 DP 转移可以优化做到 $O(n\log n)$ 的时间复杂度，将在之后的文章提到。</p>
<p>总结以上两个例子，矩阵中进行 DP，往往设 dp$[x][y]$ 表示从起点到 (x,y) 的答案；序列中进行 DP，往往设 dp$[x]$ 表示从 $1$ 到 $x$ 的答案。在具体的题目中，也会有相应的扩展。</p>
<h2 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h2><h3 id="DP-和-贪心："><a href="#DP-和-贪心：" class="headerlink" title="DP 和 贪心："></a>DP 和 贪心：</h3><p>DP 和贪心都是一种思想，它们之间没有明确的界限。可以说贪心是一种特殊的 DP，也可以认为 DP 是一种特殊的贪心，自行理解即可。</p>
<p>考虑下面一个问题：</p>
<p>例 3：</p>
<p>求用面值 $1,3,5$ 分的硬币支付 $x$ 分钱的最少硬币数量。 </p>
<p>考虑贪心：优先使用 $5$ 分，直到不能用 $5$ 分后再用 $3$ 分，最后用 $1$ 分。</p>
<p>证明：</p>
<p>引理：最后的硬币方案，一定最多 $1$ 个 $3$ 或者 $2$ 个 $1$。</p>
<p>反证。若存在 $2$ 个 $3$，则可以替换成 $1$ 个 $1$ 和 $1$ 个 $5$ 不会更劣。</p>
<p>若有 $3$ 个 $1$，则可能替换成 $1$ 个 $3$，更优。</p>
<p>也就是说用 $1$ 和 $3$ 只能支付小于 $5$ 的面额。而优先使用 $5$ 之后，剩下的只能是 $0,1,2,3,4$，分别考虑也可证明策略的正确性。</p>
<p>例 4：</p>
<p>求用面值 $2,4,5$ 分的硬币支付 $x$ 分钱的最少硬币数量，或判断无解。</p>
<p>此时，贪心显然错误。考虑 $x&#x3D;6$ 时，贪心策略无解。</p>
<p>考虑 DP。</p>
<p>状态：</p>
<p>设 dp$[x]$ 表示支付 $x$ 分钱的最少硬币数量。</p>
<p>状态转移：</p>
<ul>
<li>$(x)\rightarrow (x+2),(x+4),(x+5)$</li>
<li>$(x)\leftarrow(x-2),(x-4),(x-5)$</li>
</ul>
<p>所以写出 DP 式子：</p>
<ul>
<li>顺推：<code>dp[x+2]=max(dp[x+2],dp[x]+1),dp[x+4]=max(dp[x+4],dp[x]+1),dp[x+5]=max(dp[x+5],dp[x]+1)</code></li>
<li>逆推：<code>dp[x]=max(dp[x-2],dp[x-4],dp[x-5])+1</code></li>
</ul>
<p>初始化：</p>
<p>初始情况下没有任何硬币，所以应该选择 $(0)$ 作为初始状态并初始化 dp$[0]&#x3D;0$。同时要注意无解的情况。所以要特殊处理无解，一般可以之间置为极大值（求解最小值）或者极小值（求解最大值）。</p>
<p>容易发现，大金额的状态是由小金额的状态转移的，所以从小到大枚举金额即可。</p>
<p>最后的解即为：dp$[x]$。</p>
<p>Tips：在后续的内容，为了避免不必要的内容，除非必要，将统一使用逆推。 </p>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
  </entry>
  <entry>
    <title>DP（七）</title>
    <url>/2024/01/24/DP%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（三）</title>
    <url>/2024/01/24/DP%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>状压 DP</p>
<span id="more"></span>

<p>状压 DP，全称状态压缩 DP。是通过将状态以二进制形式压缩成一个整数来达到优化转移的目的。</p>
<h2 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h2><p>例 $1$：</p>
<p>给定 $10$ 个整数，求取出 $3$ 个整数的异或和的最大值。</p>
<p>考虑到每个整数都有选&#x2F;不选两种选择，因为可以将 $10$ 个整数的选择情况写成一个 $01$ 串，例如：$0100101000$ 表示选第 $4,6,9$ 个整数，不选第 $1,2,3,5,7,8,10$ 个整数。</p>
<p>而这个 $01$ 串，可以看成一个整数的二进制表示，例如 $0100101000$ 就可表示为：$296$。</p>
<p>因此，枚举 $[0,2^{10})$，对于仅有 $3$ 个 $1$ 的状态计算答案即可。</p>
<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><p>位运算符：</p>
<ul>
<li>$\And$：与，$a\And b&#x3D;\begin{cases}1&amp;a&#x3D;1\land b&#x3D;1\0&amp;else\end{cases}$</li>
<li>$|$：或，$a|b&#x3D;\begin{cases}1&amp;a&#x3D;1\lor b&#x3D;1\0&amp;else\end{cases}$</li>
<li>$\oplus$：异或，$a\oplus b&#x3D;\begin{cases}1&amp;a\neq b\0&amp;else\end{cases}$（事实上，$\oplus$ 表示二元运算符，算法竞赛中一般用 $\oplus$ 作为异或）</li>
<li>$\sim$：取反,$\sim a&#x3D;\begin{cases}1&amp;a&#x3D;0\0&amp;a&#x3D;1\end{cases}$</li>
<li>$&lt;&lt;$：左移，$a&lt;&lt;x&#x3D;a\times 2^x$</li>
<li>$&gt;&gt;$：右移，$a&gt;&gt;x&#x3D;\lfloor\frac{a}{2^x}\rfloor$</li>
</ul>
<p>基础位运算：</p>
<p>（第 $i$ 位均指从低位到高位）</p>
<ul>
<li>取出二进制数第 $i$ 位：$x\And(1&lt;&lt;(i-1))$</li>
<li>去掉二进制数第 $i$ 位：$x\oplus(1&lt;&lt;(i-1))$</li>
<li>交集：$a\And b$</li>
<li>并集：$a|b$</li>
<li>补集：$a\oplus b$</li>
<li>子集：$a\And b&#x3D;a$，$a$ 是 $b$ 的子集。</li>
</ul>
<h2 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h2><p>状压 DP 的思想是用二进制数表示事物的选&#x2F;不选两种状态，而通过位运算达到简化代码、便于实现的目的。</p>
<h3 id="旅行商问题："><a href="#旅行商问题：" class="headerlink" title="旅行商问题："></a>旅行商问题：</h3><p>例 $2$：</p>
<p>房间里放着 $n(n\leq 15)$ 块奶酪，一只小老鼠位于 $(0,0)$ 要把它们都吃掉，问至少要跑多少距离？</p>
<p>用 $0&#x2F;1$ 表示某一块奶酪是否被吃，最后的结果就是所有的奶酪被吃。但是在转移时，两个状态之间的增量，在于两个奶酪之间距离，所以要知道某个状态所代表的路径上最后一个奶酪是那一个。因此，除了表示吃哪些奶酪的二进制数，还有加一维表示最后一个奶酪的状态。</p>
<p>状态：</p>
<p>设 dp$[x][y]$ 表示奶酪被吃的情况为 $x$，且最后一个吃的是第 $y$ 块奶酪的最短路径。</p>
<p>转移：</p>
<p>$(x,y)\leftarrow(x^{1&lt;&lt;(y-1)},z)(x\And(1&lt;&lt;(z-1))\neq0)$</p>
<p>DP 式子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(j,<span class="number">1</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">For</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))</span><br><span class="line">        <span class="built_in">FOR</span>(k,<span class="number">1</span>,n)</span><br><span class="line">            <span class="keyword">if</span>(i==k) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&amp;(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>)))</span><br><span class="line">            f[i][j]=<span class="built_in">min</span>(f[i][j],f[k][j^(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]+dis[k][i]);</span><br></pre></td></tr></table></figure>

<p>初始化：</p>
<p>完全没有吃奶酪时，不好处理“最后一个吃的奶酪”，所以可以初始化只吃了一个奶酪的状态。</p>
<p>时间复杂度：$O(n^22^n)$。</p>
<p>空间复杂度：$O(n2^n)$。</p>
<h3 id="合法状态预处理："><a href="#合法状态预处理：" class="headerlink" title="合法状态预处理："></a>合法状态预处理：</h3><p>例 $3$：</p>
<p>在一个 $n\times m(n\leq 10,m\leq10^3)$ 的方格图中，要求选择的任意两个方格之间没有重合的边。求总共有多少种选法。</p>
<p>通常按行处理，行列转置不影响。</p>
<p>一行的方格只会影响到与它相邻的两行，某一行的状态仅需要上一行的状态就可以转移。所以按顺序枚举行，分别枚举上一行和当前行的状态转移。</p>
<p>状态：</p>
<p>设 dp$[i][x]$ 表示前 $i$ 行且第 $i$ 状态为 $x$ 的方案数。</p>
<p>转移：</p>
<p>$(i,x)\leftarrow(i-1,y)$ $x,y$ 之间没有重合的边。</p>
<p>DP 式子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	<span class="built_in">For</span>(j,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)</span><br><span class="line">		<span class="built_in">For</span>(k,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;m)<span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">if</span>(j&amp;k==<span class="number">0</span>&amp;&amp;(j&lt;&lt;<span class="number">1</span>)&amp;j==<span class="number">0</span>&amp;&amp;(k&lt;&lt;<span class="number">1</span>)&amp;k==<span class="number">0</span>)</span><br><span class="line">				dp[i][j]+=dp[i<span class="number">-1</span>][k];</span><br></pre></td></tr></table></figure>

<p>初始化：</p>
<p>第 $0$ 行状态只能为 $0$，初始化 dp$[0][0]&#x3D;1$。</p>
<p>时间复杂度：$O(n4^n)$。</p>
<p>空间复杂度：$O(n2^n)$。</p>
<p>优化：</p>
<p>其一，考虑到，行内状态独立，所以可以预处理行内的合法状态，而不是在每层循环中都枚举一遍所有状态。</p>
<p>其二，对于一个确定的行状态，其下一行的状态集合也是确定的，所以还可以对于每一个行内合法状态，预处理出它的对应的下一行状态集合。</p>
<p>设每一个行内合法对应的下一行状态集合为 $g$，则优化后的时间复杂度为：$O(n\sum|g(x)|)$。</p>
<p>而且，由于状态只和相邻的两行有关，所以状态的第一维可以滚掉。空间复杂度优化至线性。</p>
<h3 id="子集枚举："><a href="#子集枚举：" class="headerlink" title="子集枚举："></a>子集枚举：</h3><p>例 $4$：</p>
<p>有 $n(n\leq16)$ 个人需要过桥，第 $i$ 个人的重量为 $w_i$，过桥用时为 $t_i$，这些人过桥时会被分成若干组，只有某一组的所有人全部过桥后，其余的组才能过桥。桥最大承重为 $W$，求这些人全部过桥的最短用时。</p>
<p>和例 $2$ 的区别在于此处每次不止能选择一个人，此处需要枚举一组的人，即：不是一个二进制位，而是一个二进制数。</p>
<p>其它部分相差不大。</p>
<p>状态：</p>
<p>设 dp$[x]$ 表示人是否过桥的状态为 $x$ 的最短用时。</p>
<p>转移：</p>
<p>$(x)\leftarrow(y)$ $y\And x&#x3D;x\land w(x\oplus y)\leq W$。</p>
<p>DP 式子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)</span><br><span class="line">	<span class="built_in">For</span>(j,<span class="number">0</span>,i<span class="number">-1</span>)</span><br><span class="line">		<span class="keyword">if</span>(j&amp;i==x&amp;&amp;<span class="built_in">w</span>(i^j)&lt;=W)</span><br><span class="line">			dp[i]=<span class="built_in">min</span>(dp[i],dp[j]+<span class="built_in">t</span>(i^j));</span><br></pre></td></tr></table></figure>

<p>每一种状态的过桥时间和过桥体重可以预处理。</p>
<p>时间复杂度：$O(4^n)$。</p>
<p>空间复杂度：$O(2^n)$。</p>
<p>优化：</p>
<p>其一，使用例 $3$ 的方法，可以过桥的组是独立判断的，所以可以预处理哪些状态是可以过桥的，后枚举判断是否是子集。但此题是否可以过桥不像例 $3$ 那样的限制是固定的，所以在极端情况下并没有优化。</p>
<p>其二，预处理子集。考虑其时间复杂度，即：计算所有集合的子集大小之和，为 $O(3^n)$。</p>
<p>证明：</p>
<p>若一个状态有 $i$ 个 $1$，则其子集规模为 $O(2^i)$，考虑所有状态的 $1$ 的个数：$\sum\limits_{i&#x3D;0}^n\binom{n}{i}\times 2^i\times 1^{n-i}&#x3D;3^n$。</p>
<p>枚举方式：</p>
<p>枚举 $i$ 的子集，<code>for(j=i;j;j=i&amp;(j-1))</code></p>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
  </entry>
  <entry>
    <title>DP（九）</title>
    <url>/2024/01/24/DP%EF%BC%88%E4%B9%9D%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（二）</title>
    <url>/2024/01/24/DP%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>背包 DP</p>
<span id="more"></span>

<p>背包 DP，正如它的名字，是将问题模型抽象成一个背包，背包有容量，物品拥有体积和价值，要将物品按照一定的限制放入这个背包，从而求解一系列问题。</p>
<h2 id="01-背包："><a href="#01-背包：" class="headerlink" title="01 背包："></a>01 背包：</h2><p>例 $1$：</p>
<p>有一个容量为 $V$ 的背包有 $n$ 种物品，每种物品有 $v_i$ 的体积和 $w_i$ 的价值，每种物品最多取一个，求能获得的最大价值。</p>
<p>状态：</p>
<p>设 dp$[i][j]$ 表示考虑前 $i$ 个物品，选出物品体积为 $j$ 的最大价值。</p>
<p>状态转移：</p>
<p>$(i,j)\leftarrow(i-1,j-v_i),(i-1,j)$</p>
<p>DP 式子：</p>
<p><code>For(i,1,n) For(j,v[i],V) dp[i][j]=max(dp[i-1][j],dp[i-1][j-v[i]]+w[i])</code></p>
<p>最后的解即为：dp$[n][V]$。</p>
<p>某一个物品的答案一定是从前面的物品转移来的，而当前的容量之间没有转移关系，所以容量的枚举顺序无影响。</p>
<p>时间复杂度：$O(nV)$</p>
<p>空间复杂度：$O(nV)$</p>
<h3 id="滚动数组优化："><a href="#滚动数组优化：" class="headerlink" title="滚动数组优化："></a>滚动数组优化：</h3><p>观察到，dp$[i]$ 只与 dp$[i-1]$ 有关，而与 dp$[1],…,$dp$[i-2]$ 无关，同时最后的结果只和 dp$[n][V]$ 有关。也就是同时最多只需要用到两组 dp 数组的第二维，所以 dp 第一维只需要存两个即可。</p>
<p>通常使用 dp$[i\And 1]$ 的方式仅保留 $i$ 和 $i-1$ 的结果。</p>
<p>最后的解即为：dp$[n\And1][V]$。</p>
<p>空间复杂度优化至线性。</p>
<h4 id="在此题的特殊处理："><a href="#在此题的特殊处理：" class="headerlink" title="在此题的特殊处理："></a>在此题的特殊处理：</h4><p>继续观察，dp$[i][j]$ 会继承 dp$[i-1][j]$ 的答案，即：dp$[i][j]\geq$dp$[i-1][j]$。</p>
<p>所以不妨直接让 dp$[i][j]$ 继承 dp$[i-1][j]$ 的答案（直接共用一个数组）。</p>
<p>新 DP 式子：</p>
<p><code>For(i,1,n) For(j,v[i],V) dp[j]=max(dp[j],dp[j-v[i]]+w[i])</code></p>
<p>但是此时会产生新的问题：dp$[j-v[i]]$ 可能是会被修改的，而原式子中的 dp$[i-1][j-v[i]]$ 是固定的，现在的 dp$[j-v[i]]$ 不一一对应 dp$[i-1][j-v[i]]$，它可以从 $dp[j-2\times v[i]]$ 转移。而 dp$[i][j]$ 只能由 dp$[i-1][j-v[i]]$ 转移而不是 dp$[i-1][j-2\times v[i]]$。</p>
<p>通过改变枚举顺序可以避免这一点：</p>
<p><code>For(i,1,n) FOR(j,V,v[i]) dp[j]=max(dp[j],dp[j-v[i]]+w[i])</code></p>
<p>从后往前枚举容量时，保证了用于转移的状态是上一层循环记录的正确的值。</p>
<h2 id="完全背包："><a href="#完全背包：" class="headerlink" title="完全背包："></a>完全背包：</h2><p>例 $2$：</p>
<p>有一个容量为 $V$ 的背包有 $n$ 种物品，每种物品有 $v_i$ 的体积和 $w_i$ 的价值，每种物品取的个数没有限制，求能获得的最大价值。</p>
<p>状态：</p>
<p>设 dp$[j]$ 表示选出物品体积为 $j$ 的最大价值。</p>
<p>状态转移：</p>
<p>$(j)\leftarrow(j-\lfloor\frac{j}{v_i}\rfloor\times v_i),…,(j-v_i),(j)$</p>
<p>DP 式子：</p>
<p><code>For(i,1,n) FOR(j,V,1) For(k,0,j/v[i]) dp[j]=max(dp[j],dp[j-k*v[i]]+k*w[i])</code></p>
<p>最后的解即为：dp$[V]$。</p>
<p>枚举顺序与 01 背包一致，仅仅是转移的状态数不同，转移关系一致。</p>
<p>时间复杂度：$O(nV^2)$。</p>
<p>空间复杂度：$O(V)$</p>
<h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>显然，$O(nV^2)$ 是不够优秀的，回顾 01 背包中遇到的问题，从前往后枚举容量时，更新的状态不对应：dp$[j-v[i]]$ 不一一对应 dp$[i-1][j-v[i]]$，它可以从 $dp[j-2\times v[i]]$ 转移。而如果将这个结果递归下去，可以发现，dp$[j]$ 正是从 $(j-\lfloor\frac{j}{v_i}\rfloor\times v_i),…,(j-v_i),(j)$ 这样状态转移，这恰好地符合完全背包的要求。</p>
<p>所以，从后往前枚举容量即可实现完全背包的要求，而不用枚举使用量。</p>
<p>新 DP 式子：</p>
<p><code>For(i,1,n) For(j,v[i],V) dp[j]=max(dp[j],dp[j-v[i]]+w[i])</code></p>
<p>时间复杂度：$O(nV)$。</p>
<h2 id="多重背包："><a href="#多重背包：" class="headerlink" title="多重背包："></a>多重背包：</h2><p>例 3：</p>
<p>有一个容量为 $V$ 的背包有 $n$ 种物品，每种物品有 $v_i$ 的体积和 $w_i$ 的价值，每种物品取的个数为 $a_i$，求能获得的最大价值。</p>
<p>状态：</p>
<p>设 dp$[j]$ 表示选出物品体积为 $j$ 的最大价值。</p>
<p>状态转移：</p>
<p>$(j)\leftarrow(j-a_i\times v_i),…,(j-v_i),(j)$</p>
<p>DP 式子：</p>
<p><code>For(i,1,n) FOR(j,V,1) For(k,0,min(j/v[i],a[i])) dp[j]=max(dp[j],dp[j-k*v[i]]+k*w[i])</code></p>
<p>时间复杂度：$O(nVa_i)$。</p>
<p>空间复杂度：$O(n)$。</p>
<h3 id="二进制拆分优化："><a href="#二进制拆分优化：" class="headerlink" title="二进制拆分优化："></a>二进制拆分优化：</h3><p>考虑最后的最优的方案中某物品的选取个数，设为 $x$。若这个物品取 $x$ 是最优，那么只要这个物品能取 $x$ 个就能保证最后解正确。那么，就算这个物品原本是可以取 $2x$ 个的，现在把它取的个数限制成 $x$ 个即可。</p>
<p>可是并无法获知每个物品在最终的答案里是被取几次的。</p>
<p>考虑 $a_i&#x3D;2^0+2^1+…+2^p+(a_i-2^{p+1}+1)$，将原本可以取 $[0,a_i]$ 次的第 $i$ 个物品，拆分成 $\log{a_i}$ 个固定取 $2^0,2^1,..,2^p,(a_i-2^{p+1}+1)$ 的物品。</p>
<p>引理：用 $2^0,2^1,..,2^p,(a_i-2^{p+1}+1)$ 可以组成 $[1,a_i]$ 之间的任何数。</p>
<p>证明：</p>
<p>用 $2^0,2^1,…,2^p$ 可以组成 $[1,2^{p+1}-1]$ 的任何数。</p>
<p>$[2^{p+1},a_i]$ 之间的数可以用 $a_i-2^{p+1}+1$ 和 $[1,2^{p+1}-1]$ 对应组成。</p>
<p>所以原本一个物品有 $O(a_i)$ 的转移量，而现在只有 $O(\log a_i)$ 的转移量。</p>
<p>时间复杂度：$O(nV\log a_i)$。</p>
<h3 id="单调队列优化："><a href="#单调队列优化：" class="headerlink" title="单调队列优化："></a>单调队列优化：</h3><p>对于一个转移，其转移个数是确定是 $a_i$ 个。在容量从小到大枚举的过程中，转移的下界也在增大，且转移的个数是确定的，前后两次容量的转移区间仅有头尾不同。这是一种特殊的“滑动窗口”，可以套用单调队列优化 DP 的方式优化多重背包。</p>
<p>$(j)\leftarrow(j-a_i\times v_i),…,(j-v_i),(j)$</p>
<p>$(j+v_i)\leftarrow(j-(a_i-1)\times v_i),…,(j),(j+v_i)$</p>
<p>对于 $(j-(a_i-1)\times v_i),…,(j)$ 部分是一样的，只有 $(j-a_i\times v_i)$ 和 $(j+v_i)$ 是不一样的。</p>
<p>具体不作展开。</p>
<p>时间复杂度：$O(nV)$。</p>
<h2 id="01-背包-完全背包-多重背包："><a href="#01-背包-完全背包-多重背包：" class="headerlink" title="01 背包+完全背包+多重背包："></a>01 背包+完全背包+多重背包：</h2><p>例 4：</p>
<p>有一个容量为 $V$ 的背包有 $n$ 种物品，每种物品有 $v_i$ 的体积和 $w_i$ 的价值，每种物品有一个类型 $op$，$op&#x3D;1$ 表示最多取 $1$ 次；$op&#x3D;2$ 表示可以取无限次；$op&#x3D;3$ 表示最多取 $a_i$ 次，求能获得的最大价值。</p>
<p>事实上，注意到它们之间仅仅是转移的时候，用到的状态数不太一样。所以只需要根据不同的物品的类型，进行不同的处理转移即可。</p>
<p>时间复杂度：$O(nV)$。</p>
<p>空间复杂度：$O(V)$。</p>
<h3 id="addition："><a href="#addition：" class="headerlink" title="addition："></a>addition：</h3><p>注意到，上述 DP 过程均使用的是“逆推”，优化也基本基于“逆推”才能进行，如果使用“顺推”不易优化。</p>
<p>原因就是“逆推”给定了“从哪来”的范围，每次只更新当前的状态。如果能比较快地在“从哪来”选择出那个最优的，就可以加快运算速度。对于“顺推”，需要用当前状态去更新多个状态，对于区间修改，是不易维护的（可以，较复杂，对应数据结构的区间修改）。</p>
<h2 id="多维背包："><a href="#多维背包：" class="headerlink" title="多维背包："></a>多维背包：</h2><p>例 5：</p>
<p>有 $n$ 个任务需要完成，完成第 $i$ 个任务需要花费 $t_i$ 分钟，$c_i$ 的支出。共有 $T$ 的时间和 $C$ 的资金，求最多完成多少任务。</p>
<p>与前文中的背包相比，此背包具有二维代价，而不是一维。</p>
<p>因此需要两层循环枚举容量，其它地方并无二致。</p>
<p><code>For(i,1,n) FOR(j,T,t[i]) FOR(k,C,c[i]) dp[j][k]=max(dp[j][k],dp[j-t[i]][k-c[i]]+1)</code></p>
<p>时间复杂度：$O(nTC)$。</p>
<p>空间复杂度：$O(TC)$。</p>
<h2 id="分组背包："><a href="#分组背包：" class="headerlink" title="分组背包："></a>分组背包：</h2><p>例 6：</p>
<p>有一个容量为 $V$ 的背包有 $n$ 种物品，每种物品有 $v_i$ 的体积和 $w_i$ 的价值，每种物品最多取一个，同时每个物品都属于一个组 $c_i$，一个组内只能选择一个物品。求能获得的最大价值。</p>
<p>同样是转移的方式不同。因为现在的物品是组内选一个，而组间无关。</p>
<p>转移：</p>
<p>$(j)\leftarrow(j-a_{p_1}),(j-a_{p_2}),…,(j-a_{p_c}),(j)$</p>
<p>由组内的任意一个转移。</p>
<p>DP 式子：</p>
<p><code>For(i,1,n) FOR(j,V,1) For(j,1,cnt[c[i]]) dp[j]=max(dp[j],dp[j-v[p[j]]]+w[p[j]])</code></p>
<p>因为所有组内的物品数之和还是 $n$，所以时间复杂度不变。</p>
<p>时间复杂度：$O(nV)$。</p>
<p>空间复杂度：$O(V)$。</p>
<h2 id="背包判可行："><a href="#背包判可行：" class="headerlink" title="背包判可行："></a>背包判可行：</h2><p>例 7：</p>
<p>有一个容量为 $V$ 的背包有 $n$ 种物品，每种物品有 $v_i$ 的体积，每种物品最多取一个，求是否能取出体积之和为 $m$ 的物品。</p>
<p>状态转移与 01 背包一致，需要修改维护的内容。</p>
<p>状态：</p>
<p>设 dp$[x]$ 表示是否能取出体积之和为 $x$ 的物品。</p>
<p>状态转移：</p>
<p>$(x)\leftarrow(x-v_i)$</p>
<p>DP 式子：</p>
<p><code>For(i,1,n) FOR(j,V,v[i]) dp[j]|=dp[j-v[i]]</code></p>
<p>初始化：</p>
<p>初始只有 $0$，dp$[0]&#x3D;1$ 即可。</p>
<p>时间复杂度：$O(nV)$。</p>
<p>空间复杂度：$O(V)$。</p>
<h3 id="bitset-优化："><a href="#bitset-优化：" class="headerlink" title="bitset 优化："></a>bitset 优化：</h3><p>因为结果只含 $0&#x2F;1$，容易联想到 bitset。</p>
<p>每一层物品的循环，$v_i$ 是固定的，所以相当于把 dp$[x]$ 整体右移了 $v_i$。</p>
<p>新 DP 式子：</p>
<p><code>For(i,1,n) temp=dp&lt;&lt;v[i],dp|=temp</code></p>
<p>对 bitset 整体操作的时间复杂度为 $O(\frac{n}{\omega})$。</p>
<p>时间复杂度：$O(\frac{nV}{\omega})$。</p>
<p>空间复杂度：$O(\frac{V}{\omega})$。</p>
<h2 id="背包求方案数："><a href="#背包求方案数：" class="headerlink" title="背包求方案数："></a>背包求方案数：</h2><p>例 8：</p>
<p>有一个容量为 $V$ 的背包有 $n$ 种物品，每种物品有 $v_i$ 的体积，每种物品最多取一个，求取出体积之和为 $m$ 的物品的方案数。</p>
<p>同样是状态转移与 01 背包一致，需要修改维护的内容。</p>
<p>状态：</p>
<p>设 dp$[x]$ 表示取出体积之和为 $x$ 的物品的方案数。</p>
<p>状态转移：</p>
<p>$(j)\leftarrow(j-v_i)$</p>
<p>DP 式子：</p>
<p><code>For(i,1,n) FOR(j,V,v[i]) dp[j]+=dp[j-v[i]]</code></p>
<p>时间复杂度：$O(nV)$。</p>
<p>空间复杂度：$O(V)$。</p>
<h3 id="多项式卷积："><a href="#多项式卷积：" class="headerlink" title="多项式卷积："></a>多项式卷积：</h3><p>每一个物品都可以视作一个形式幂级数，$n$ 个物品求方案数等价于 $n$ 个形式幂级数的卷积。</p>
<p>利用形式幂级数的封闭形式，可以做到 $O(V\log V)$。</p>
<p>此处不过多展开。</p>
<h3 id="可撤销性："><a href="#可撤销性：" class="headerlink" title="可撤销性："></a>可撤销性：</h3><p>背包求方案数的过程具有可撤销性。</p>
<p>例 9：</p>
<p>有一个容量为 $V$ 的背包，每次新加一个物品体积为 $v_i$，或每次删去一个已添加的物品，对于每次操作都求取出物品体积之和为 $m$ 的方案数。</p>
<p>新加物品的操作与前文一致。考虑如何删去一个物品。</p>
<p>实际上，若从多项式卷积的角度，“可撤销性”是容易解释的。</p>
<p>因为撤销一个物品相当于在若干个形式幂级数的卷积里去掉一个，等价于卷积的逆操作，或者称“多项式除法”。是可行的，但是每次的时间复杂度均为：$O(V\log V)$。</p>
<p>考虑 DP。</p>
<p>状态：</p>
<p>设 dp$[x]$ 表示取出体积之和为 $x$ 的物品的方案数。</p>
<p>状态转移：</p>
<p>$(j)\leftarrow(j-v_i)$</p>
<p>DP 式子：</p>
<ul>
<li>添加：<code>FOR(j,V,v[i]) dp[j]+=dp[j-v[i]]</code></li>
<li>删除：<code>For(j,v[i],V) dp[j]-=dp[j-v[i]]</code></li>
</ul>
<p>删除时，同样要保证 dp$[j]$ 减去的是不考虑 v$[i]$ 的方案数，所以 dp$[j-v[i]]$ 要先把 dp$[j-2\times v[i]]$ 的部分减去。因此，删除需要从小到大枚举容量。</p>
<p>单次时间复杂度：$O(V)$。</p>
<h2 id="addition：-1"><a href="#addition：-1" class="headerlink" title="addition："></a>addition：</h2><p>先枚举容量和先枚举物品。</p>
<p>实际上，这个问题在于 01 背包和完全背包的比较。</p>
<p>在 01 背包中，每个物品只能选择 $1$ 次或者 $0$ 次，若是先枚举容量，每一次都枚举物品，那么无法确定某一个物品是否在前面的枚举中使用过。而完全背包对选择的次数没有限制，所以也就不用确定是否在前面的枚举中使用过。所以，对于完全背包，是可以先枚举容量，再枚举物品的；对于 01 背包，是不可以先枚举容量，再枚举物品的。其它背包过程同理，若物品的使用次数有限制，则不能先枚举容量。而需要先枚举物品，使得物品之间的选择相互独立且考虑完备。</p>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
  </entry>
  <entry>
    <title>DP（五）</title>
    <url>/2024/01/24/DP%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>数位 DP</p>
<span id="more"></span>

<p>数位是指把一个数字按照个、十、百、千等等一位一位地拆开，关注它每一位上的数字。如果拆的是十进制数，那么每一位数字都是 $0,..,9$，其他进制可类比十进制。</p>
<h2 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h2><p>例 1：</p>
<p>求 $[a,b]$ 之间有多少个数满足：从高位到低位，各位上的数非递减。</p>
<p>对于数位 DP，普遍是利用差分，用 $[1,b]$ 的答案减去 $[1,a-1]$ 的答案得到 $[a,b]$ 的答案。</p>
<p>先来考虑一个大数比较的策略：</p>
<p>对于两个大整数 $a,b(a,b\leq 10^{10^6})$ 比较大小。</p>
<p>先比较 $a,b$ 的长度：</p>
<ul>
<li>$lena&gt;lenb$，$a&gt;b$。</li>
<li>$lena&lt;lenb$，$a&lt;b$。</li>
</ul>
<p>对于 $lena&#x3D;lenb$ 的情况，继续讨论。从最高位开始，找到第一个 $a[i]\neq b[i]$：</p>
<ul>
<li>$a[i]&gt;b[i]$，$a&gt;b$。</li>
<li>$a[i]&lt;b[i]$，$a&lt;b$。</li>
</ul>
<p>若没有 $a[i]\neq b[i]$ 的位置，则 $a&#x3D;b$。</p>
<p>这个过程启发，只要第一个不等的位置满足大小关系，那么后面的数位就可以取任意值。</p>
<p>所以对于例 $1$，可以枚举前缀相同的数位个数（前缀长度确定后数位固定）后枚举考虑那个满足小于关系的数位，对于后面的数位则可以取 $[0,9]$ 的任意数字。</p>
<p>状态：</p>
<p>设 dp$[x][y][0&#x2F;1]$ 表示从高到低第 $x$ 位，第 $x$ 位为 $y$ 且最高位到第 $x$ 位是&#x2F;不是前缀的合法数量。</p>
<p>转移：</p>
<p>$(x,a[x],0)\leftarrow(x-1,a[x-1],0)$ $a[x]\geq a[x-1]$</p>
<p>$(x,y,1)\leftarrow(x-1,a[x-1],0),…(x-1,1,1),(x-1,0,1)$ 且数位不递减</p>
<p>DP 式子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="built_in">For</span>(j,<span class="number">0</span>,<span class="number">9</span>) dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">For</span>(j,<span class="number">0</span>,<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==a[i]-<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[i]&gt;=a[i<span class="number">-1</span>]) dp[i][j][<span class="number">0</span>]=dp[i<span class="number">-1</span>][a[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">For</span>(k,<span class="number">0</span>,j)&#123;</span><br><span class="line">            dp[i][j][<span class="number">1</span>]+=dp[i<span class="number">-1</span>][k][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(j&lt;a[i]-<span class="string">&#x27;0&#x27;</span>) dp[i][j][<span class="number">1</span>]+=dp[i<span class="number">-1</span>][k][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的答案为 dp$[lena][a[lena]][0]+…+$dp$[lena][0][1]$。</p>
<p>时间复杂度：$O(c\log^2_ca)$。</p>
<p>空间复杂度：$O(c\log_ca)$。</p>
<p>$c$ 表示进制数。</p>
<p>空间易得滚动数组优化。</p>
<h3 id="addition："><a href="#addition：" class="headerlink" title="addition："></a>addition：</h3><p>在上文中，“第一个不等关系的数位后可以取任意数字”。在这里注意到可以将后面视作一个子结构，因为“任意”说明此时的后续状态并不关心前半部分的内容。</p>
<p>而在之前的内容中，学习过“记忆化搜索”。若将这个“子结构”用递归的方式处理并记忆化，同样可以实现 DP 的过程。并且笔者看来相较扫表更容易理解。</p>
<p>新 DP 式子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[x][y][z]) <span class="keyword">return</span> mem[x][y][z];</span><br><span class="line">    <span class="built_in">For</span>(i,y,<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">0</span>&amp;&amp;i&gt;a[x+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(z==<span class="number">0</span>&amp;&amp;i==a[x+<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>) res+=<span class="built_in">dp</span>(x+<span class="number">1</span>,i,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> res+=<span class="built_in">dp</span>(x+<span class="number">1</span>,i,<span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    vis[x][y][z]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mem[x][y][z]=res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对比两种实现方式："><a href="#对比两种实现方式：" class="headerlink" title="对比两种实现方式："></a>对比两种实现方式：</h2><p>扫表和记忆化搜索。</p>
<p>其实可以发现，扫表记录是从起点到当前状态的结果，记忆化搜索记录的是当前状态到终点的结果。</p>
<p>若目标问题更容易解决的是到终点的结果（或是更容易视作子结构）那么更适合记忆化搜索实现。反之，若是更容易解决到起点的结果，那么更适合扫表方式解决。</p>
<p>同时，容易发现，记忆化搜索无法进行滚动数组优化，因为它需要反复访问不同状态记录的结果，而不是像扫表仅依附于上一轮的值。</p>
<p>对应的，记忆化也并非毫无优势。记忆化搜索确保了状态都是有用的，不会访问到一些无用状态，而扫表是通过循环枚举，会覆盖整个 DP 数组空间。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>数位 DP 整体是比较套路化的一种 DP，整体框架确定：</p>
<ul>
<li>枚举前缀，标记是否前缀</li>
<li>枚举数位</li>
<li>根据题目要求修改转移的状态</li>
</ul>
<p>当然，难的题目也可以比较困难，而难的核心往往就是“根据题目要求修改转移的状态”，这需要结合实际题目考虑，但普遍较“套路”。</p>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
  </entry>
  <entry>
    <title>DP（六）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（八）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（十一）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（十五）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（十三）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（十二）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（四）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>状态机 DP</p>
<span id="more"></span>

<p>笔者其实更愿意称之为“分类DP”。</p>
<p>状态机本身概念与算法无关，选择性理解。</p>
<p>解释：包含多个待选状态，不同的状态之间有相互转化的方法，我们可以借助这些转化的手段，达成状态之间的相互转移。</p>
<p>例 $1$：</p>
<p>给定一支股票 $n$ 天的价格 $a_i$，最多持有一只股票，买入卖出共视作一次交易，最多进行 $k$ 次交易，求最大收益。</p>
<p>买入&#x2F;卖出是通过卖出&#x2F;买入的状态转移来的，而不是通过更小规模的相同结构转移过来，称这样的 DP 过程为状态机 DP。</p>
<p>状态：</p>
<p>设 dp$[i][j][0&#x2F;1]$ 表示到第 $i$ 天，共进行 $j$ 次交易，且第 $i$ 天为买入&#x2F;卖出的最大收益。</p>
<p>转移：</p>
<p>$(i,j,0)\leftarrow(i-1,j-1,1),(i-1,j,0)$</p>
<p>$(i,j,1)\leftarrow(i-1,j,0),(i-1,j,1)$</p>
<p>DP 式子：</p>
<p><code>For(i,1,n) For(j,1,k) dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j-1][1]-a[i]),dp[i][j][1]=max(dp[i-1][j][1],dp[i-1][j][0]+a[i])</code></p>
<p>空间上显然可以滚动数组优化。</p>
<p>时间复杂度：$O(nk)$。</p>
<p>空间复杂度：$O(k)$。</p>
<p>例 2：</p>
<p>给定一支股票 $n$ 天的价格 $a_i$，最多持有一只股票，买入卖出共视作一次交易，卖出股票后第二天不能买入，求最大收益。</p>
<p>状态：</p>
<p>设 dp$[i][j][0&#x2F;1&#x2F;2]$ 表示到第 $i$ 天，共进行 $j$ 次交易，且第 $i$ 天为买入&#x2F;卖出&#x2F;不操作的最大收益。</p>
<p>转移：</p>
<p>$(i,0)\leftarrow(i-1,0),(i-1,2)$</p>
<p>$(i,1)\leftarrow(i-1,0)$</p>
<p>$(i,2)\leftarrow(i-1,2),(i-1,1),(i-1,0)$</p>
<p>DP 式子：</p>
<p><code>For(i,1,n) dp[i][0]=max(dp[i-1][0],dp[i-1][2]-a[i]),dp[i][1]=dp[i-1][0]+a[i],dp[i][2]=max(dp[i-1][2],max(dp[i-1][0],dp[i-1][1]))</code></p>
<p>同样地容易得出可以滚动数组优化空间。</p>
<p>时间复杂度：$O(n)$。</p>
<p>空间复杂度：$O(1)$。</p>
]]></content>
      <categories>
        <category>DP</category>
      </categories>
  </entry>
  <entry>
    <title>DP（十四）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（十）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%8D%81%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DP（十六）</title>
    <url>/2024/01/24/DP%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>图（三）</title>
    <url>/2024/01/26/%E5%9B%BE%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>最短路</p>
<span id="more"></span>

<p>最短路问题一般在带权图中考虑。</p>
<p>最短路问题中，无向图与有向图类似，将一条无向边拆成两条权值相同，方向相反的边。</p>
<p>最短路类型：</p>
<ul>
<li>单源最短路：一个起点。</li>
<li>多源最短路：多个起点（共用一个最短路距离）。</li>
<li>全源最短路：任意两点之间的最短路。</li>
</ul>
<p>松弛：</p>
<p>对 $(u,v,w)$ 进行松弛：<code>dis[v]=min(dis[v],dis[u]+w)</code></p>
<h2 id="Dijkstra："><a href="#Dijkstra：" class="headerlink" title="Dijkstra："></a>Dijkstra：</h2><p>一种用于求<strong>非负权</strong>图上单源最短路径的算法。</p>
<h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p>将节点分成两个集合：</p>
<ul>
<li>已确定最短路长度的点集（S）</li>
<li>未确定最短路长度的点集（T）</li>
</ul>
<p>初始所有点均属于 T 且所有点的最短路距离均为＋∞，将源点（出发点）放入 S，并将最短路数组设为 $0$。</p>
<p>不断执行以下操作：</p>
<ul>
<li>从 T 集合中，选取一个最短路长度最小的节点，移到 S 中。</li>
<li>对于刚加入 S 的节点，松弛所有出边。</li>
</ul>
<p>直到 T 集合为空，算法结束。</p>
<p>时间复杂度瓶颈为选取一个最短路长度最小的节点：</p>
<ul>
<li>暴力选取：算法时间复杂度为：$O(n^2+m)$。</li>
<li>二叉堆选取：松弛成功时要将节点插入二叉堆（若已经加入需要删除），同时每个点也会被取出 $1$ 次，时间复杂度：$O(n\log n+m\log n)$。</li>
<li>优先队列选取：同二叉堆，但优先队列不能删除元素，所以松弛成功插入时，时间复杂度单次为 $O(\log m)$，总时间复杂度：$O(n\log m+m\log m)$。</li>
<li>其它动态维护最值的方式。</li>
</ul>
<p>虽然算法原理角度不同，但是算法流程和优先队列 BFS 在图上的实现是一致的，所以证明略。</p>
<p>关于负权图中失效的问题在优先队列 BFS 中也有解释，不赘述。 </p>
<h2 id="Bellman-Ford："><a href="#Bellman-Ford：" class="headerlink" title="Bellman-Ford："></a>Bellman-Ford：</h2><p>一种基于松弛操作的用于求单源最短路的算法（可以求有负权的图的最短路问题）。</p>
<h3 id="过程：-1"><a href="#过程：-1" class="headerlink" title="过程："></a>过程：</h3><p>初始化源点最短路数组为 $0$，不断重复地对所有边进行松弛操作。</p>
<p>时间复杂度：$O(nm)$。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>在最短路存在的情况下，每一轮松弛操作（因为无法获知最短路是哪一条，所以需要对所有边松弛。同时，最短路也不会只有一条），会使得最短路的节点数$+1$。</p>
<p>而图中最短路最多经过 $n$ 个点，所以进行 $n-1$ 轮松弛即可找到最短路。</p>
<h3 id="判负环："><a href="#判负环：" class="headerlink" title="判负环："></a>判负环：</h3><p>若存在负环，则可以一直松弛，所以若是 Bellman-Ford 在第 $n$ 轮松弛中还有点被更新，即有负环。</p>
<h3 id="特殊性："><a href="#特殊性：" class="headerlink" title="特殊性："></a>特殊性：</h3><p>根据 Bellman-Ford 的原理，容易发现，在第 $i$ 轮松弛操作时，求出的最短路数组即为“经过 $i$ 条边的最短路”。</p>
<h2 id="SPFA："><a href="#SPFA：" class="headerlink" title="SPFA："></a>SPFA：</h2><p>Bellman-Ford 队列优化。</p>
<p>虽然 SPFA 通常指队列优化，但是本身是对松弛操作次数的优化，所以不一定使用队列，也存在 SPFA-DFS 实现的说法。</p>
<p>Bellman-Ford 将所有边松弛了 $n-1$ 轮，而在实际问题中，最短路不一定经过 $n$ 个点，也不是所有边都能有效松弛。所以考虑将所有点放入队列中，若是一个点已经不能松弛任何点了，那在后续的过程中就不再考虑了。</p>
<p>实际上，SPFA 就可以视作普通 BFS 求最短路。</p>
<p>时间复杂度：$O(m)\sim O(nm)$。</p>
<p>SPFA 在最坏情况下和 Bellman-Ford 一致。</p>
<p>朴素的 SPFA 使用菊花即可卡成和 Bellman-Ford 一致。</p>
<p>尽管 SPFA 存在各式形形色色的优化，但是都是可以在特殊情况下得到较劣的时间复杂度，甚至在部分情况下会出现指数级别的时间复杂度（SPFA-DFS 在无负环时判负环）。</p>
<p>一般而言，除非必要（负权图求最短路），不使用 SPFA。</p>
<h2 id="Floyd："><a href="#Floyd：" class="headerlink" title="Floyd："></a>Floyd：</h2><p>一种基于动态规划的全源最短路算法。</p>
<p>设 dp$[k][x][y]$ 表示从 $x$ 到 $y$ 只经过 $1-k$ 号点的最短路。</p>
<p>$(k,x,y)\leftarrow(k-1,x,k)+(k-1,k,y)$。</p>
<p>先枚举 $k$，再枚举点 $x,y$。</p>
<p>时间复杂度：$O(n^3)$。</p>
<h3 id="特殊性：-1"><a href="#特殊性：-1" class="headerlink" title="特殊性："></a>特殊性：</h3><h4 id="传递闭包："><a href="#传递闭包：" class="headerlink" title="传递闭包："></a>传递闭包：</h4><p>可以使用 Floyd 求传递闭包，即：图的完整连通情况。同时因为连通性只含 0&#x2F;1，使用 bitset 可以优化至 $O(\frac{n^3}{\omega})$。</p>
<h4 id="无向正权图最小环："><a href="#无向正权图最小环：" class="headerlink" title="无向正权图最小环："></a>无向正权图最小环：</h4><p>dp$[z-1][x][y]$ 和 $(x,z),(z,y)$ 构成一个环。</p>
<h4 id="矩阵快速幂："><a href="#矩阵快速幂：" class="headerlink" title="矩阵快速幂："></a>矩阵快速幂：</h4><p>Floyd dp$[k][x][y]$ 只与 dp$[k-1][x][y]$ 有关，所以可以采用滚动数组优化，同时类似 01 背包，dp$[k][x][y]$ 可以继承自 dp$[k-1][x][y]$。所以可以直接去掉第一维，而去掉第一维后，对于 DP 式子而言，可以抽象地视作一个矩阵乘法的过程。$\min$ 视作 $\sum$，$+$ 视作 $\times$。</p>
<p>时间复杂度优化至：$O(n^2\log n)$。但通常没必要。</p>
<h2 id="Johnson-全源最短路："><a href="#Johnson-全源最短路：" class="headerlink" title="Johnson 全源最短路："></a>Johnson 全源最短路：</h2><p>最短路问题上，实现目的与 Floyd 一致。</p>
<p>时间复杂度：$O(nm\log m)$。</p>
<p>若是正权图，分别以 $n$ 个点作为源点求最短路即可；若是负权图，</p>
<h2 id="有向无环图的最短路："><a href="#有向无环图的最短路：" class="headerlink" title="有向无环图的最短路："></a>有向无环图的最短路：</h2><p>DP 问题。</p>
<h2 id="边权为-1-的最短路："><a href="#边权为-1-的最短路：" class="headerlink" title="边权为 1 的最短路："></a>边权为 1 的最短路：</h2><p>BFS。</p>
<p>略。</p>
<h2 id="边权为-0-1-的最短路："><a href="#边权为-0-1-的最短路：" class="headerlink" title="边权为 0&#x2F;1 的最短路："></a>边权为 0&#x2F;1 的最短路：</h2><p>01 BFS。</p>
<p>略。</p>
<h2 id="番外："><a href="#番外：" class="headerlink" title="番外："></a>番外：</h2><h3 id="次短路："><a href="#次短路：" class="headerlink" title="次短路："></a>次短路：</h3><h3 id="k-短路："><a href="#k-短路：" class="headerlink" title="k 短路："></a>k 短路：</h3>]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>图（一）</title>
    <url>/2024/01/26/%E5%9B%BE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>基本概念</p>
<span id="more"></span>

<p>图论相关定义在不同教材中往往会有所不同，遇到的时候需根据上下文加以判断。</p>
<p>本文将介绍部分常用概念，更多图论相关知识请自行了解。</p>
<h2 id="图："><a href="#图：" class="headerlink" title="图："></a>图：</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>图是一个二元组 $G&#x3D;(V(G),E(G))$。其中 $V(G)$ 是非空集，称为点集，对于 $V$ 中的每个元素，我们称之为顶点或节点，简称点；$E(G)$ 为 $V(G)$ 各节点之间的边的集合，称为边集。</p>
<p>常简化用 $G&#x3D;(V,E)$ 表示图。</p>
<h3 id="无向图："><a href="#无向图：" class="headerlink" title="无向图："></a>无向图：</h3><p>若 $G$ 为无向图，则 $E$ 中每一个元素为一个无序二元组 $(u,v)$，称作无向边。$u,v$ 称作端点。</p>
<h3 id="有向图："><a href="#有向图：" class="headerlink" title="有向图："></a>有向图：</h3><p>若 G 为有向图，则 E 中每一个元素为一个有序二元组 $(u,v)$，有时也称作 $u\rightarrow v$。$u$ 称作起点，$v$ 称作终点。称 $u$ 是 $v$ 的直接前驱，$v$ 是 $u$ 的直接后继。</p>
<h3 id="有权图："><a href="#有权图：" class="headerlink" title="有权图："></a>有权图：</h3><p>若图为有权图，则用 $(u,v,w)$ 描述一条边。</p>
<h3 id="简单图："><a href="#简单图：" class="headerlink" title="简单图："></a>简单图：</h3><p>若一个图中没有自环和重边，则被称为简单图。</p>
<h4 id="自环："><a href="#自环：" class="headerlink" title="自环："></a>自环：</h4><p>对 $E$ 中的边 $e&#x3D;(u,v)$，若 $u&#x3D;v$，则 $e$ 被称作一个自环。</p>
<h4 id="重边："><a href="#重边：" class="headerlink" title="重边："></a>重边：</h4><p>若 $E$ 中存在两个完全相同的元素 $e_1&#x3D;e_2$，则它们被称作一组重边。</p>
<p>addition:</p>
<p>无向图中，$(u,v)$ 和 $(v,u)$ 算作重边；有向图中，$(u,v)$ 和 $(v,u)$ 不算作重边。</p>
<h3 id="图的度："><a href="#图的度：" class="headerlink" title="图的度："></a>图的度：</h3><h4 id="无向图：-1"><a href="#无向图：-1" class="headerlink" title="无向图："></a>无向图：</h4><p>与一个顶点相关的边的条数称作该点的度。</p>
<h4 id="有向图：-1"><a href="#有向图：-1" class="headerlink" title="有向图："></a>有向图：</h4><p>入度：以一个顶点为终点的边数。</p>
<p>出度：以一个顶点为起点的边数。</p>
<p>addition：</p>
<p>无向图的度在欧拉回路&#x2F;欧拉路径中有特殊应用。</p>
<p>有向图的度在拓扑排序中有特殊应用。</p>
<h3 id="图的路径："><a href="#图的路径：" class="headerlink" title="图的路径："></a>图的路径：</h3><h4 id="途径："><a href="#途径：" class="headerlink" title="途径："></a>途径：</h4><p>途径是连接一连串顶点的边的序列，可以为有限或无限长度。形式化地说，一条有限途径 $w$ 是一个边的序列 $e_1,e_2,…,e_k$，使得存在一个顶点序列 $v_0,v_1,…,v_k$ 满足 $e_i&#x3D;(v_{i-1},v_i)$。通常来说，边的数量 $k$ 被称作这题途径的长度（如果边是带权的，长度通常指途径上的边权之和）</p>
<h4 id="迹："><a href="#迹：" class="headerlink" title="迹："></a>迹：</h4><p>对于一条途径 $w$，若 $e_1,e_2,…,e_k$ 两两互不相同，则称 $w$ 是一条迹。</p>
<h4 id="路径："><a href="#路径：" class="headerlink" title="路径："></a>路径：</h4><p>路径又称简单路径。</p>
<p>从一个点出发不经过相同点的边序列称为路径（简单路径）。</p>
<h3 id="子图："><a href="#子图：" class="headerlink" title="子图："></a>子图：</h3><p>对于一张图 $G&#x3D;(V,E)$，若存在另一张图 $H&#x3D;(V’,E’)$ 满足 $V’\subseteq V$ 且 $E’\subseteq E$，则称 $H$ 是 $G$ 的子图，记作 $H\subseteq G$。</p>
<h3 id="图的连通性："><a href="#图的连通性：" class="headerlink" title="图的连通性："></a>图的连通性：</h3><h4 id="无向图：-2"><a href="#无向图：-2" class="headerlink" title="无向图："></a>无向图：</h4><p>对于一张无向图 $G&#x3D;(V,E)$，对于 $u,v\in V$，若存在一条路径使得从 $u$ 出发可以到 $v$，则称 $u$ 和 $v$ 是连通的。</p>
<p>若无向图 $G&#x3D;(V,E)$ 满足其中任意两个顶点均连通，则称 $G$ 是连通图，$G$ 具有连通性。</p>
<p>若 $H$ 是 $G$ 是一个连通子图，$H\subsetneq F\subsetneq G$ 且 $F$ 为连通图，则 $H$ 是 $G$ 的一个连通块&#x2F;连通分量（极大连通子图）</p>
<h4 id="有向图：-2"><a href="#有向图：-2" class="headerlink" title="有向图："></a>有向图：</h4><p>对于一张无向图 $G&#x3D;(V,E)$，对于 $u,v\in V$，若存在一条路径使得从 $u$ 出发可以到 $v$，则称 $u$ 可达 $v$。</p>
<h2 id="树："><a href="#树：" class="headerlink" title="树："></a>树：</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>任意两个节点之间有且仅有一条简单路径的无向图称为树。</p>
<p>等价定义：</p>
<ul>
<li>有 $n$ 个节点，$n-1$ 条边的无向连通图</li>
<li>无向无环的连通图</li>
<li>任何边均为桥的连通图</li>
<li>没有环，且在任意不同两点间添加一条边之后所得图含唯一的一个环的图</li>
</ul>
<h3 id="根："><a href="#根：" class="headerlink" title="根："></a>根：</h3><p>树根：树中的一个节点。（确定树根后的有根树能引申出许多其它概念）</p>
<h4 id="无根树：没有固定根节点的树。"><a href="#无根树：没有固定根节点的树。" class="headerlink" title="无根树：没有固定根节点的树。"></a>无根树：没有固定根节点的树。</h4><h4 id="有根树：指定一个节点为根的树。"><a href="#有根树：指定一个节点为根的树。" class="headerlink" title="有根树：指定一个节点为根的树。"></a>有根树：指定一个节点为根的树。</h4><h3 id="只对于有根树而言的概念："><a href="#只对于有根树而言的概念：" class="headerlink" title="只对于有根树而言的概念："></a>只对于有根树而言的概念：</h3><ul>
<li>父节点：对于除根以外的每个节点，定义为从该节点到根路径上的第二个节点。 根结点没有父节点。</li>
<li>祖先节点：一个结点到根节点的路径上，除了它本身外的节点。根节点没有祖先。</li>
<li>最近公共祖先：两个点的公共祖先里面，离根最远的那个。</li>
<li>子节点：如果 $u$ 是 $v$ 的父亲，那么 $v$ 是 $u$ 的子节点。</li>
<li>节点的深度：到根结点的路径上的边数（一般为边数 $+1$）。</li>
<li>树的高度：所有结点的深度的最大值。</li>
<li>兄弟节点：同一个父亲的多个子节点互为兄弟。</li>
<li>后代节点：子节点和子节点的后代。</li>
</ul>
<p><img src="https://oi-wiki.org/graph/images/tree-definition.svg"></p>
<ul>
<li>子树：删掉与父亲相连的边后，该节点所在的图。</li>
</ul>
<p><img src="https://oi-wiki.org/graph/images/tree-definition-subtree.svg"></p>
<h3 id="既适用无根树又适用有根树的概念："><a href="#既适用无根树又适用有根树的概念：" class="headerlink" title="既适用无根树又适用有根树的概念："></a>既适用无根树又适用有根树的概念：</h3><ul>
<li>森林：每个联通块都是树的图（注：树也是森林）。</li>
<li>生成树：一个无向联通图（可以有环）的生成子图，同时要求是树。</li>
<li>叶子节点：度不超过 $1$ 的节点。</li>
<li>树的直径：树上最长的任意两节点之间的简单路径</li>
<li>树的重心：对于树上的每一个点，计算以其为根时所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。</li>
</ul>
<p>注：叶子节点既是无根树又是有根树的概念。比如：链，有两个叶子节点，而与它怎么画无关。</p>
<h3 id="特殊的树："><a href="#特殊的树：" class="headerlink" title="特殊的树："></a>特殊的树：</h3><ul>
<li>链：满足与任一节点相连的边不超过 $2$ 条的树称为链。</li>
<li>菊花图：满足存在 $u$ 使得所有除 $u$ 以外结点均与 $u$ 相连的树。</li>
<li>二叉树：每个节点最多只有两个子节点的有根树。</li>
</ul>
<h3 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h3><p>（二叉树还存在有特殊的二叉树，限于篇幅不在此介绍）</p>
<p>二叉树是特殊的有根树，具有很多特殊的性质。</p>
<h4 id="只对于二叉树的概念："><a href="#只对于二叉树的概念：" class="headerlink" title="只对于二叉树的概念："></a>只对于二叉树的概念：</h4><ul>
<li>左右儿子：对任一节点两个的子节点任意编序，其中一个为左儿子，另一个即为右儿子。</li>
<li>完全二叉树：只有最下面两层结点的度数可以小于 $2$，且最下面一层的结点都集中在该层的最左侧 $\Leftrightarrow$ 对树中的节点按从上至下、从左到右的顺序进行编号，如果编号为 $i$ 的节点与满二叉树中编号为 $i$ 的节点在二叉树中的位置相同。</li>
</ul>
<p><img src="https://oi-wiki.org/graph/images/tree-binary-complete.svg"></p>
<ul>
<li>满二叉树$&#x2F;$完美二叉树：所有叶节点的深度均相同的二叉树 $\Leftrightarrow$ 节点数$&#x3D;2^{\text{树的高度}}-1$。</li>
</ul>
<p><img src="https://oi-wiki.org/graph/images/tree-binary-perfect.svg"></p>
<ul>
<li>完整二叉树：每个节点的子节点数量均为 $0$ 或者 $2$ 的二叉树。</li>
</ul>
<p><img src="https://oi-wiki.org/graph/images/tree-binary-proper.svg"></p>
<p>注：满二叉树和完整二叉树定义有歧义，不同教材定义不一致。有的教材，将满二叉树定义成完整二叉树。</p>
<h2 id="图的存储："><a href="#图的存储：" class="headerlink" title="图的存储："></a>图的存储：</h2><h3 id="直接存："><a href="#直接存：" class="headerlink" title="直接存："></a>直接存：</h3><p>用一个结构体存储 $(u,v,w)$。</p>
<h3 id="邻接矩阵："><a href="#邻接矩阵：" class="headerlink" title="邻接矩阵："></a>邻接矩阵：</h3><p>用 $c[x][y]$ 表示 $(x,y,c[x][y])$。</p>
<h3 id="邻接表："><a href="#邻接表：" class="headerlink" title="邻接表："></a>邻接表：</h3><p>把以一个点为起点的边存在这个点所对应的集合中。</p>
<p>有向图只存在起点，无向图两个端点都要存。</p>
<h4 id="vector："><a href="#vector：" class="headerlink" title="vector："></a>vector：</h4><p>采用 vector 实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;edge&gt; p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    p[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:p[i])</span><br><span class="line">        cout&lt;&lt;u&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;u.v&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;u.w&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="链式前向星："><a href="#链式前向星：" class="headerlink" title="链式前向星："></a>链式前向星：</h4><p>采用链表实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">    to[idx]=v,edge[idx]=w,nex[idx]=head[u],head[u]=idx++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u=head[i];~u;u=nex[u])</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;to[u]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;edge[u]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>图（二）</title>
    <url>/2024/01/26/%E5%9B%BE%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>拓扑排序</p>
<span id="more"></span>

<p>拓扑排序不是一般意义上的“排序”。</p>
<h2 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h2><p>例 1：</p>
<p>对于一个家族，给出每个人的孩子的序号，输出一个序列，使得每个人的祖先都比他先列出。</p>
<p>将每个人视作图中的一个节点，若 $v$ 是 $u$ 的孩子，则视作边 $(u,v)$，那么形成的图一定是一个有向无环图，拓扑排序就是针对有向无环图的算法。</p>
<p>第一个输出的点一定是不存在祖先的节点，体现在图上即：入度为 $0$ 的节点。每输出一个点，就在图上取下这个点。当一个节点的祖先全部输出后，这个点便可以被输出，因为满足了它的祖先都比它先输出了。</p>
<p>通常使用队列模拟上述过程，此算法被称为 Kahn 算法。通常来说，拓扑排序均指 Kahn 算法。（使用队列模拟即 BFS 实现，也可以使用 DFS 实现，但通常不这么做）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!in[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">	<span class="keyword">auto</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">	seq.<span class="built_in">push_back</span>(now);</span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> u:p[now])&#123;</span><br><span class="line">		in[u]--;</span><br><span class="line">		<span class="keyword">if</span>(!in[u]) q.<span class="built_in">push</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：$O(|V|+|E|)$。</p>
<h2 id="拓扑排序实现-DP："><a href="#拓扑排序实现-DP：" class="headerlink" title="拓扑排序实现 DP："></a>拓扑排序实现 DP：</h2><p>回顾记忆化搜索中提到的子结构，其维护的是从当前状态到终点的信息，而扫表对应的是从起点到当前状态的信息，拓扑排序同样维护的是起点到当前状态的信息。</p>
<p>其一，考虑搜索树，容易发现，若为树上的边赋予一个“方向”，那么树就是一个有向无环图。所以记忆化搜索的状态之间即为一个有向无环图，这便满足了可以进行拓扑排序的前置条件。</p>
<p>其二、对于扫表而言，其保证了用一个状态的值去转移另一个状态时，它的值是正确（不会再被转移）所以，对应到图上，也就是没有入度了。同样是一个有向无环图。</p>
<p>例 2：</p>
<p>给定一个食物网，用 $(u,v)$ 描述 $u$ 吃 $v$，求食物网中存在多少条最大食物链，最大食物链即最左端不存在吃的，最右端不存在被吃的。</p>
<p>状态：</p>
<p>设 dp$[x]$ 表示以 x 为最右端的最大食物链数。</p>
<p>转移：</p>
<p>$(v)\leftarrow(u)$</p>
<p>此时，枚举的顺序就不容易确定了，因为要保证用于转移的状态是正确的，所以并不能直接从小到大枚举生物。此时就可以用拓扑排序实现。</p>
<p>DP 式子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">For</span>(i,<span class="number">1</span>,n) <span class="keyword">if</span>(!in[i]) q.<span class="built_in">push</span>(i),dp[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="keyword">auto</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> u:p[now])&#123;</span><br><span class="line">        dp[u]+=dp[now];</span><br><span class="line">        in[u]--;</span><br><span class="line">        <span class="keyword">if</span>(!in[u])</span><br><span class="line">            q.<span class="built_in">push</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓扑排序判环："><a href="#拓扑排序判环：" class="headerlink" title="拓扑排序判环："></a>拓扑排序判环：</h2><p>有向图中判环拓扑排序的一个简单小应用。</p>
<p>（理论上有环不是有向无环图，那自然算不得拓扑排序，所以其实叫 Kahn 判环会更合适）</p>
<p>对于一个环，其没有入度为 $0$ 的点，也就无法进入循环，同时无法去掉环上的点。</p>
<p>所以跑一遍拓扑排序后，入度不为 $0$ 的点就是在环上的点。</p>
<h2 id="番外："><a href="#番外：" class="headerlink" title="番外："></a>番外：</h2><p>记忆化搜索、扫表、拓扑排序的对比：</p>
<h3 id="记忆化搜索："><a href="#记忆化搜索：" class="headerlink" title="记忆化搜索："></a>记忆化搜索：</h3><p>维护的是从当前状态到终点的信息。</p>
<p>优点：</p>
<p>在处理容易视作“子结构”的问题中，会更好理解。</p>
<p>因为其“子结构”性质，不会访问到无用状态。</p>
<p>缺点：</p>
<p>需要记录所有用到的状态，不能滚动数组优化空间，且不容易使用数据结构优化时间。</p>
<h3 id="扫表："><a href="#扫表：" class="headerlink" title="扫表："></a>扫表：</h3><p>维护的是从起点到当前状态的信息。</p>
<p>优点：</p>
<p>在处理小规模到大规模明确的问题中更好写。</p>
<p>相比记忆化搜索不用记录状态，所以在部分情况下可以使用滚动数组优化空间，可以使用数据结构优化时间。</p>
<p>缺点：</p>
<p>需要枚举所有状态，会遇到无用的状态。</p>
<p>在枚举顺序不容易确定的情况，比较难写（转移关系顺序难确定）。</p>
<h3 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h3><p>维护的是从起点到当前状态的信息。</p>
<p>优点：</p>
<p>处理图论模型，不用考虑枚举顺序，在有向无环图上“自动”解决枚举顺序。在状态之间关系明确的情况下容易建图实现。</p>
<p>和扫表同样可以滚动数组优化空间和数据结构优化空间（因为本质是 BFS，可以预处理深度后按层处理）</p>
<p>同时不需要枚举所有状态空间，也能避免遇到无用的状态。</p>
<p>缺点：</p>
<p>需要建图。</p>
<p>代码相对复杂。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>图（五）</title>
    <url>/2024/01/26/%E5%9B%BE%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>LCA 的 $n$ 种求法。</p>
<span id="more"></span>

<p>LCA 是许多树上问题的基础。</p>
<p>本文将介绍 LCA 的 $5$ 种求法。</p>
<h2 id="倍增："><a href="#倍增：" class="headerlink" title="倍增："></a>倍增：</h2><p>先考虑什么是倍增。</p>
<p>对于一个 $x$，其一定能被拆分成若干个 $2$ 的整数幂次之和（二进制描述），同时一个拆分策略就是每次减去不超过 $x$ 的最大 $2$ 的整数幂次。</p>
<p>考虑在一个二分问题上（解序列满足单调性），比 $x$ 大的值均为解。所以每次加上一个最大的无解的 2 的整数幂次，最后一定可以得到 $x$。</p>
<p>观察到：LCA 的性质是“最近”，而当距离超过这个“最近”后，到根所有的祖先节点均为 $(x,y)$ 的 CA。即：满足二分性。一般在树上问题，二分实现较麻烦，不如倍增。</p>
<p>设 f$[x][i]$ 表示 $x$ 的 $2^i$ 级祖先。</p>
<p>先要将 $x,y$ 跳到同一深度，否则相同的 $i$，$x,y$ 的 $2^i$ 祖先不相同无法倍增。解决方法同倍增，对于深度较深的点，若它的 $2^i$ 级祖先的深度已经低于另一个点了，那么就将 $i$ 减小。</p>
<p>那么从 $x$ 和 $y$ 分别往上跳祖先，当跳到一个相同点时，所以至少是 LCA 的祖先了，那么就可以将 $i$ 减小。</p>
<p>时间复杂度：$O(\log n)$。</p>
<p>需要预处理倍增数组和深度数组。</p>
<p>通常作为最经典、最广的 LCA 求法被使用。</p>
<h2 id="Tarjan："><a href="#Tarjan：" class="headerlink" title="Tarjan："></a>Tarjan：</h2><p>考虑 $m$ 次询问 LCA$(x,y)$，Tarjan 求 LCA 是一种离线算法，通常使用并查集维护某节点的祖先节点。</p>
<p>使用并查集的 Tarjan 时间复杂度为：$O(m\alpha(n+m)+n)$，但是存在严格 $O(m+n)$ 时间复杂度的 Tarjan 做法，但是 Tarjan 常数较大。</p>
<p>时间复杂度：$O(n)-O(1)$。</p>
<p>不常用。</p>
<h2 id="欧拉序求-LCA："><a href="#欧拉序求-LCA：" class="headerlink" title="欧拉序求 LCA："></a>欧拉序求 LCA：</h2><p>引理 1：树上 $(x,y)$ 的路径在树的欧拉序中是连续的一部分。</p>
<p>引理 2：树上 $(x,y)$ 不在 $(x,y)$ 路径上的祖先不在 $(x,y)$ 欧拉序中。</p>
<p>所以求 $(x,y)$ 的 LCA 等价于求 $(x,y)$ 欧拉序（并不关心 $x,y$ 欧拉序第几次出现的位置，只要保证之间不存在 LCA 的祖先即可）上深度最小的点。</p>
<p>转换成了静态区间询问最小值位置的问题，使用任何喜欢的方式维护即可。</p>
<p>因为是静态的，所以一般使用 ST 表维护。</p>
<p>时间复杂度：$O(n\log n)-O(1)$。</p>
<h2 id="dfs-序求-LCA："><a href="#dfs-序求-LCA：" class="headerlink" title="dfs 序求 LCA："></a>dfs 序求 LCA：</h2><p>引理：树上的某子树的点在 dfs 序中是连续的一部分。</p>
<p>所以 $x,y$ 的子树 dfs 序一定是在 LCA 的子树中，且在从 x&#x2F;y 回溯到 y&#x2F;x（取决于谁在 dfs 序中位置更靠前）的过程中，一定会经过 LCA 的某个儿子。</p>
<p>所以求出 $x,y$ 的 dfs 序中的深度最小值，LCA 即为该点的父节点。</p>
<p>时间复杂度同欧拉序求 LCA。</p>
<p>dfs 序求 LCA 相比欧拉序求 LCA 而言，优势在于 dfs 序点数更少（dfs 序记录 $n$ 个点，欧拉序记录 $2n-1$ 个点）dfs 序扩展性相对更强，在题目中同时需要求其它内容时，具有兼容性。</p>
<h2 id="树链剖分求-LCA："><a href="#树链剖分求-LCA：" class="headerlink" title="树链剖分求 LCA："></a>树链剖分求 LCA：</h2><p>此处指重链剖分。</p>
<p>与倍增相似，每次把 $x,y$ 向上跳到链顶位置，跳到相同的点时，说明找到了。因为链是连续的一段，所以最后的 LCA 就是不在链内的另一条链的链顶的父节点。</p>
<p>根据重链剖分性质，易得从 $x$ 到根节点最多经过 $O(\log n)$ 条链。</p>
<p>时间复杂度：$O(n)-O(\log n)$。且常数较小。</p>
<h2 id="番外："><a href="#番外：" class="headerlink" title="番外："></a>番外：</h2><h3 id="LCA-与-RMQ-问题。"><a href="#LCA-与-RMQ-问题。" class="headerlink" title="LCA 与 RMQ 问题。"></a>LCA 与 RMQ 问题。</h3><p>RMQ 即：静态区间最值问题。</p>
<p>LCA 转换成 dfs 序&#x2F;欧拉序上最值后，时间复杂度瓶颈为区间最值的瓶颈，而实际上 RMQ 存在 $O(n)$ 预处理 $O(1)$ 询问的算法。</p>
<p>同时，RMQ 问题也可转换为笛卡尔树上 LCA 问题。</p>
<h3 id="树上-k-级祖先："><a href="#树上-k-级祖先：" class="headerlink" title="树上 k 级祖先："></a>树上 k 级祖先：</h3><p>倍增、重链剖分均可在 $O(\log n)$ 的时间复杂度内解决。</p>
<p>使用长链剖分，可以在 $O(n)$ 的时间复杂度内解决。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构（五）</title>
    <url>/2024/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>平衡树</p>
<span id="more"></span>

<p>平衡树是一种特殊的二叉搜索树。</p>
<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>二叉搜索树是一种二叉树的树形结构，其定义如下：</p>
<ul>
<li>空树是二叉搜索树。</li>
<li>若二叉搜索树的左子树不为空，则其左子树上所有点的附加权值小于其根节点的值。</li>
<li>若二叉搜索树的右子树不为空，则其右子树上所有点的附加权值大于其根节点的值。</li>
<li>二叉搜索树的左右子树均为二叉搜索树。</li>
</ul>
<p>二叉搜索树上的基本操作所花费的时间与这棵树的高度成正比。</p>
<img src="/2024/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89/1.jpg" class="" title="咕咕咕">

<h2 id="查找最值："><a href="#查找最值：" class="headerlink" title="查找最值："></a>查找最值：</h2><p>二叉搜索树上的最小值为二叉搜索树左链的顶点，最大值为二叉搜索树右的顶点。</p>
<h2 id="查找元素："><a href="#查找元素：" class="headerlink" title="查找元素："></a>查找元素：</h2><p>设当前二叉搜索树子树的根为 root。</p>
<ul>
<li>若 root 为空，返回 <code>false</code>。</li>
<li>若 root 的权值等于 <code>value</code>，返回 <code>true</code>。</li>
<li>若 root 的权值大于 <code>value</code>，递归左子树。</li>
<li>若 root 的权值小于 <code>value</code>，递归右子树。</li>
</ul>
<h2 id="插入元素："><a href="#插入元素：" class="headerlink" title="插入元素："></a>插入元素：</h2><p>设当前二叉搜索树子树的根为 root。</p>
<ul>
<li>若 root 为空，创建一个新节点插入元素。</li>
<li>若 root 的权值等于 <code>value</code>，该节点的权值对应的计数数组加 $1$。</li>
<li>若 root 的权值大于 <code>value</code>，递归左子树。</li>
<li>若 root 的权值小于 <code>value</code>，递归右子树。</li>
</ul>
<h2 id="删除元素："><a href="#删除元素：" class="headerlink" title="删除元素："></a>删除元素：</h2><p>先查找元素，若存在元素，设对应节点为 root。</p>
<ul>
<li>若 root 权值对应的计数数组大于 $1$，则减 $1$。</li>
<li>若 root 为叶子节点，直接删除。</li>
<li>若 root 只有一个儿子的节点，返回这个儿子。</li>
<li>若 root 有两个非空子节点，用左子树的最大值替代它（swap 即可），再删除该节点。</li>
</ul>
<h2 id="求元素的排名："><a href="#求元素的排名：" class="headerlink" title="求元素的排名："></a>求元素的排名：</h2><p>排名的一个等价定义：比 $x$ 小的数的个数&#x2F;比 $x$ 大的数的个数 $+1$（具体题目具体分析）。</p>
<p>在查找元素的过程中累加左子树的大小之和（同时累加节点的计数数组）即可。</p>
<h2 id="查找排名为-k-的元素："><a href="#查找排名为-k-的元素：" class="headerlink" title="查找排名为 k 的元素："></a>查找排名为 k 的元素：</h2><p>比 $x$ 小的元素个数为 $k-1$。设 $count$ 为当前节点对应的计数数组的值。</p>
<ul>
<li>若左子树的大小大于等于 $k$，递归左子树。</li>
<li>若左子树的大小小于 $k-count$，则该元素在右子树中。</li>
<li>若其左子树的大小在区间 $[k-count,k-1]$ 中，则该元素为子树的根节点。</li>
</ul>
<h2 id="平衡树："><a href="#平衡树：" class="headerlink" title="平衡树："></a>平衡树：</h2><p>朴素二叉搜索树的时间复杂度均为 $O(h)$，在极限数据下，为 $O(n)$。</p>
<p>但是二叉搜索树树形态不唯一，这也就使得寻求一种 $h$ 更小更稳定的二叉搜索树成为了优化的核心道路。</p>
<p>平衡树即是指树高平衡的二叉搜索树，平衡树同样不唯一，根据不同的平衡策略可得不同的平衡树。</p>
<p>根据平衡方式可分为：旋转平衡、重构平衡、自平衡等。</p>
<p>平衡树均使得单次操作的时间复杂度为 $O(\log n)$，即使得树高均衡在 $O(\log n)$。但根据不同的平衡规则，部分平衡树为均摊时间复杂度而不是稳定时间复杂度。</p>
<p>在算法竞赛中使用较广的平衡树有：Treap（分为无旋 Treap（FHQ-Treap） 和带旋 Treap，通常 Treap 单指带旋 Treap，但无定论，还是要结合上下文）、Splay、替罪羊树、笛卡尔树。</p>
<p>其中 Splay 更多地被应用于 LCT（一种动态树）以及用于维护序列而不是值。替罪羊树和笛卡尔树相对使用较少，替罪羊树是一种基于重构的平衡树，笛卡尔树作为一种特殊形态的平衡树（本质是特殊的 Treap）其具有唯一性，在部分题目中对理解更加形象，但由于和单调栈没有本质区别，所有笛卡尔树具有可替代性。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>图（四）</title>
    <url>/2024/01/26/%E5%9B%BE%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>最小生成树</p>
<span id="more"></span>

<p>无向连通图才有最小生成树，最小生成树即为边权和最小的生成树。</p>
<h2 id="Kruskal："><a href="#Kruskal：" class="headerlink" title="Kruskal："></a>Kruskal：</h2><h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><p>将 $m$ 条边按照权值升序，每次连接权值最小的顶点不在同一个连通块中的边。</p>
<p>使用并查集维护连通块，算法时间复杂度瓶颈为排序，时间复杂度：$O(m\log m)$。</p>
<h2 id="Prim："><a href="#Prim：" class="headerlink" title="Prim："></a>Prim：</h2><p>过程：</p>
<p>类似于 Dijkstra。</p>
<p>将点集划分成两部分：</p>
<ul>
<li>不在已生成的“最小生成树”子集中的点。（T）</li>
<li>在已生成的“最小生成树”子集中的点。（S）</li>
</ul>
<p>每次在 S 中选择一个最小的连接 S 和 T 集合的边连接即可。</p>
<p>根据选取边的时间复杂度不同，可得不同的时间复杂度：</p>
<ul>
<li>暴力选取：$O(n^2+m)$。</li>
<li>二叉堆（优先队列）：$O(n\log n+m\log n)$，因为不用删除了，所以时间复杂度一致。</li>
<li>其它。</li>
</ul>
<h2 id="Boruvka："><a href="#Boruvka：" class="headerlink" title="Boruvka："></a>Boruvka：</h2><p>基本思路为，从一个集合连出一条最短边，合并两个集合。每一轮操作，每个集合都会被合并，集合个数至少减小一半，初始共有 $n$ 个集合，时间复杂度：$O(m\log n)$。</p>
<p>本质上，Boruvka 用于求给定图的最小生成森林，当图连通时，即为求最小生成树。</p>
<h2 id="次小生成树："><a href="#次小生成树：" class="headerlink" title="次小生成树："></a>次小生成树：</h2><p>结论：次小生成树和最小生成树只有一条边不同。</p>
<h2 id="瓶颈生成树（Kruskal重构树）："><a href="#瓶颈生成树（Kruskal重构树）：" class="headerlink" title="瓶颈生成树（Kruskal重构树）："></a>瓶颈生成树（Kruskal重构树）：</h2><p>将在 Kruskal 过程中连接的两点，视作生成树上两叶子，建立一个新节点作为两点的父节点。最后形成的树即为 Kruskal 重构树。</p>
<p>结论：</p>
<p>原图中，两点之间的瓶颈路的瓶颈即为 Kruskal 重构树上 LCA 的权值。</p>
<p>瓶颈路：路径上最小边权最大的路径&#x2F;路径上最大边权最小的路径。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构（六）</title>
    <url>/2024/01/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>字符串（一）</title>
    <url>/2024/01/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>字符串 Hash</p>
<span id="more"></span>

<p>定义把一个字符串映射到整数的函数 $f$，这个 $f$ 称为是 Hash 函数。</p>
<p>通过这个映射可以判断两个字符串是否相等。</p>
<p>attention：</p>
<p>注意区分哈希和字符串哈希，字符串哈希是哈希问题的一个子集。哈希的另一个经典应用为哈希表。本文介绍字符串哈希。</p>
<h2 id="进制哈希（多项式哈希）："><a href="#进制哈希（多项式哈希）：" class="headerlink" title="进制哈希（多项式哈希）："></a>进制哈希（多项式哈希）：</h2><p>将字符串视作一个 $|c|$ 进制数（$|c|$ 表示字符集大小），计算得到的结果即为 $f$ 的值。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>唯一确定，不会产生任何哈希冲突。</li>
<li>每一位字符独立。比如修改字符串中的某一个字符，只需要加减对应权值即可。</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>值域过大，映射的值与字符串长度呈强相关，在字符串长度较长时，存不下这么大的值。</li>
</ul>
<h2 id="多项式模数哈希（模哈）："><a href="#多项式模数哈希（模哈）：" class="headerlink" title="多项式模数哈希（模哈）："></a>多项式模数哈希（模哈）：</h2><p>即在多项式哈希的基础上，对最后的结果取模。</p>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>可以将字符串映射到 $[0,\bmod)$ 中，方便存储。</li>
<li>模运算具有优秀的性质，可以支持很多其它操作（比如修改字符串中的某一个字符，只需要加减取模即可）。</li>
</ul>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>映射范围较小容易产生哈希冲突。</li>
</ul>
<h2 id="多项式哈希冲突概率："><a href="#多项式哈希冲突概率：" class="headerlink" title="多项式哈希冲突概率："></a>多项式哈希冲突概率：</h2><p>设模数为 $\bmod$，则映射集合为 $[0,\bmod-1]$。</p>
<p>假设字符串随机分布，即哈希值随机分布（每次从 $[0,\bmod-1]$ 中随机选一个数）。</p>
<p>根据“生日悖论”，在随机 $\sqrt{\bmod}$ 次后，有约 $\dfrac{1}{2}$ 的概率产生冲突。</p>
<p>若产生冲突，则字符串哈希用于“判断两个字符串是否相同”的目的即失效。</p>
<p>所以在随机情况下，$\bmod$ 一般要超过 $\sqrt{\text{字符串数目}}$。</p>
<p>但是上述结论建立在随机的情况下，在实际场景中，往往可以通过对特定模数的特定构造，达到 $2$ 次即冲突的情况。</p>
<h2 id="双模数多项式哈希（双模哈）："><a href="#双模数多项式哈希（双模哈）：" class="headerlink" title="双模数多项式哈希（双模哈）："></a>双模数多项式哈希（双模哈）：</h2><p>即使用两个模数，分别进行多项式模数哈希，只有在两者结果均相同时，认为字符串相同。</p>
<p>同样考虑随机分布下，在随机 $\bmod$ 次后，有约 $\dfrac12$ 的概率产生冲突。</p>
<p>但是这并不能改变哈希冲突的可能性。</p>
<h2 id="构造哈希冲突："><a href="#构造哈希冲突：" class="headerlink" title="构造哈希冲突："></a>构造哈希冲突：</h2><p>前文中的“生日悖论”概率建立在随机分布意义下，但是由于取模运算本身的性质，哈希冲突并不完全是随机分布的。</p>
<p>考虑：$a\equiv x\pmod c$。</p>
<p>冲突的情况即为同余方程解的数目。</p>
<p>$a\equiv x\pmod c\Leftrightarrow x&#x3D;a+yc $</p>
<p>若 $\gcd(a,c)\neq 1$，令 $k&#x3D;\gcd(a,c)$，则 $x&#x3D;ka’+ykc’\rightarrow \frac{x}{k}&#x3D;a’+yc’$，即：解空间由 $\lbrace x\rbrace$ 变成了 $\lbrace\dfrac{x}{k}\rbrace$，若原本的冲突空间为 $[0,\bmod-1]$，此时则为 $[0,\dfrac{\bmod-1}{k}]$。</p>
<p>那么为了使冲突空间尽可能大，就要使 $\gcd(a,c)$ 尽可能小，直接让 $\gcd(a,c)&#x3D;1$ 即可，所以通常选取一个大质数作为模数。</p>
<h2 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h2><h3 id="求一个子串的哈希值："><a href="#求一个子串的哈希值：" class="headerlink" title="求一个子串的哈希值："></a>求一个子串的哈希值：</h3><p>因为本质上多项式哈希是给每一位字符一个权值然后全部加起来。那么对于一个区间 $[l,r]$ 的权值和，维护一个差分前缀和即可。</p>
<p>一个注意的点是：差分直接得到的是原串中的权值和，并不是一个新的字符串的哈希值（位的权值不一样）。要视作一个新的字符串，则要将权值和除以 ${|c|}^{l}$ 即可。</p>
<h3 id="字符串匹配："><a href="#字符串匹配：" class="headerlink" title="字符串匹配："></a>字符串匹配：</h3><p>直接判断哈希值是否相等即可。</p>
<h3 id="最长回文子串："><a href="#最长回文子串：" class="headerlink" title="最长回文子串："></a>最长回文子串：</h3><p>引理：若子串 $s<a href="r-l%3E1">l,r</a>$ 为回文串，则 $s[l-1,r-1]$ 也为回文串。</p>
<p>由引理可得，以回文串中点开始，回文串半径长度满足单调性。</p>
<p>所以可以枚举回文串中点，后二分半径长度，判断左右两部分是否一致即可。</p>
<p>因为左右两部分顺序相反，所以需要对原字符串顺着做一遍哈希后逆着再做一遍哈希。</p>
<h3 id="最长公共前缀（LCP）："><a href="#最长公共前缀（LCP）：" class="headerlink" title="最长公共前缀（LCP）："></a>最长公共前缀（LCP）：</h3><p>最长公共前缀显然也是满足二分性的，所以二分长度后哈希判断是否相同即可。</p>
<h3 id="本质不同回文子串："><a href="#本质不同回文子串：" class="headerlink" title="本质不同回文子串："></a>本质不同回文子串：</h3><p>一个字符串的本质不同回文子串规模为 $O(n)$（一个容易的证明是回文自动机（PAM）共有 $n$ 个节点）。所以可以使用字符串哈希将所有本质不同的回文子串存下来。</p>
<p>具体方法是：枚举回文串中点时，二分找到最长半径后暴力不断缩小半径，直到遇到出现过的回文子串后终止。</p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>字符串（三）</title>
    <url>/2024/01/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<p>KMP</p>
<span id="more"></span>

<p>KMP 算法是用于求在一个字符串中是否存在一个子串与另一个字符串相同的算法。</p>
<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>例 1：给定两个字符串 $s_1,s_2$，求 $s_1$ 在 $s_2$ 中的所有出现位置。</p>
<h2 id="naive："><a href="#naive：" class="headerlink" title="naive："></a>naive：</h2><p>考虑暴力匹配，枚举起点，不断判断 $s_{1,i+j-1}&#x3D;s_{2,j}$ 即可。</p>
<p>时间复杂度：$O(nm)$。</p>
<h2 id="KMP："><a href="#KMP：" class="headerlink" title="KMP："></a>KMP：</h2><p>注意到，暴力匹配较慢的原因是每次匹配失败后，都要从 $j&#x3D;1$ 重新开始。但是实际上，完全可以利用上一次匹配的结果，简化匹配次数。</p>
<p>假设起点为 $i$ 时，匹配到 $j$，那么下一次从 $i+1$ 开始匹配，若能匹配的比 $i$ 作为起点更远，则从 $i+1$ 开始一段连续字符一定是 $s_2$ 的一段前缀，同时也是 $s_1[i,i+j-1]$ 的一段后缀，也就是说 $s_1[i+1,i+j-1]$ 是 $s_2[1,j]$ 的最大 Border。而如果 $i+1$ 不能比 $i$ 匹配的更远，那么肯定不应该考虑。</p>
<p>综上，得到一个结论：从 $i$ 开始下一个可能会匹配成功的位置，一定是 $s_2$ 的 Border，</p>
<p>具体而言，匹配失败后，可以直接在 $i+(j-Border_j+1)$ 开始接着匹配。（其中，$Border_j$ 指的是 $s_2[1,j]$ 的 Border）</p>
<p>时间复杂度：$O(|s_1|+|s_2|)$。</p>
<p>同求 Border，将匹配时的起止点视作两个指针，两个指针都是单调递增的，所以时间复杂度是线性的。</p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>字符串（二）</title>
    <url>/2024/01/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>字符串基础</p>
<span id="more"></span>

<h2 id="基础定义："><a href="#基础定义：" class="headerlink" title="基础定义："></a>基础定义：</h2><p>字符串：一个由若干个字符组成的序列，通常写作 $S$。</p>
<p>字符串长度：字符串序列的大小，通常写作 $|S|$。</p>
<p>字符：字符串的某一个字符，通常写作 $S[i]$（虽然 string 从 $0$ 开始，但在书面中，通常认为从 $1$ 开始）</p>
<p>子串：字符串的某一段连续子序列，通常写作 $S[l,r]$。</p>
<p>前缀：从 $S[1]$ 开始的一段连续子序列，通常写作 $pre[i]&#x3D;S[1,i]$。</p>
<p>后缀：从 $S[|S|]$ 结束的一段连续子序列（长度为 $i$），通常写作 $suf[i]&#x3D;S[|S|-i+1,|S|]$。</p>
<h2 id="重要定义："><a href="#重要定义：" class="headerlink" title="重要定义："></a>重要定义：</h2><p>Border：若 $pre[i]&#x3D;suf[i]$，则称 $pre[i]$ 为 $S$ 的一个 Border（有时 Border 也指 $|pre[i]|$ 而不是一个具体的字符串）。</p>
<p>周期：若 $S[i]&#x3D;S[i-p](i\in [p+1,|S|])$，则称 $p$ 为 $S$ 的周期。</p>
<p>循环节：若周期 $p\mid |S|$，则称 $p$ 为 $S$ 的循环节。</p>
<h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><p>$p$ 是 $S$ 的周期，$|S|-p$ 是 $S$ 的 $Border$。</p>
<p>结合字符串哈希，可以 $O(1)$ 判断一个数是否是字符串周期。</p>
<h2 id="Border-的求法："><a href="#Border-的求法：" class="headerlink" title="Border 的求法："></a>Border 的求法：</h2><p>（一般而言，仅考虑一个字符串 $S$ 的 Border 时指的是不含 $S$ 本身的最大 Border）</p>
<p>引理：Border 的 Border 也是 Border。</p>
<p>假设已经求出了 $S[1,i]$ 的 Border，对于新的字符 $S[i+1]$，$S[1,i+1]$ 的 border 一定是 $S[1,i]$ 的 Border，所以只要枚举 $S[1,i]$ 的 Border(pre[j])，判断 $S[pre[j]+1]$ 和 $S[i+1]$ 是否相同即可。枚举 $S[1,i]$ 的 Border 就可以采用 Border 的 Border 还是 Border 的方式来实现了。</p>
<p>时间复杂度：$O(n)$。</p>
<p>因为在枚举 $S[1,i]$ 的 Border 的过程中，Border 对应的 $suf[j]$ 的 $j$ 是在不断变大的。和 $i$ 一样，$j$ 最多从 $1$ 增长到 $n$。所以总时间复杂度还是 $O(n)$ 的。</p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>字符串（四）</title>
    <url>/2024/01/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<p>Manacher</p>
<span id="more"></span>

<p>Manacher 是用于在 $O(n)$ 的时间复杂度内求出给定字符串所有回文子串的算法。</p>
<h2 id="回文串："><a href="#回文串：" class="headerlink" title="回文串："></a>回文串：</h2><p>满足 $S[1,|S|]&#x3D;S[|S|,1]$ 的字符串 $S$ 被称为回文串。</p>
<p>性质：对于回文串 $S$，满足 $S[1,\lfloor\frac{|S|}{2}\rfloor]&#x3D;S[n,|S|-\lfloor\frac{|S|}{2}\rfloor]$，即回文串是中心对称的。</p>
<p>所以假设确定了对称中心和半径，那么回文串也就确定了。</p>
<h3 id="Manacher："><a href="#Manacher：" class="headerlink" title="Manacher："></a>Manacher：</h3><p>首先，需要将回文子串分为奇数长或偶数长。若回文串为偶数长，则其对称中心为空字符；若回文串为奇数长，则其对称中心为任意字符。</p>
<p>先考虑奇数长：</p>
<p>假设以 $[1,i]$ 为对称中心的最长回文子串的半径已求好，为 $d_1[i]$，要求 $d_1[i+1]$ 考虑以下两种情况：</p>
<ul>
<li>$\max\lbrace i+d_1[i]\rbrace&lt;i+1$，暴力增大 $d_1[i+1]$ 判断是否合法。</li>
<li>$\max\lbrace i+d_1[i]\rbrace\geq i+1$，考虑在对应的 $\max\lbrace i+d_i\rbrace$ 的回文串中，以 $i’$ 为对称中心，$i+1$ 的对称点 $i’’$。若 $d_1[i’’]\leq i’+d_1[i’]-(i+1)$，那么 $d[i+1]$ 至少为 $d[i’’]$；反之 $d[i+1]$ 至少为 $i’+d_1[i’]-(i+1)$。再暴力增大 $d_1[i+1]$ 判断是否合法即可。</li>
</ul>
<p>时间复杂度：$O(n)$。</p>
<p>$\max\lbrace i+d_1[i]\rbrace$ 全局维护，当 $d_1[i]$ 更新时，$\max\lbrace i+d_1[i]\rbrace$ 也一定会更新。那么暴力修改 $d_1[i]$ 的次数即为 $O(n)$。</p>
<p>偶数同样处理即可。</p>
<h3 id="特殊处理："><a href="#特殊处理：" class="headerlink" title="特殊处理："></a>特殊处理：</h3><p>也可以通过一定的特殊处理，将回文串偶数和奇数长度的情况划归到一类中处理。在每两个相邻字符之间插入一个分隔符 <code>#</code>，后按奇数处理方式处理即可。<code>#</code> 为对称中心的情况即为回文串长度为偶数时的情况。</p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>字符串（五）</title>
    <url>/2024/02/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<p>Trie</p>
<span id="more"></span>

<p>Trie 是用于维护一个字符串集合，判断某字符串是否在集合中出现的数据结构。</p>
<p>Trie 又叫字典树，就像它的功能一样，用于维护一个“字典”，其中存储若干字符串。</p>
<p>实际上，Trie 是一种前缀数据结构。不同字符串的相同前缀在 Trie 上是相同的部分。</p>
<img src="/2024/02/05/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E4%BA%94%EF%BC%89/1.png" class="" title="咕咕咕">

<p>形式化而言，对于一个字符串 $S$，$S[i]$ 是 Trie 上第 $i+1$ 层的节点（因为所有字符串首字符不尽相同，所以需要一个公共根节点）。在 Trie 上，$S[i]$ 的父节点是 $S[i-1]$。</p>
<h2 id="插入："><a href="#插入：" class="headerlink" title="插入："></a>插入：</h2><p>插入 $S$，从根节点出发，先访问根节点的 $S[1]$ 儿子，再访问 $S[1]$ 的 $S[2]$ 儿子，依次往复，直至插入 $S[|S|]$。在插入过程中，若对应儿子节点为空，则新建节点；若经过的所有点均存在，则在 $S[|S|]$ 对应节点的计数数组加 $1$，表示 $S$ 出现次数加 $1$。</p>
<h2 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h2><p>询问 $S$ 是否出现。与插入类似，在访问到 $S[|S|]$ 过程中，若出现空节点则说明未出现；反之还要判断对应计数数组（因为可能是某个出现的字符串的前缀而不是整个字符串）。</p>
<h2 id="01-Trie"><a href="#01-Trie" class="headerlink" title="01-Trie:"></a>01-Trie:</h2><p>01-Tire 即用于存储 01 串的 Trie。</p>
<p>例：给定 $n$ 个数 $a_i$，求任意两数异或和的最大值。</p>
<p>对于一个给定数 $a_i$，考虑如何选择另一个 $a_j$ 使得 $a_i\oplus a_j$ 最大。</p>
<p>首先，长度不变情况下，比较数值大小，等价于比较字典序。所以要“贪心”地使最高位尽可能地大（在 $01$ 串中，即为要尽可能地为 $1$）。</p>
<p>所以从最高位开始，若 $a_i$ 对应位为 $0$，则 $a_j$ 尽可能为 $1$；反之为 $0$。那么在 01-Trie 上从 $a_i$ 的二进制表达的最高位开始，访问与 $a_i$ 相反的对应位即可。</p>
<p>时间复杂度：$O(n\log n)$。</p>
<p>因为每个数都要在 01-Trie 上求一遍，单次时间复杂度为 01-Trie 的深度，而 01-Trie 深度即为 $a_i$ 的二进制位数。</p>
]]></content>
      <categories>
        <category>字符串</category>
      </categories>
  </entry>
  <entry>
    <title>数学（三）</title>
    <url>/2024/03/06/%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><span id="more"></span>

<h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>若正整数 $a$ 的约数只有 $1$ 和 $a$，则称 $a$ 是质数。特殊地，$1$ 不是质数。</p>
<p>质数又称素数。</p>
<h2 id="性质："><a href="#性质：" class="headerlink" title="性质："></a>性质：</h2><h3 id="互质："><a href="#互质：" class="headerlink" title="互质："></a>互质：</h3><p>质数和除它倍数外的任意整数互质。</p>
<h3 id="哥德巴赫猜想："><a href="#哥德巴赫猜想：" class="headerlink" title="哥德巴赫猜想："></a>哥德巴赫猜想：</h3><p>任一大于 $2$ 的偶数都可写成两个质数之和。</p>
<h3 id="费马小定理："><a href="#费马小定理：" class="headerlink" title="费马小定理："></a>费马小定理：</h3><p>对于质数 $p$ 和任意满足 $p\not\mid a$ 的整数 $a$，$a^{p-1}\equiv 1\pmod p$。</p>
<p>费马小定理最大的应用是求逆元，对于满足费马小定理的整数 $a,p$，$a\times a^{p-2}\equiv 1\pmod p$，所以 $a$ 的逆元就是 $a^{p-2}$，通常结合快速幂即可在 $O(\log n)$ 的时间内解决。</p>
<h3 id="质数密度："><a href="#质数密度：" class="headerlink" title="质数密度："></a>质数密度：</h3><p>用 $\pi(n)$ 表示 $[1,n]$ 中的质数个数。</p>
<p>$\pi(n)\approx \dfrac{n}{\ln n}$，即：通常认为质数个数为 $O(\dfrac{n}{\log n})$ 级别的。</p>
<h3 id="质数距离："><a href="#质数距离：" class="headerlink" title="质数距离："></a>质数距离：</h3><p>由质数密度容易猜想，任意两个质数之间的非质数数量不会特别多。</p>
<p>事实也确实如此，所以若要寻找比 $x$ 大的最小质数，可以暴力向后枚举判断是否是质数。</p>
<h3 id="唯一分解定理："><a href="#唯一分解定理：" class="headerlink" title="唯一分解定理："></a>唯一分解定理：</h3><p>任意整数均可唯一分解成若干质数幂次之积的形式：$x&#x3D;p_1^{a_1}p_2^{a_2}…p_n^{a_n}$，其中 $p_i$ 表示从 $2$ 开始第 $i$ 个质数。</p>
<h2 id="质数检测："><a href="#质数检测：" class="headerlink" title="质数检测："></a>质数检测：</h2><p>即判断一个数是否是质数。</p>
<h3 id="暴力："><a href="#暴力：" class="headerlink" title="暴力："></a>暴力：</h3><p>求出 $[1,n]$ 内的所有整除 $n$ 的数。</p>
<p>时间复杂度：$O(n)$。</p>
<h3 id="根号均衡："><a href="#根号均衡：" class="headerlink" title="根号均衡："></a>根号均衡：</h3><p>$a\times b&#x3D;n,\min\lbrace a,b\rbrace\leq \sqrt n$。</p>
<p>对于一个数的约数，它们是成对出现的。确定了其中之一，那么另一个也就确定了。</p>
<p>而根据上述不等式，启发我们，如果只枚举 $\min\lbrace a,b\rbrace$，那么只需要枚举到 $\sqrt n$ 即可。</p>
<p>时间复杂度：$O(\sqrt n)$。</p>
<h3 id="质数优化："><a href="#质数优化：" class="headerlink" title="质数优化："></a>质数优化：</h3><p>引理：若 $a\mid b,b\mid c$，则 $a\mid c$。</p>
<p>同时，质数是不存在大于 $1$ 的真因子的，所以可以只判断 $[1,\sqrt n]$ 的质数是否是 $n$ 的约数即可。</p>
<p>或者根据唯一分解定理，也可以得知只要判断质因子即可。</p>
<p>根据质数密度，可得时间复杂度：$O(\dfrac{\sqrt n}{\log\sqrt n})$，一般可直接写作 $O(\dfrac{\sqrt n}{\log n})$。</p>
<h3 id="Miller-Rabin："><a href="#Miller-Rabin：" class="headerlink" title="Miller-Rabin："></a>Miller-Rabin：</h3><p>根据费马小定理，若 $p$ 是质数，则 $a^{p-1}\equiv 1\pmod p$，所以如果要检测 $p$ 是不是质数，可以尝试判断 $a^{p-1} \bmod p$ 的结果是否为 $1$。若不为 $1$ 则 $p$ 一定不是质数，但是反之不然。</p>
<p>所以仅仅判断 $a^{p-1}\bmod p$ 的结果是不够的。</p>
<p>注意到，若 $a^{\frac{p-1}{2}}\bmod p$ 的结果不是 $1$ 或 $p-1$，而 $a^{p-1}\bmod p$ 的结果是 $1$，那么 $p$ 一定不是质数。所以不断对指数除以 $2$ 判断即可。</p>
<p>同时，$\dfrac{p-1}{2}$ 可能就已经不是偶数了，所以一个底数可能还是不够，因此可以多选几个底数。一般选前 $9$ 个质数即可，或者随机生成几个数也行。</p>
<p>由上可以发现，这是一个随机化算法，其正确性和哈希冲突类似，同样是生日悖论模型，只要出现一次不是 $1$ 或 $p-1$，即可认为不是质数，在多次检测过后还是错误的概率会非常小。</p>
<p>一个小细节是因为指数按 $2$ 倍递增，所以可以每次按 $2$ 倍增，总的时间复杂度为 $O(c\log n)$，其中 $c$ 为选择用于检测的底数个数。</p>
<h2 id="分解质因数："><a href="#分解质因数：" class="headerlink" title="分解质因数："></a>分解质因数：</h2><p>即求出一个数的所有质因数（一般认为也需要求出对应指数）。</p>
<h3 id="暴力分解："><a href="#暴力分解：" class="headerlink" title="暴力分解："></a>暴力分解：</h3><p>此处暴力分解指根号均衡时的暴力分解，根号均衡质数检测时，若某质数是 $x$ 的因子，则不断将 $x$ 除以此质数，因为根据唯一分解定理，将某质因子从 $x$ 中除去后，并不影响后续别的质因子的分解。</p>
<p>时间复杂度：$O(\dfrac{\sqrt n}{\log n})$。</p>
<p>若在分解除以质因子的同时判断当前枚举的质数$\leq \sqrt x$，则对于实际运行中的平均效率而言，普遍跑不满这个 $O(\dfrac{\sqrt n}{\log n})$。当然，最坏情况还是会跑满的（即：$x&#x3D;p_i^2$ 时）。</p>
<h3 id="枚举倍数："><a href="#枚举倍数：" class="headerlink" title="枚举倍数："></a>枚举倍数：</h3><p>若枚举 $i$，同时枚举 $i$ 的倍数，将 $i$ 作为因子放到 $i$ 的倍数的因子集合中。则可以处理出 $[1,n]$ 所有数的所有约数。时间复杂度：$O(n\log n)$。</p>
<p>因为调和级数：$\dfrac11+\dfrac12+…+\dfrac1n\approx\ln n$。</p>
<p>若仅仅需要质因子，也容易，因为质数的约数只有 $1$ 和它本身，所以当从小到大枚举到 $i$ 时，$i$ 对于的约数集合只有 $1$，那么它就是质数。</p>
<p>（所以，使用此方法也可以筛质数。或者说，这本质上和埃氏筛的基本思想是一致的）</p>
<h3 id="Pollard-rho："><a href="#Pollard-rho：" class="headerlink" title="Pollard-rho："></a>Pollard-rho：</h3><p>Pollard-rho 同样是一种随机化算法。</p>
<p>考虑一个数列：$x_n&#x3D;(x_{n-1}^2+c)\bmod p$，期望经过多少项后会有两项值相等。</p>
<p>同样是“生日悖论”模型，大约 $O(\sqrt p)$ 项后会出现相同的两项。</p>
<p>引理：若 $p&#x3D;p_1\times p_2$，则 $x_n&#x3D;(x_{n-1}^2+c)\bmod p$ 的循环节是 $x_n&#x3D;(x_{n-1}^2+c)\bmod p_1$ 和 $x_n&#x3D;(x_{n-1}^2+c)\bmod p_2$ 的倍数。</p>
<p>根据引理可得，$p$ 对于数列的循环节一定是 $p_1,p_2$ 的循环节。</p>
<p>但是无法确定，所以第 $n$ 项和前 $[1,n-1]$ 项都做差，那么其中一定会有一个 $p_1$ 或 $p_2$ 的循环节。根据前文内容，可得这个 $n$ 是期望 $O(\sqrt{p_1}),O(\sqrt{p_2})$ 的。</p>
<p>引理：$\gcd(a,b)\mid b$。</p>
<p>求 $\gcd(a,b)$，是容易的，通过辗转相除法可以 $O(\log n)$ 求得，所以若 $\gcd(a,b)\neq 1\land\gcd(a,b)\neq b$，则我们就得到了 $b$ 的一个非平凡因子。</p>
<p>（所以也就是说，最理想状态下，随机一个数，然后用它和 $n$ 求 $\gcd$ 就得到了 n 的一个因子，然后不断递归，可以 $O(\log n)$ 分解质因数。同时，一个数的质因数规模最大就是 $O(\log n)$ 的，所以分解质因数的理论时间复杂度不应该比 $O(\log n)$ 还快）</p>
<p>所以，判断 $n$ 是否是循环节的方式就是作差后求 $\gcd$ 然后判断是否是 $1$。</p>
<p>综上：即可在单次期望 $O(\sqrt p_1\log p)$ 的时间复杂度内得到 $p$ 的一个因数（算上求 $\gcd$ 的时间复杂度）。</p>
<p>引理：$\exist\ i\in[1,m],\gcd(a_i,n)\neq 1$，则 $\gcd(a_1\times a_2\times…\times a_m,n)\neq 1$。</p>
<p>引理：$p&#x3D;p_1\times p_2$，若 $p_1\mid a$，那么满足 $a\mid b$ 的 $b$ 对 $p$ 取模后的结果还是 $p_1$ 的倍数。</p>
<p>根据引理，结合 Pollard-rho 期望的是找到那个不等于 $1$ 的 $\gcd$，所以可以将 $\log n$ 次差的结果乘起来作 $\gcd$，这样均摊后的时间复杂度就能做到 $O(\sqrt p)$。</p>
<p>而根据前文的根号均衡 $\min\lbrace p_1,p_2\rbrace\leq \sqrt p$，所以一般认为 Pollard-rho 的时间复杂度为 $O(\sqrt{\sqrt n})&#x3D;O(n^{\frac14})$。</p>
<p>而要完全质因数分解一个数，则需要分解 $O(\log n)$ 次因子。</p>
<p>（上述时间复杂度模型相当于每次划分指数集合，每次划分后的集合大小都会变小，划分到 $1$ 为止，最后的划分次数就是初始集合大小，而质因数分解后的指数大小为 $O(\log n)$，那么即分解 $O(\log n)$ 次因子）</p>
<p>综上：Pollard-rho 分解质因数的总时间复杂度为：$O(n^{\frac14}\log n)$。</p>
<p>tips：</p>
<p>实际上，Pollard-rho 分解到质数后，不存在非平凡因子了，时间复杂度就失效了，所以还要特判当前递归状态是否是质数。（根据质数检测的时间复杂度不同，时间复杂度不同，但是由于质因子只有 $O(\log n)$，所以只要进行 $O(\log n)$ 次质数检测，使用 Miller-Rabin 的话不会影响时间复杂度瓶颈）</p>
<h2 id="筛质数："><a href="#筛质数：" class="headerlink" title="筛质数："></a>筛质数：</h2><p>筛质数是指预处理 $[1,n]$ 的所有质数。</p>
<h3 id="埃氏筛："><a href="#埃氏筛：" class="headerlink" title="埃氏筛："></a>埃氏筛：</h3><p>基本思想是一个大于 $1$ 的整数的不为自身的倍数不会是质数。</p>
<p>所以从小到大枚举 $i$，然后标记它的所有倍数即可。若枚举到 $i$ 的时候，$i$ 没有被标记过，则 $i$ 是一个质数。</p>
<p>根据调和级数，时间复杂度：$O(n\log n)$。</p>
<p>埃氏筛优化：</p>
<p>根据根号均衡的思路，枚举倍数时，另一个乘数，可以从 $i$ 开始枚举，而不是 $2$。</p>
<p>通过此优化，时间复杂度优化至：$O(n\log\log n)$。</p>
<h3 id="欧拉筛（线性筛）："><a href="#欧拉筛（线性筛）：" class="headerlink" title="欧拉筛（线性筛）："></a>欧拉筛（线性筛）：</h3><p>基本思想同样是标记每一个非质数，但是用 $x$ 最小的质因数标记它。保证了每个数最多被标记一次，所以时间复杂度为 $O(n)$。$O(n)$ 时间复杂度即线性，所以欧拉筛也通常被称为线性筛。</p>
<p>具体流程，仍然从小到大枚举 $i$，然后枚举 $[1,i]$ 处理好的质数，标记 $i\times p_j$，若 $i\equiv 0\pmod {p_j}$，则停止标记过程，继续枚举 $i$。当枚举到的 $i$ 未被标记时，$i$ 就是质数。</p>
<h3 id="其它筛："><a href="#其它筛：" class="headerlink" title="其它筛："></a>其它筛：</h3><p>还有许多其它的筛法。但是算法竞赛中以上两种筛法足以应付几乎所有情况了。</p>
<p>因为质数密度为 $O(\dfrac{n}{\log n})$ 的，所以任何筛法的时间复杂度都不会低于这个阈值。</p>
<h3 id="扩展："><a href="#扩展：" class="headerlink" title="扩展："></a>扩展：</h3><p>欧拉筛也常用作预处理积性函数。事实上 $prime(i)&#x3D;\begin{cases}1&amp; i\ is\<br>a\ prime\0&amp;else\end{cases}$ 也是一个积性函数。</p>
<p>addition：</p>
<p>由于质数筛的标记数组只存在 $0&#x2F;1$，所以若使用 bitset 存储，其效率会得到不小的提升。相较 bool 数组，空间也能得到优化。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>数学（一）</title>
    <url>/2024/03/06/%E6%95%B0%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前置知识："><a href="#前置知识：" class="headerlink" title="前置知识："></a>前置知识：</h2><span id="more"></span>

<h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><h4 id="带余除法："><a href="#带余除法：" class="headerlink" title="带余除法："></a>带余除法：</h4><p>给定一个整数 $a$ 和一个正整数 $q$，总能找到一个整数 $b$ 使得 $a&#x3D;bq+r(0\leq r&lt;q)$。我们称 $r$ 为 $a$ 被 $q$ 除的余数。</p>
<h4 id="模运算："><a href="#模运算：" class="headerlink" title="模运算："></a>模运算：</h4><p>对于一个带余除法：$a&#x3D;bq+r$，可表述为 $a\bmod q&#x3D;r$。</p>
<h4 id="同余："><a href="#同余：" class="headerlink" title="同余："></a>同余：</h4><p>若 $a&#x3D;b_1q+r,A&#x3D;b_2q+r$，则称 $a,A$ 同余，写作 $a\equiv A\pmod q$。</p>
<h4 id="整除："><a href="#整除：" class="headerlink" title="整除："></a>整除：</h4><p>若 $a&#x3D;bq+r,r&#x3D;0$ 即 $a&#x3D;bq$，则称 $q$ 整除 $a$。</p>
<h4 id="约数和倍数："><a href="#约数和倍数：" class="headerlink" title="约数和倍数："></a>约数和倍数：</h4><p>如果一个整数 $a$ 能被正整数 $b$ 整除，则称 $a$ 是 $b$ 的倍数，$b$ 是 $a$ 的约数。</p>
<p>tips:</p>
<ul>
<li>约数和倍数是定义在整数域上的概念。</li>
<li>正整数 $a$ 的两个倍数的和差还是 $a$ 的倍数。</li>
<li>约数一定是正整数，倍数可以是负整数或零。（负整数的约数等价于它的相反数的约数）</li>
<li>$0$ 的约数为全体正整数，$0$ 没有倍数的定义。</li>
</ul>
<h4 id="最大公约数和最小公倍数："><a href="#最大公约数和最小公倍数：" class="headerlink" title="最大公约数和最小公倍数："></a>最大公约数和最小公倍数：</h4><p>如果正整数 $p$ 同时是两个整数 $a,b$ 的约数，我们就称 $p$ 为 $a,b$ 的公约数。$a,b$ 的所有公约数中最大的那个数被称为 $a,b$ 的最大公约数。</p>
<p>如果正整数 $p$ 同时是两个整数 $a,b$ 的倍数，我们就称 $p$ 为 $a,b$ 的公倍数。$a,b$ 的所有公倍数中最小的那个数被称为 $a,b$ 的最小公倍数。</p>
<p>tips:</p>
<ul>
<li>$0,0$ 不存在最大公约数。</li>
<li>任何整数和 $0$ 的最大公约数都是它本身。</li>
</ul>
<h4 id="质数："><a href="#质数：" class="headerlink" title="质数："></a>质数：</h4><p>对于一个正整数 $a$，如果 $a$ 只有 $1$ 和 $a$ 两个约数，就称它为质数。</p>
<p>两个整数的最大公约数如果为 $1$，就称这两个数是互质的。</p>
<h3 id="常见符号："><a href="#常见符号：" class="headerlink" title="常见符号："></a>常见符号：</h3><ul>
<li>整除符号：$x\mid y$，表示 $x$ 整除 $y$。</li>
<li>取模符号：$x\bmod y$，表示 $x$ 除以 $y$ 得到的余数。</li>
<li>互质符号：$x\perp y$，表示 $x,y$ 互质。</li>
<li>最大公约数：$\gcd(x,y)$，在无混淆意义的时候可以写作 $(x,y)$。</li>
<li>最小公倍数：$\text{lcm}(x,y)$，在无混淆意义的时候可以写作 $[x,y]$。</li>
<li>阶乘：$x!&#x3D;1\times2\times3\times…\times x$。</li>
<li>向下取整：$\lfloor x\rfloor$，表示小于等于 $x$ 的最小整数。</li>
<li>向上取整：$\lceil x\rceil$，表示大于等于 $x$ 的最小整数。</li>
<li>组合数：$\binom{x}{y}$，即：$C_x^y$。</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>数学（四）</title>
    <url>/2024/03/06/%E6%95%B0%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><span id="more"></span>

<h2 id="引入："><a href="#引入：" class="headerlink" title="引入："></a>引入：</h2><p>求 $a^b\bmod p(1\leq a,b,p\leq 10^9)$。</p>
<p>$a^{2b}&#x3D;(a^b)^2$，所以若 $b$ 是 $2$ 的一个整数幂，那就容易了，因为一定可以变型成 $a^{2^{2^{2^·}}}$ 的形式，每次只要计算一个新的平方即可，总共只要计算 $O(\log b)$ 次即可。</p>
<p>若 $b$ 不是 $2$ 的一个整数幂，其实也不复杂，只要把 $b$ 拆成 $\frac{b-1}{2}$ 和 $\frac{b+1}2$ 即可。对 $\frac{b-1}2$ 和 $\frac{b+1}2$ 同样递归即可。可以证明，最后出现的不同数字为 $O(\log b)$ 级别的。</p>
<p>但是仅仅递归的话，可能还需要记忆化。所以一般会写成递推（迭代的形式）。或是以下二进制指数的等价表示。</p>
<p>$a^b&#x3D;a^{b(2)}$，$b(2)$ 为 $b$ 的二进制表达。</p>
<p>$a^b&#x3D;\prod a^{p_i}$，其中 $p_i&#x3D;2^i$，满足 $p_i$ 是 $b(2)$ 中的 $1$ 位。</p>
<p>此时，就只需要计算 $a$ 的 $2$ 的整数幂次即可。可以预处理后按照 $b$ 的二进制表达计算即可。</p>
<p>时间复杂度：$O(\log b)$。</p>
<h2 id="X-进制快速幂："><a href="#X-进制快速幂：" class="headerlink" title="X 进制快速幂："></a>X 进制快速幂：</h2><p>通常使用的快速幂为二进制快速幂，即把 $b$ 视作一个二进制数后去考虑计算。</p>
<p>但是其本质是按位算贡献，所以同样可以扩展到 $X$ 进制快速幂。</p>
<p>$a^b&#x3D;\prod a^{A_i\times p_i}$，其中 $p_i&#x3D;X^i$，$A_i$ 是系数，因为二进制只有 $0&#x2F;1$，但是 $X$ 进制有 $[0,X-1]$。</p>
<p>所以预处理就不能只处理 $a$ 的 $X$ 的整数次幂了。共需要 $O(X\log_X^b)$ 的预处理。</p>
<p>因此 $X$ 进制快速幂的时间复杂度为：$O(X\log_X^b)$（容易发现二进制快速也符合这个式子）</p>
<p>X 进制的一个优势也在于，若题目给出的数是一个较大的整数（不能用整型变量存储 $b$，则可以直接按位算贡献）</p>
<h2 id="光速幂："><a href="#光速幂：" class="headerlink" title="光速幂："></a>光速幂：</h2><p>若多次询问 $a^b\bmod p$，但是底数 $a$ 是相同的，可以通过 $O(\sqrt b)$ 预处理，做到 $O(1)$ 处理单次询问。</p>
<p>本质是一种大步小步算法。</p>
<p>考虑一个整数 $b$ 一定可以写成 $x\sqrt{b_{max}}+y$ 的形式，其中 $x,y\leq \sqrt{b_{max}}$。得到 $x,y$ 的方式也简单，$x&#x3D;\lfloor\frac{b}{\sqrt{b_{max}}}\rfloor,y&#x3D;b\bmod \sqrt{b_{max}}$。</p>
<p>所以预处理 $a^{0},…,a^{\sqrt{b_{max}}-1}\bmod p$ 的值，再预处理 $a^{\sqrt{b_{max}}},…,a^{\sqrt{b_{max}}\times\sqrt{b_{max}}}$ 的值。询问的时候做一次乘法即可。</p>
<p>时间复杂度：$O(\sqrt{b_{max}})$。</p>
<h2 id="龟速乘："><a href="#龟速乘：" class="headerlink" title="龟速乘："></a>龟速乘：</h2><p>龟速乘用于解决模数较大的情况。</p>
<p>例如：求 $a\times b\bmod p(1\leq a,b,p\leq 10^{18})$。</p>
<p>最后的结果一定 $\leq 10^{18}$，但是乘的过程超过了 $10^{18}$。</p>
<p>不能计算出结果后再取模。</p>
<h3 id="解-1："><a href="#解-1：" class="headerlink" title="解 1："></a>解 1：</h3><p>转成 long double，再把取模变成带余除法。</p>
<p>有精度问题。</p>
<h3 id="解-2："><a href="#解-2：" class="headerlink" title="解 2："></a>解 2：</h3><p>将乘法变成加法。$b+b$ 并没有超过 long long，考虑 $a$ 的二进制表达，原式可变型为 $\sum 2^i\times b$，这个 $2$ 的整数幂同样累积预处理即可。每次只需要对一个 $10^{18}$ 的数做一个乘 $2$ 即可。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>数学（二）</title>
    <url>/2024/03/06/%E6%95%B0%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><span id="more"></span>

<h2 id="欧拉函数："><a href="#欧拉函数：" class="headerlink" title="欧拉函数："></a>欧拉函数：</h2><p>$\varphi(n)$ 表示 $[1,n]$ 中和 $n$ 互质的数的个数。</p>
<h3 id="欧拉函数的计算："><a href="#欧拉函数的计算：" class="headerlink" title="欧拉函数的计算："></a>欧拉函数的计算：</h3><h4 id="公式计算："><a href="#公式计算：" class="headerlink" title="公式计算："></a>公式计算：</h4><p>$\varphi(n)&#x3D;n\times(1-\frac{1}{p_1})\times…\times(1-\frac{1}{p_m})$，其中 $p_1,…,p_m$ 是 $n$ 的质因子。</p>
<p>时间复杂度同质因数分解。</p>
<h4 id="通过-varphi-n-得到-varphi-d-d-mid-n-："><a href="#通过-varphi-n-得到-varphi-d-d-mid-n-：" class="headerlink" title="通过 $\varphi(n)$ 得到 $\varphi(d),d\mid n$："></a>通过 $\varphi(n)$ 得到 $\varphi(d),d\mid n$：</h4><p>若得到了 $\varphi(n)$，可以通过 dfs 枚举质因数指数，$O(\sqrt n)$ 得到所有 $\varphi(d),d\mid n$。</p>
<h4 id="筛法计算："><a href="#筛法计算：" class="headerlink" title="筛法计算："></a>筛法计算：</h4><p>等价于筛法求积性函数。</p>
<p>$\varphi(i\times p)&#x3D;\varphi(i)\times p,p\mid i$，$\varphi(i\times p)&#x3D;\varphi(i)\times \varphi(p),p\not\mid i$。</p>
<p>特殊地，$\varphi(p)&#x3D;p-1$。</p>
<h3 id="欧拉定理："><a href="#欧拉定理：" class="headerlink" title="欧拉定理："></a>欧拉定理：</h3><p>$\gcd(a,p)&#x3D;1,a^{\varphi(p)}\equiv 1\pmod p$。</p>
<h3 id="扩展欧拉定理："><a href="#扩展欧拉定理：" class="headerlink" title="扩展欧拉定理："></a>扩展欧拉定理：</h3><p>$a^b\equiv\begin{cases}a^{b\bmod\varphi(p)}&amp;\gcd(a,p)&#x3D;1\a^b&amp;\gcd(a,p)\neq1,b\leq\varphi(p)\a^{b\bmod \varphi(p)+\varphi(p)}&amp;\gcd(a,p)\neq1,b\geq\varphi(p)\end{cases}\pmod p$</p>
<h4 id="欧拉降幂："><a href="#欧拉降幂：" class="headerlink" title="欧拉降幂："></a>欧拉降幂：</h4><p>求 $a^{2^{2^{2^{2^{.^{.^.}}}}}}\bmod p$。</p>
<p>运用扩展欧拉定理不断对指数递归 $\bmod \varphi(p)+\varphi(p)$ 即可。</p>
<p>欧拉降幂是扩展欧拉定理的一个特殊情况，其核心是：$\varphi(\varphi(\varphi(…)))$ 不断递归后，大约在 $\log n$ 次后到 $1$。</p>
<h2 id="群论："><a href="#群论：" class="headerlink" title="群论："></a>群论：</h2><p>群是有运算和变换方法的集合，写作 $(G,\cdot)$。$G$ 表示元素集合，$\cdot$ 表示运算。</p>
<p>一个群要满足下面四个性质：</p>
<ul>
<li>封闭性：对于所有 $a,b\in G$，$a\cdot b\in G$。</li>
<li>结合律：对于所有 $a,b,c\in G$，$(a\cdot b)\cdot c&#x3D;a\cdot(b\cdot c)$。</li>
<li>单位元：$G$ 中存在唯一一个 $e$，满足对于所有 $a\in G,a\cdot e&#x3D;e\cdot a&#x3D;a$。</li>
<li>逆元：对于所有 $a\in G$，总存在一个元素 $b$（可以 $b&#x3D;a$），使得 $a\cdot b&#x3D;b\cdot a&#x3D;e$，称 $b$ 为 $a$ 的逆元，写作 $a^{-1}$。可以发现，实际上 $a,b$ 互为逆元。</li>
</ul>
<h3 id="模意义下的乘法群："><a href="#模意义下的乘法群：" class="headerlink" title="模意义下的乘法群："></a>模意义下的乘法群：</h3><h4 id="同余定理："><a href="#同余定理：" class="headerlink" title="同余定理："></a>同余定理：</h4><p>$a+b\equiv (a\bmod p)+(b\bmod p)\pmod p$</p>
<p>$a\times b\equiv (a\bmod p)\times (b\bmod p)\pmod p$</p>
<ul>
<li>封闭性：$a\in G,b\in G,a\times b\equiv ab\in G$。</li>
<li>结合律：$a\times b\equiv b\times a$。</li>
<li>单位元：$a\times 1\equiv 1\times a$。</li>
</ul>
<h4 id="逆元："><a href="#逆元：" class="headerlink" title="逆元："></a>逆元：</h4><p>逆元：$ab\equiv 1$。</p>
<p>此时，逆元没有那么显然。甚至不那么确定是否一定存在逆元。</p>
<p>考虑同余方程 $ax\equiv 1\pmod p$，此方程有解，当且仅当 $\gcd(a,p)\mid 1$，即 $\gcd(a,p)&#x3D;1$。</p>
<p>所以对于一个固定的模数 $p$，只有 $\gcd(a,p)&#x3D;1$ 的 $a\in G$。</p>
<h5 id="求逆元："><a href="#求逆元：" class="headerlink" title="求逆元："></a>求逆元：</h5><p>对于一般存在的逆元，使用 exgcd 解同余方程即可。</p>
<p>对于模数为质数的逆元，使用费马小定理结合快速幂即可。</p>
<p>时间复杂度：$O(\log p)$。</p>
<h5 id="线性预处理逆元："><a href="#线性预处理逆元：" class="headerlink" title="线性预处理逆元："></a>线性预处理逆元：</h5><p>求 $a_1,…,a_n$ 每个数的逆元。</p>
<p>令 $f(n)\equiv\prod\limits_{i&#x3D;1}^n a_i$，$g(n)&#x3D;f(n)^{-1}$。</p>
<p>$O(n)$ 即可预处理 $f(i)$。</p>
<p>而 $g(n)&#x3D;f(n)^{-1}$，单次 $O(\log n)$ 即可求得。</p>
<p>$g(i)$ 根据 $g(i-1)&#x3D;g(i)\times a_i$，从 $g(n)$ 递推即可。</p>
<p>总时间复杂度：$O(n)$。</p>
<h2 id="阶："><a href="#阶：" class="headerlink" title="阶："></a>阶：</h2><p>满足 $a^r\equiv 1\pmod n$ 的最小正整数 $r$，称为 $a$ 模 $n$ 的阶，要求 $\gcd(a,n)&#x3D;1$。记作 $\delta_n(a)&#x3D;r$</p>
<p>性质：</p>
<ul>
<li>$a^1,…,a^r \bmod n$ 的结果两两不同。</li>
<li>若 $a^i\equiv a^j\pmod n(0\leq i,j)$，则 $i\equiv j\pmod r$。</li>
</ul>
<h2 id="原根："><a href="#原根：" class="headerlink" title="原根："></a>原根：</h2><p>若 $\delta_n(a)&#x3D;\varphi(n)$，则称 $a$ 是 $n$ 的原根。原根一般写作 $g$。</p>
<h3 id="原根存在定理："><a href="#原根存在定理：" class="headerlink" title="原根存在定理："></a>原根存在定理：</h3><p>只有 $2,4,p^a,2p^a$，其中 $p$ 是大于 $2$ 的质数，$a$ 是正整数。</p>
<h3 id="离散对数："><a href="#离散对数：" class="headerlink" title="离散对数："></a>离散对数：</h3><p>模数为质数时，$\varphi(p)&#x3D;p-1$，对于 $g^i\equiv a\pmod p$，在 $i\in [1,p-1]$ 时 $a\in [1,p-1]$，因此 $i$ 和 $a$ 恰好一一对应。此时的 $\varphi(p)$ 同时也是阶。</p>
<p>因此 $g^i\equiv g^j\pmod p\rightarrow i\equiv j\pmod {p-1}$。</p>
<p>$g^i\times g^j\equiv g^{(i+j)\bmod p-1}\bmod p$</p>
<p>形式化地，$\prod g^{a_i}\equiv g^{\sum a_i\bmod p-1}\pmod p$。</p>
<p>观察到，这和整数对数的形式是一致的。</p>
<p>所以称 $g^i\equiv a\pmod p$ 的 $i$ 为 $a$ 的离散对数，模数的原根不唯一，因此根据不同的 $g$，可得 $a$ 不同的离散对数 $i$。通常写作 $\text{ind}_ga$。</p>
<p>形式化地，$\text{ind}_ga+\text{ind}_gb&#x3D;\text{ind}_gab,\text{ind}_ga-\text{ind}_gb&#x3D;\text{ind}_g{\frac{a}{b}},\text{ind}_ga^k&#x3D;k\text{ind}_ga$。</p>
<h4 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h4><p>在 NTT 做乘法卷积时，可以通过原根求离散对数转换成求离散对数的加法卷积。</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>计算几何-实战（一）</title>
    <url>/2024/03/11/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95-%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Winding-Number"><a href="#Winding-Number" class="headerlink" title="Winding Number"></a><a href="https://ac.nowcoder.com/acm/contest/27249/B">Winding Number</a></h2><p>题意简化：以任意顺序给定 $n$ 个点，$m$ 次询问，每次询问一个点为极点，</p>
]]></content>
      <categories>
        <category>计算几何</category>
      </categories>
  </entry>
</search>
